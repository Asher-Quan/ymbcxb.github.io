<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker---Docker容器数据卷]]></title>
    <url>%2F2019%2F04%2F29%2FDocker-Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%2F</url>
    <content type="text"></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-DockerFile]]></title>
    <url>%2F2019%2F04%2F29%2FDocker-DockerFile%2F</url>
    <content type="text"></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker初探]]></title>
    <url>%2F2019%2F04%2F23%2FDocker%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[Docker初识什么是Docker呢？ Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal)、OpenStack 集群和其他的基础应用平台。 简单点理解呢：Docker是一个管理容器的平台 简单介绍一下容器和虚拟机： 虚拟机：虚拟出一套硬件，在其之上的一个运行一个完整的操作系统 容器：容器之间互相隔离，但共享这同一份硬件系统 我们平时会在电脑上安装各种软件，比如微信，QQ。那么我们Docker呢，在想的是把一个系统看成一个软件，我们安装一个软件（本质是一个系统），比如，你现在的操作系统有很多软件，假设，你要换到一台新的电脑是不是要重新安装软件呢，这就很麻烦了，我们可以直接把你的系统当作一个软件，直接一安装就和你旧的电脑一摸一样了。 Docker的好处： 轻：开启速度快，因为不像Vmware那样子有一套虚拟化硬件，所以快 开发运维一致性：不会再对环境不一样起争议 弹性大：这点解释下，比如我现在一台服务器不够用的情况下，理论上是要新建一台服务器，但是新建的过程是很费时间的，因为有各种配置文件，所以，在Docker里，当不够用的时候，不过是安装多一个容器的事情，容器里面什么都做好了 安全：怎么捣鼓都是在容器里，实在不行，删了重建而已，不会影响导别的容器 附上一张图，以供了解： 那么Docker有几个核心概念： 仓库 镜像 容器 简单描述如下： 容器呢就是我们实际运行的东西 镜像呢就是用生成容器 这里可以这么理解为：用面向对象的思想来说，镜像就是类，容器就是实例对象 仓库呢就是用来放镜像的 首先简单跑一个Docker例子首先开启我们的虚拟机,我这里是Centos7，不同虚拟机可能有一点点差别，总体来说差别不大： 安装docker这里要注意一点： Centos 需要内核版本为3.8以及以上才能运行Docker (命令不包含$符号) 12//查看内核版本$ uname -r 12//安装docker$ sudo yum install docker 启动docker123456//启动 docker$ systemctl start docker//将 docker 服务设为开机启动$ systemctl enable docker//查看 docker版本，验证启动成功$ docker -v 拉取一个Centos镜像拉取之前，先要搜索 1$ docker search centos OFFICIAL ：代表官方 这里拉取的时候，默认是很慢的，因为使用的源地址是国外的，速度非常非常慢 为了提高速度，可以换取阿里或者网易的源 我这里使用的是阿里云 首先得注册一个阿里云账号，进入控制台找到 在这里可以看到加速器的地址，由于每个人的加速器地址，我这里就教下怎么配置 123456//打开配置文件$ vi /etc/docker/daemon.json//配置下面这段&#123; &quot;registry-mirrors&quot;: [&quot;https://xxxxx.mirror.aliyuncs.com&quot;]&#125; 接下来开始正式拉取镜像 1$ docker pull centos 12//查看所有镜像$ docker images 什么！！！只有两百M？对的，就是这么小，为什么，因为没有虚拟出一套物理硬件，单纯在硬件之上的层次，就这么小 默认的就是拉取最新版 如果想拉6的怎么办 指定一下就可以了 1$ docker pull centos:centos6 那么我怎么知道标签是多少呢？？？ 去官网https://hub.docker.com/_/centos查就可以了 最后一步！！！ 创建容器12//docker run 镜像名字:标签,这里 -it代表交互$ docker run -it centos:latest 此时就跑起来了 这就跑起来了一个建立在你虚拟机上的一个centos，而且秒开 你可以在这个界面里输入一些Linux指令也是可以行的，如果要退出 有两种方式 1234//第一种 退出容器，且杀死容器，说白了就容器没了$ exec //第二种，退出容器，且容器后台运行，可以重新进入$ ctrl+p+q 12//检查所有容器的状态$ docker ps -a 本章就到此结束了，算入个门吧，复杂的东西，后面再讲]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web登陆其实没那么简单]]></title>
    <url>%2F2019%2F04%2F11%2FWeb%E7%99%BB%E9%99%86%E5%85%B6%E5%AE%9E%E6%B2%A1%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95%2F</url>
    <content type="text"><![CDATA[一个简单的HTML例子看看用户信息安全标准的HTML语法中，支持在form表单中使用input标签来创建一个HTTP提交的属性，现代的WEB登录中，常见的是下面这样的表单： 12345&lt;form action = &quot;http://localhost:8080/Application/login&quot; method = &quot;POST&quot;&gt; 用户名：&lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot; /&gt; 密码：&lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;登陆&lt;/button&gt;&lt;/form&gt; form表单会在提交请求时,会获取form中input标签存在name的属性，作为HTTP请求的body中的参数传递给后台，进行登录校验。 例如我的账号是user1，密码是123456，那么我在提交登录的时候会给后台发送的HTTP请求如下（Chrome或者FireFox开发者工具捕获，需开启Preserve log）： 可以发现即便password字段是黑点，但是本机仍以明文的形式截获请求。 HTTP协议传输直接暴露用户密码字段在网络传输过程中，被嗅探到的话会直接危及用户信息安全，以Fiddler或Wireshark为例，发现捕获的HTTP报文中包含敏感信息： 使用加密算法能保证密码安全吗？WEB前端可以通过某种算法，对密码字段进行加密后，在将密码作为Http请求的内容进行提交，常见的包括对称和非对称加密。 对称加密:采用对称密码编码技术，它的特点是文件加密和解密使用相同的密钥加密。 非对称加密:需要两个密钥，公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。 3.1 使用对称加密加密解密在前后台协商后，似乎是个不错的办法，比如，前台使用一个字符串位移+字符串反转的简单方法（举个例子，当然不能这么简单）。 那么这样简单的方法似乎可以混淆原密码，并且轻松由后台进行相反操作复原。但是这有两个缺点： 前后端加密解密需要同时修改代码； 前端加密无非是写在JS里，但是JS有风险被直接破解从而识别加密方法。 3.2非对称加密HTTPS就一定是安全的吗？非对称加密有着公钥私钥的存在，公钥可以随意获取，私钥是用来对公钥解密的本地存储，通过公私钥的机制似乎可以保证传输加密并且乃至现在还在使用的HTTPS就是基于这个原理。但是HTTPS就一定安全吗？HTTP存在两种可能的风险： HTTPS可以保证传输过程中的信息不被别人截获，但是细细思考下，HTTPS是应用层协议，下层采用SSL保证信息安全，但是在客户端和服务端，密文同样是可以被截获的； HTTPS报文在传输过程中，如果客户端被恶意引导安装“中间人”的WEB信任证书，那么HTTPS中的“中间人攻击”一样会将明文密码泄露给别人。 结论是，无论HTTP还是HTTPS，密码必须密文传输想想HTTPS也不能一定保障用户密码信息，那么就应该考虑在应用层之上再继续对密码进行保护，也就是编写代码来进行控制，而不依赖特定协议，比较容易想到的就是利用不可逆加密散列函数MD5(string)，用户在注册输入密码的时候，就存储MD5(password)值，并且在WEB端先进行MD5(password)，然后将密码传输至后台，与数据库中的密文进行比较（PS：MD5函数在指定位数的情况下，对相同字符串运算值相同）。优点比较明显： 保证了用户数据库内部的密码信息安全； 传输过程中无论如何都不会使得用户的密文被破解出原密码； 简单高效，执行以及编码难度都不大，各种语言都提供MD5支持，开发快。 那太好了！这样可以省下HTTPS的钱了，真是这样吗？回到开头的例子：用户输入的用户名是：user1，密码是：123456，那么不管在什么协议之下，可以看到实际发送的HTTP/HTTPS报文在MD5处理后是这样的： 没错，加密登录成功了。但是，当我们庆祝密码安全的时候，发现账户的钱突然不翼而飞。这是为什么呢？黑客却笑的很开心：因为他们并不一定要获取到你的密码明文，如果直接截获你的密码密文，然后发送给服务器不是一样可以登录吗？因为数据库里的不也是MD5(password)的一样的密文吗？HTTP请求被伪造，一样可以登录成功，从而攫取其他的数据或者转走余额。 这怎么办?其实并不难，有很多种解决方法？其实原理都是类似的：那就是服务器缓存生成随机的验证字段，并发送给客户端，当客户端登录时，把这个一并字段传给服务器，用于校验。 方案一：验证码MVC场景。控制器将把数据的Model封装到View中，这种存在Session的连接方式，允许了在Session中存取信息。那么我们可以利用一些开源的验证码生成工具，例如JAVA中的Kaptcha，在服务端存放生成一个验证码值以及一个验证码的生成图片，将图片以Base64编码，并返回给View，在View中解码Base64并加载图片，并于用户下次登录时再进行比对。 方案二：token令牌前后端分离场景。现在非常流行的前后端分离的开发模式大大提高了项目的开发效率。职责、分工明确，但是由于HTTP是无状态的（就是这一次请求并不知道上一次请求的内容），当用户登录时，根据用户的username作为key，生成随机令牌（例如UUID）作为value缓存在Redis中，并且将token返回给客户端，当客户端登录时，将完成校验，并且删除Redis中的那条缓存记录。 那么每次从服务器中获取认证的token，确实能保证HTTP请求是由前端传回来的了，因为token在每次登陆后都会删除并被重置，会导致黑客尝试重放账号密码数据信息来登陆的时候导致无法成功登陆。 总而言之，就是我拿到了账号以及密码的密文也登陆不了，因为，如果请求不包含后台认证的令牌token，是个非法请求。 可是还别高兴的太早，当心数据被篡改密码也加密了，黑客看不到明文了。加上Token了，登陆过程也没法再被截获重放了。可是想想这种情况，你在进行某宝上的网络支付，需要账号，密码，金额，token这四个字段进行操作，然后支付的时候你付了1块钱买了一袋包邮的小浣熊干脆面，某宝结算结束后，你发现你的账户余额被扣了1万元。这又是怎么回事呢？ 因为即便黑客不登录，不操作，一样要搞破坏：当请求路由到黑客这边的时候，截获数据包，然后也不需要登录，反正账号密码都是对的，token也是对的，那么把数据包的字段改改，搞破坏就可以了，于是把money改成了1万，再传给服务器，作为受害者就莫名其妙踩了这个坑。可这该怎么解决呢？其实原理类似于HTTPS里的数字签名机制，首先科普下什么是数字摘要以及数字签名： 什么是“数字摘要”我们在下载文件的时候经常会看到有的下载站点也提供下载文件的“数字摘要“，供下载者验证下载后的文件是否完整，或者说是否和服务器上的文件”一模一样“。其实，数字摘要就是采用单项Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文，这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的内容信息其摘要必定一致。 因此，“数字摘要“叫”数字指纹“可能会更贴切一些。“数字摘要“是HTTPS能确保数据完整性和防篡改的根本原因。 数字签名–水到渠成的技术假如发送方想把一份报文发送给接收方，在发送报文前，发送方用一个哈希函数从报文文本中生成报文摘要,然后用自己的私人密钥对这个摘要进行加密，这个加密后的摘要将作为报文的”签名“和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公用密钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认报文是从发送方发送且没有被遗漏和修改过！这就是结合“非对称密钥加解密”和“数字摘要“技术所能做的事情，这也就是人们所说的“数字签名”技术。在这个过程中，对传送数据生成摘要并使用私钥进行加密地过程就是生成”数字签名“的过程，经过加密的数字摘要，就是”数字签名“。 因此，我们可以在WEB端对之前案例中提到的username+MD5(password)+token通过签名，得到一个字段checkCode，并将checkCode发送给服务器，服务器根据用户发送的checkCode以及自身对原始数据签名进行运算比对，从而确认数据是否中途被篡改，以保持数据的完整性。 总结看似非常简单的WEB登录，其实里面也存在着非常多的安全隐患。这些安全完善的过程是在一个实际WEB项目中遇到的，上面的分析演化是在应对项目安全的检查中所提出的解决方案，多少会有很多不足的地方，希望一起交流探讨，共同进步！ 补充1：JS加密函数存在被破解问题： 12如果黑客通过阅读前端js源码,发现加密算法,是否意味他可以构造可以被服务端解密的checkCode 来欺骗服务端呢 ? 回答: 1摘要或加密JS算法不直接以静态文件的形式存在浏览器中，而是让WEB端去请求Server，服务器可以根据随机令牌token值决定返回一个相应随机的加密策略，以JS代码响应的方式返回，在异步请求响应中，加载JS摘要算法，这样客户端就可以动态加载数字摘要策略，保证无法仿造。 补充2：MD5存在隐患的问题问题： 1用MD5、SHA256 处理密码的过时了。。。现在 PBKDF、bcrypt 都在过时中。 回答： 123456789本文重点侧重于方法思路的介绍，并不一定是要使用MD5函数，可以使用其他的方式。MD5存在隐患，之前确实没有考虑太多，不过非常感谢园友指出，确实是这样的，主要思想是：对于MD5的破解，实际上都属于【碰撞】。比如原文A通过MD5可以生成摘要M，我们并不需要把M还原成A，只需要找到原文B，生成同样的摘要M即可。设MD5的哈希函数是MD5()，那么：MD5(A) = MMD5(B) = M任意一个B即为破解结果。B有可能等于A，也可能不等于A。大概意思也就是，截获了MD5加密后的密文，一样可以，找到一个不是原密码，但是加密后可以登陆成功的“伪原文”。 CSDN有一篇关于MD5风险的博客写的非常好，推荐一下：MD5算法如何被破解 从中可以看到一点，MD5函数确实能被反向“破解”，但是这个“破解”只是找到一个经过MD5运算后得到相同结果的原文，并非是用户的明文密码。但是这样会被破解登录的可能，确实是需要采用更完善的算法进行加密，再次感谢！]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Web登陆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一条SQL语句的执行过程]]></title>
    <url>%2F2019%2F04%2F09%2F%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Mysql基本架构示意图 大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。 Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL5.5.5 版本开始成为了默认存储引擎。 也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同 连接器连接器是连接我们客户端和服务器首先经过的第一个功能模块，当我们连接我们的Mysql的时候，首先就会执行一条语句 1mysql -h[ip地址] -P[端口号] -u[用户名] -p[密码] 这条语句做的事情就是让本机连接上远端或者本地的Mysql服务器，从而进行管理Mysql 此时连接器就是用来验证我们的用户名和密码是否正确的，正确则可以得到操作的权限，其实就是和我们网站的第一个入口—&gt;登陆是一个意思，进行用户验证 如果连接了之后,没有别的操作，则当前连接就正处于一个空闲状态 当连接上数据库的时候，会保持一个连接，这个连接是长连接，直到连接关闭，否则一直保持连接，中途所有的客户端请求，都由该连接进行工作。短连接只能保证客户端在某个时间段的请求由该连接进行工作，下次查询将会使用一个新的连接 使用长连接也会由问题： 因为长连接保持连接，所以长时间下来，当连接数很多的时候，所占用的内存就会很多 解决办法如下： 1.定期断开长连接 2.Mysql5.7版本之后，每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，速度会比较快 查询缓存我们首先可以查看mysql关于缓存的配置 query_cache_type: 查询缓存类型,是否打开缓存 可选项 1、0(OFF)：关闭 Query Cache 功能，任何情况下都不会使用 Query Cache； 2、1(ON)：开启 Query Cache 功能，但是当SELECT语句中使用SQL_NO_CACHE提示后，将不使用Query Cache； 3、2(DEMAND)：开启Query Cache 功能，但是只有当SELECT语句中使用了SQL_CACHE 提示后，才使用Query Cache。 备注1: 如果query_cache_type为on而又不想利用查询缓存中的数据，可以用下面的SQL： 1SELECT SQL_NO_CACHE * FROM my_table WHERE condition; 如果值为2，要使用缓存的话，需要使用SQL_CACHE开关参数： 1SELECT SQL_CACHE * FROM my_table WHERE condition; 但是大多情况下，建议不要使用查询缓存，因为查询缓存的失效非常频繁，任意一个表的更新操作，这个表上的所有查询缓存都会被清空了，所以查询缓存的命中率非常低，除非表中基本上只会涉及到查操作而很少更新操作的时候可以考虑使用查询缓存的方式 Mysql8.0没有查询缓存的功能，已被彻底抛弃 分析器往上说的，如果开启了缓存机制的，就在缓存里查，否则就要走分析器了，所谓分析器，就是判断你输入的这条语句到底是什么意思，是要做查操作呢还是更新操作呢，还是语法有错误呢，都是由分析器去做的事情 优化器经过了分析器，Mysql就知道你要做的是查还是更新还是什么，此时，到优化器，顾名思义，就是如何优化你查的方式 比如： 1select * from t1 join t2 using(ID) where t1.c = 10 and t2.d =20 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2里面 d 的值是否等于 20。 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1里面 c 的值是否等于 10。 这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。 执行器通过分析器，知道要做什么了，通过优化器知道选择什么的方式做了，执行器就是根据上面的两个结论去做，调用InnoDB引擎去取表中的数据 总结这就是Mysql的逻辑架构，对一个Sql语句完整执行流程的各个阶段有一个初步的认识]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos搭建git私服]]></title>
    <url>%2F2019%2F03%2F26%2FCentos%E6%90%AD%E5%BB%BAgit%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[Centos搭建GIT私服安装gitCentos默认自带Git 可以通过以下命令进行查看 1git --version 默认是1.8 创建用户123groupadd gitadduser git -g gitpassword git 先创建一个用户组 再在这个用户组里面创建一个用户 再给用户设置密码 创建authorized_keys文件1234567cd /home/gitmkdir .sshchmod 700 .sshtouch .ssh/authorized_keyschmod 600 .ssh/authorized_keyscd /homechown -R git:git git 要注意的是文件权限和所属用户。 (后续的git clone如果需要密码，很有可能是git用户没有访问authorized_keys文件的权限) 客户端创建密钥并上传1ssh-keygen -t rsa -C &quot;your_email&quot; 该命令会产生两个文件: id_rsa对应私钥，id_rsa.pub对应公钥。 将id_rsa.pub中的内容写到服务器的authorized_keys文件中。 如果有多个客户端，那么在authorized_keys文件中，一行保存一个客户端的公钥。 创建git仓库为了方便管理，所有的git仓库都置于同一目录下，假设为/home/gitrepo， 123cd /homemkdir gitrepochown git:git gitrepo 接下来创建git仓库：test.git 12cd gitrepogit init --bare test.git 把仓库所属用户改为git 1chown -R git:git test.git 注意每次新建的仓库，都要修改仓库的所属用户 git私服搭建完毕push 和 clone示例 打开git bash 1234git clone git@ip:/home/gitrepo/test.gitgit remote add origin git@ip:/home/gitrepo/test.gitgit push -u origin]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-进阶]]></title>
    <url>%2F2019%2F01%2F31%2FGit-%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Git进阶本地分支管理一个项目如果是你一个人开发，那就没什么，反正就一份项目，你想做哪个模块就做哪个模块但是这样子开发效率慢啊 要是两个人开发，开发效率提高一倍，那么怎么合并起来呢？？？ 如果说两个人做的地方，刚好互不影响，那很简单，学过数学的人都知道，直接合并起来嘛 问题来了！！！ 如果两个人做的地方有重复怎么办？？？一行一行对比，然后一行行改?还是说一个人做完再让另外一个人做？那这和一个人做有什么区别 这就太麻烦了 所以引入了分支管理！这是个好东西 创建分支根据上图我们可以知道，我们首先是有一个主干的(称为master分支) 我们每次提交，会多一个新的节点 提交越多，master分支也会边长 创建分支的代码：(新的分支名字为dev) 1git branch dev 我们可以看到一个*标记在master，这代表着我们操控着master分支假设我们要切换分支： 1git checkout dev (我们也有一个更加方便的代码，创建分支同时切换到该分支上)： 1git checkout -b dev 接下来，我们执行一次提交 然后我又返回到master里再提交一次 合并分支首先切换到master分支将dev分支合并到master分支下 1git merge dev 删除分支1git branch -d dev GitHub上实现分支管理上面说这么多，其实为了熟悉一下命令，还有通过一些图来表明，每个操作，到底发生了什么 接下来才是实际开发中会用到的，结合GitHub上讲解 首先我拉取一下我Github，我仓库里只有一个A.txt,里面有句Hello 我新建两个文件夹用来模拟两台电脑 接着做如下操作 然后把文件都添加到本地仓库中 接着在Git2里推送到github上的分支下12git checkout -b devgit push -u origin dev 这样子在Github上就有分支了 接着Git去上传自己的到github的master下1git push -u origin master 在创建一个文件夹Git3 分别把两个分支拉下来 1234567git clone 路径进入仓库git checkout dev git clone -b dev(分支名) 路径git checkout mastergit merge devgit push -u origin master]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门]]></title>
    <url>%2F2019%2F01%2F12%2FGit%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[版本控制器：首先了解Git之前要明白另外一样东西，那就是版本控制系统 什么叫版本控制系统呢？ 版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。 程序员写代码，学会一种版本控制器是必不可少的技能 写代码，少不了的就是不断的修改源代码，但是代码是一种很神奇的东西，你会发现，原本只有一个BUG的改着改着突然发现BUG数量不仅仅没有减少而且还增加，此时的心里感受，哈哈，应该要吐血，那么怎么办？我原来的代码也被我改掉了说白了就是已经没有的备份，那就凉了~ 好的，小白曾经是这么干的，比如说，出现BUG吗，那我要修改，修改之前，先拷贝一份现在的源文件，然后再去改，这样子就稳了 当然小白一开始做得还是很开心的，因为很简单啊，写的代码也不多，而且往往只是一个文件，随着小白的进步当中，代码往往牵涉到多个文件的修改，这样子也是可以ctrl+c和ctrl+v的，但是一是一个文件夹里密密麻麻的项目，二是，看着一堆副本一副本二，简直就是头疼啊！！！ 好啦，现在开始讲我们的版本控制器了 简单来说呢，版本控制器就是可以更加方便地对我们的代码进行管理 进入正题： Git:Git：分布式版本控制系统 那么有分布式那么就会有集中式，没错！ SVN就是集中式版本控制系统，本章不做介绍 Git很火的呢，怎么说，GitHub就是基于Git的基础上的 至于分布式版本系统控制系统和集中式版本控制系统，等我把Git和SVN讲解完再进行一个比较 Git的安装Git的安装可以参考官网https://git-scm.com/downloads直接下载后安装后就可以了，很简单 安装后在开始菜单中找到Git Bash鼠标右键也会有 Git的入门我首先创建了一个文件夹，专门进行讲解文件夹名字为Git，首先创建一个文件，名字为a.txt，内容为AAA 接下来进行提交 在文件夹里面右键 git Bash 初始化首先我们要初始化一个仓库，这个仓库是放在我们本机的 1git init 默认为隐藏的，要设置查看隐藏文件就可以看得到多了一个文件夹 添加将文件添加到仓库里 1git add a.txt 提交将文件提交到仓库里 1git commit -m &quot;version 1.0&quot; -m后面是本次提交的一个说明，就是提交的是什么东西(原则上可以省略，但是建议不要) git add 和 git commit的区别首先git add添加自己指定的文件git commit不可以，一次性将所有提交，不可指定文件 git add是先将文件添加到暂存区，git commit将暂存区里的文件一次性提交到仓库里！！！ 基本上简单的一个Git流程的上传部分就介绍完了 下载文件既然前面我们讲完了如何将文件上传到自己的仓库，那么我们现在要用到的情况下，怎么从仓库下载下来呢？？？ 现在为了模仿以下真实环境 我进行多了两次提交 第一次提交之前，在a.txt增加了一行BBB 第二次提交之前，在a.txt增加了一行CCC 接下来我们就要去查看记录了 1git log 当前TXT是这样子的 现在要恢复啦！！！见证奇迹的时刻——- 1git reset --hard HEAD^ 再打开文本，发现已经恢复了，用git log去查看的时候发现也确实少了一条记录HEAD代表的是当前版本HEAD^代表的是当前版本的上一个版本HEAD^^代表的是上上版本 HEAD~N 代表的是当前邦本的上N个版本 远程仓库GitHub是提供Git仓库托管服务的,所以首先要有一个GitHub账号 自行注册GitHub的账号，这个问题，不在这里描述了 其次注册完账号还有做一些事情 先创建一个SSH KEY 1ssh-keygen -t rsa -C &quot;邮箱&quot; 在C盘本地账号下有一个文件夹.ssh 里面有两个文件，分别是id_rsa.pub 和 id_rsa分别对应着公钥和私钥 登陆GitHub，打开Settings里有一个选项，SSH and GPG keys添加自己机子的公钥 因为Git支持SSH协议，所以添加了SSH KEY之后可以防止别人冒充来对我们的仓库进行恶意修改 添加文件到GitHub首先在GitHub里面创建一个Repository 比如说我创建了一个gitTest 然后回到git Bash添加远程仓库1git remote add origin git@github.com:用户名/仓库名字.git 那么对应删除远程仓库的命令：1git remote rm origin 现在我们添加成功之后，接下来就是要上传到远程仓库里面去了 1git push -u origin master 接着去刷新我们的仓库，发现文件已经提交上去了 GitHub上下载文件这个也很简单对应着一条命令就可以了 1git clone git@github.com:用户名/仓库名字.git 好了，本章对Git的介绍就讲到这里，这里只是入门，后面会有一些更加多的内容介绍，敬请关注~]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取网易云音乐]]></title>
    <url>%2F2019%2F01%2F12%2FPython%E7%88%AC%E5%8F%96%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[Python爬取网易云音乐首先放网址： https://music.163.com/ 通过Network我们可以找到我们的音乐url存放的位置 那么我们就简单啦，知道Ajax的请求页面，我们当然就可以直接爬取了，但是： 这个FormData好像不简单，那我怎么请求呢？ 第一直觉，就感觉是被加密了，不愧是网易云，有一套呢 那么肯定就是和JS脱离不了关系了，找到JS，然后保存到本地进行分析一下 把代码保存到本地，进行一些操作 加密用到了四个参数，那么我们可以打印一下这四个参数 那么问题来了，这JS文件在我的本地，我怎么让网站进行加载呢？ 对的，这里要运用到一个工具，Fiddler4 这是个什么东西呢 它能够记录并检查所有你的电脑和互联网之间的Http通讯，设置断点，查看所有的进出Fiddler的数据（cookie,html,css,js） 大概就是，在客户端和服务器之间创建一个代理服务器来对之间进行交互通讯信息进行监控 下载安装完成之后还要对Fiddler4进行配置： Tools—》Options 更详细的介绍，这里就不多说了 那么大概界面是这样的 接着我们打开网易云官网 把core.js拖拉都右边，钩上相应的选项，在最下面找到要替换的JS，最后点击一下save 就能发现上面的路径变了，上图是我已经替换好的了 接下来：在网易云上搜索一首歌，打开控制台 你会发现，居然这样子了： 打印成功了！ 再看XHR里面 我们的重点是url这个，所以我们只用关注第一个打印的，显然ids就是歌曲的序号 多试几组可以看出来一个问题就是： 后三个参数是不用管的 那么歌曲的序号又要怎么获取呢？最终找到的结果是在 然而这个页面也是加密的，很强，没事 我们再看看后台打印的东西 span class = “s-fc7”又是什么东西呢？ 经过测试，发现这是固定的值 整个Json不同的地方在于s，传入歌名就可以了 呼 offset是偏移量，与翻页数有关系 好了，接下来又得去看我们的JS代码，去分析加密过程了 1234567891011121314151617181920212223242526272829303132333435363738function a(a) &#123; var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;; for (d = 0; a &gt; d; d += 1) e = Math.random() * b.length, e = Math.floor(e), c += b.charAt(e); return c &#125; function b(a, b) &#123; var c = CryptoJS.enc.Utf8.parse(b) , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;) , e = CryptoJS.enc.Utf8.parse(a) , f = CryptoJS.AES.encrypt(e, c, &#123; iv: d, mode: CryptoJS.mode.CBC &#125;); return f.toString() &#125; function c(a, b, c) &#123; var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,&quot;&quot;,c), e = encryptedString(d, a) &#125; function d(d, e, f, g) &#123; var h = &#123;&#125; , i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h &#125; function e(a, b, d, e) &#123; var f = &#123;&#125;; return f.encText = c(a + e, b, d), f &#125; window.asrsea = d 首先看函数d 函数d首先有个i，这个i是一个随机的十六位字符串， 然后进行了两次加密，第一次是第一个参数和第四个参数进行加密，把结果返回出来后与i字符串进行第二次加密，这个encText就是我们的params 而通过我们的刚才打印结果来看，后三个参数是固定的，然而i是随机的，也就是我们可以固定一个参数（一个最不可能的坑你，就是每次随机刚好就是随机到我的字符串），也就是说h.encSecKey=c(i,e,f)也是固定的，那也没什么好看的了 最主要的还是我们的params参数的第一次加密，因为第二次加密是在第一次加密的结果和一个固定的字符串，所以也没有讨论的必要了 首先看看我们的加密算法： 12345678910#AES加密算法def AES_encrypt(text, key, iv): pad = 16 - len(text) % 16 if type(text)==type(b&apos;&apos;): text = str(text, encoding=&apos;utf-8&apos;) text = text + pad * chr(pad) encryptor = AES.new(key, AES.MODE_CBC, iv) encrypt_text = encryptor.encrypt(text) encrypt_text = base64.b64encode(encrypt_text) return encrypt_text 这里，要安装一下Crypto模块，不然会报错，模块找不到 接下来就是源代码了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from Crypto.Cipher import AESimport requestsimport base64import osimport codecsimport jsonfrom pypinyin import lazy_pinyinfrom urllib.request import urlretrieve# 后三个参数和i的值（随机的十六位字符串）b = &apos;010001&apos;c = &apos;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&apos;d = &apos;0CoJUm6Qyw8W8jud&apos;#随机的十六位字符串def createSecretKey(size): return (&apos;&apos;.join(map(lambda xx: (hex(ord(xx))[2:]), str(os.urandom(size)))))[0:16]#AES加密算法def AES_encrypt(text, key, iv): pad = 16 - len(text) % 16 if type(text)==type(b&apos;&apos;): text = str(text, encoding=&apos;utf-8&apos;) text = text + str(pad * chr(pad)) encryptor = AES.new(key, AES.MODE_CBC, iv) encrypt_text = encryptor.encrypt(text) encrypt_text = base64.b64encode(encrypt_text) return encrypt_text#得到第一个加密参数def Getparams(a,SecretKey): #0102030405060708是偏移量，固定值 iv = &apos;0102030405060708&apos; h_encText = AES_encrypt(a,d,iv) h_encText = AES_encrypt(h_encText,SecretKey,iv) return h_encText#得到第二个加密参数def GetSecKey(text, pubKey, modulus): text = text[::-1] rs = int(codecs.encode(text.encode(&apos;utf-8&apos;), &apos;hex_codec&apos;), 16) ** int(pubKey, 16) % int(modulus, 16) return format(rs, &apos;x&apos;).zfill(256)#得到表单的两个参数def GetFormData(a): SecretKey = createSecretKey(16) params = Getparams(a,SecretKey) enSecKey = GetSecKey(SecretKey,b,c) data = &#123; &quot;params&quot;:str(params,encoding=&apos;utf-8&apos;), &quot;encSecKey&quot;:enSecKey &#125; return datadef getOnePatam(): # 查询id的url url = &apos;https://music.163.com/weapi/cloudsearch/get/web?csrf_token=&apos; #伪装头部 head = &#123; &apos;Host&apos;: &apos;music.163.com&apos;, &apos;Origin&apos;:&apos;https://music.163.com&apos;, &apos;Referer&apos;:&apos;https://music.163.com/search/&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;, &#125; print(&quot;输入你想要下载的歌手&quot;) song_name = input() #第一个参数 song_name = &apos;&apos;.join(lazy_pinyin(song_name)) key = &apos;&#123;hlpretag:&quot;&quot;,hlposttag:&quot;&lt;/span&gt;&quot;,s:&quot;&apos;+song_name+&apos;&quot;,type:&quot;1&quot;,csrf_token:&quot;&quot;,limit:&quot;30&quot;,total:&quot;true&quot;,offset:&quot;0&quot;&#125;&apos; FormData = GetFormData(key) html = requests.post(url,headers=head,data=FormData) result = json.loads(html.text) return result[&apos;result&apos;][&apos;songs&apos;]#下载器：def download(name,id): # 获取歌曲的url的路径 song_url = &quot;https://music.163.com/weapi/song/enhance/player/url?csrf_token=&quot; # 伪装头部 headers = &#123; &apos;Host&apos;: &apos;music.163.com&apos;, &apos;Origin&apos;: &apos;https://music.163.com&apos;, &apos;Referer&apos;: &apos;https://music.163.com/&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos; &#125; # 把上个页面查询到的id放到第二个页面的第一个参数上 a =str(&#123;&apos;ids&apos;: &quot;[&quot;+str(id)+&quot;]&quot;, &apos;br&apos;: 320000, &apos;csrf_token&apos;: &quot;&quot;&#125;) FormData = GetFormData(a) response = requests.post(song_url,data = FormData,headers=headers) json_dict = json.loads(response.content) song_url=json_dict[&apos;data&apos;][0][&apos;url&apos;] print(song_url) folder = os.path.exists(&apos;songs&apos;) if not folder: os.makedirs(&apos;songs&apos;) path = os.path.join(&apos;songs&apos;,name+&quot;.mp3&quot;) urlretrieve(song_url,filename=path)if __name__ == &apos;__main__&apos;: song_list = getOnePatam() for i in song_list: name = i[&apos;name&apos;] id = i[&apos;id&apos;] download(name,id) 以下是效果图 这次程序重点的是对加密的网页，学会如何去处理 有一点要强调一下，因为如果是中文，会导致加密的时候字符串长度不匹配的问题，所以只能用拼音，所以这里加了一个中文转拼音的库，pypinyin的lazy_pinyin()的方法]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr集群版的搭建]]></title>
    <url>%2F2019%2F01%2F10%2FSolr%E9%9B%86%E7%BE%A4%E7%89%88%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Solr集群版的搭建搭建Solr集群 首选需要配置zookeeper集群 先搭建四个tomcat 1234cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat01cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat02cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat03cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat04 1234vim tomcat01/conf/server.xmlvim tomcat02/conf/server.xmlvim tomcat03/conf/server.xmlvim tomcat04/conf/server.xml 给不同的Tomcat修改端口，tomcat01为81，tomcat02为82,以此类推，主要修改以下三个地方 把单机版的Solr放到Tomcat下 1234cp -r solr /home/app/solr-cloud/tomcat01/webapps/cp -r solr /home/app/solr-cloud/tomcat02/webapps/cp -r solr /home/app/solr-cloud/tomcat03/webapps/cp -r solr /home/app/solr-cloud/tomcat04/webapps/ 再复制四个solrhome到solr-cloud目录下 再修改每个solrhome下的solr.xml 注意写自己的端口号和IP地址 修改每个tomcat的solr的web.xml 修改catalina文件 1234vim tomcat01/bin/catalina.shvim tomcat02/bin/catalina.shvim tomcat03/bin/catalina.shvim tomcat04/bin/catalina.sh tomcat运行catalinda.sh脚本命令 配置JAVA_OPTS 1JAVA_OPTS=&quot;-DzkHost=192.168.25.130:2181,192.168.25.130:2182,192.168.25.130:2183&quot; 在solr文件下的example目录下的script目下的cloud-scripts目录下有个zkcli.sh 上传配置文件至zookeeper的命令 1./zkcli.sh -zkhost 192.168.25.130:2181,192.168.25.130:2182,192.168.25.130:2183 -cmd upconfig -confdir /home/quan/app/solr-cloud/solrhome01/collection1/conf/ -confname myconf 进入solr-cloud的zookeeper01中的bin目录下进行连接zookeeper 1./zkCli.sh -server 192.168.25.130:2182 检查一下 1./zkCli.sh -server 192.168.25.130:2182 myconf就是我们上传的 内容里面有我们上传的solr文件 整个搭建就完成了 开启四个Tomcat 1234/home/quan/app/solr-cloud/tomcat01/bin/startup.sh/home/quan/app/solr-cloud/tomcat02/bin/startup.sh/home/quan/app/solr-cloud/tomcat03/bin/startup.sh/home/quan/app/solr-cloud/tomcat04/bin/startup.sh SolrCloud创建Collection的命令 1http://192.168.25.130:8180/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;relicationFactor=2 SolrCloud删除Collection的命令 1http://192.168.25.130:8180/solr/admin/collections?action=DELETE&amp;name=collection1]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例]]></title>
    <url>%2F2019%2F01%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 说白了就是：就是使用设计模式，代码会更好。 单例模式：就是单个实例 那么单例模式有什么好处呢？ 很简单，首先，都是单个实例了，那么就可以怎样 一、实例控制 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。 二、灵活性 因为类控制了实例化过程，所以类可以灵活更改实例化过程。 但是还是有缺点的： 一、开销 虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。 二、可能的开发混淆 使用单例对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用new关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。 三、对象生存期 不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于.NET Framework的语言），只有单例类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如 C++），其他类可以删除对象实例，但这样会导致单例类中出现悬浮引用。。 单例模式根据实例化对象时机的不同分为两种 饿汉式 上代码 12345678910public class Single&#123; /*私有化，防止外部创建实例*/ private Single&#123;&#125; /*设置静态属性私有，防止外部通过类名访问*/ private static Single single = new Single(); /*设置静态方法*/ public static Single getInstance()&#123; return single; &#125;&#125; 这个很简单的 上面有个问题，当类加载的时候，就会实例化Single（），假如我加载完类，一段时间没用，而实例却已经早就创建了，着就会造成一个浪费。 通过这个问题，我们可以想，当我们需要实例的时候我们才去实例化，而不是通过类加载，那么我们可以这样子做 懒汉式 12345678910111213public class Single&#123; /*私有化，防止外部创建实例*/ private Single&#123;&#125; /*设置静态属性私有,先设空，需要的时候再实例化*/ private static Single single=null; /*设置静态方法*/ public static Single getInstance()&#123; if(single==null)&#123; single = new Single() &#125; return single &#125;&#125; 这样子，就没什么问题了 但是现在再思考一个问题，万一是多线程的时候呢？这样就有问题的了 这样子我们就需要加一个锁 12345678910111213141516171819public class Single&#123; /*私有化，防止外部创建实例*/ private Single&#123;&#125; /*设置静态属性私有,先设空，需要的时候再实例化*/ private static Single single=null; /*设置静态方法*/ public static Single getInstance()&#123; /*两重判空是为了提高效率*/ if(single==null)&#123; /*上锁*/ synchronized(Single.Class)&#123; if (single==null) &#123; single = new Single() &#125; &#125; &#125; return single; &#125;&#125; 这样子整个单例模式就做得比较好了]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程]]></title>
    <url>%2F2018%2F12%2F28%2FJava%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是线程？ 线程是一个程序里的不同执行路径 一般的程序是从一个入口出发，沿着唯一的路径走到终点，而线程则使唯一的路径变成多条路径 以下是单线程操作 123456789101112131415161718192021class A extends Thread&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.run(); while(true) &#123; System.out.println(&quot;hello JAVA&quot;); &#125; &#125;&#125; 因为aa.run没有执行完毕，下面的while循环就不会执行，所以就是一直输出“hello world“再看看多线程操作 123456789101112131415161718192021class A extends Thread&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); while(true) &#123; System.out.println(&quot;hello JAVA&quot;); &#125; &#125;&#125; Thread中的start方法就是创建一个线程，并且自动调用run方法，直接调用run方法是不会创建一个线程的。执行一个线程，其实就是执行一个线程里面的run方法，一个Thread对象不能调用两次start方法，否则会抛出异常。把aa.run改成aa.start结果就是两个循环交替执行，这就是多线程。单线程就是一条路径，从头到尾执行。多线程就是有多条路径，每次都可以走不同的路径。 执行aa.start并不代表aa对象的线程就立刻执行，而是得到了能够被CPU执行的资格，也就是就绪的状态。创建线程的第二种方式： 12345678910111213141516171819202122class A implements Runnable&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125;public class Thread2 &#123; public static void main(String[]args) &#123; A aa=new A(); Thread th=new Thread(aa); th.start(); while(true) &#123; System.out.println(&quot;hello JAVA&quot;); &#125; &#125;&#125; Thread常用方法： setName（String）设置名字 currentThread（）返回正在执行线程的对象 getName（）返回线程的名字 12345678910111213141516171819class A extends Thread&#123; public void run() &#123; System.out.println(&quot;hello world&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); System.out.println(&quot;hello JAVA&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125; 123456789101112131415161718class A extends Thread&#123; public void run() &#123; System.out.println(&quot;hello world&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.setName(&quot;123&quot;); aa.start(); System.out.println(&quot;hello JAVA&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125; Thread的sleep方法sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。要捕获异常！ 123456789101112131415161718192021222324class A extends Thread&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+i); try&#123; Thread.sleep(1000); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); &#125;&#125; Thread的join方法：如a.join（）；暂停当前正在执行的线程，直到a的线程运行终止之后当前线程才有机会得到执行，注意：不是暂停a对象的线程，而是当前运行的线程12345678910111213141516171819202122232425262728class A extends Thread&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); try&#123; aa.join(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125; **Thread的优先级： getPriority:获取优先级 setPriority:设置优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。 线程调度器用数字表现，范围从一到十，一个线程默认是5。 通常优先级高的比优先级低的要先执行，但并不是一定的！因为实际开发中并不单纯依赖优先级来决定优先级的运行顺序** 1234567891011121314151617181920212223242526272829class A implements Runnable&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(&quot;A&quot;+i); &#125; &#125;&#125;class B implements Runnable&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(&quot;B&quot;+i); &#125; &#125;&#125;public class Thread3 &#123; public static void main(String[]args) &#123; Thread t1=new Thread(new A()); Thread t2=new Thread(new B()); t1.setPriority(Thread.MIN_PRIORITY); t2.setPriority(Thread.MAX_PRIORITY); t1.start(); t2.start(); &#125;&#125; 优先级越高！越容易被CPU先调用！ 线程的同步卖票系统！ 假如有三个地方，A,B,C同时卖票 假如代码写成这样 12345if(票数大于0)&#123; 买票 票数-1&#125; 当A发现票大于0的时候，本应该执行下一步，假如此时CPU切换的B线程的时候，发现票数大于0（因为在A线程里面，票数没有减一），当在B中发现票数大于0之后，假如CPU又切换到C线程里面，发现票数还是大于0（同理）假如票只有一张，那么此时就相当于一张票被卖了三次。这将产生错误！ 123456789101112131415161718192021222324252627282930class A implements Runnable&#123; private int tickets=100; public void run() &#123; while(true) &#123; if(tickets&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;); tickets--; &#125; else &#123; break; &#125; &#125; &#125;&#125;public class Thread4 &#123; public static void main(String[]args) &#123; A a=new A(); Thread t1=new Thread(a); t1.start(); A b=new A(); Thread t2=new Thread(b); t2.start(); &#125;&#125; 以上代码运行结果： 每张票都被卖出去两次！！！这是不合理的 导致这个的原因是a对象和b对象都有一个属于自己的tickets 100 那么接下来看以下程序 123456789101112131415161718192021222324252627282930class A implements Runnable&#123; static int tickets=100; public void run() &#123; while(true) &#123; if(tickets&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;); tickets--; &#125; else &#123; break; &#125; &#125; &#125;&#125;public class Thread4 &#123; public static void main(String[]args) &#123; A a=new A(); Thread t1=new Thread(a); t1.start(); A b=new A(); Thread t2=new Thread(b); t2.start(); &#125;&#125; 把票数改成静态的结果是这样的： 那么来分析一下这个结果是为什么，当Thread-0发现票数是100的时候执行卖出操作，然后立刻切换的线程1然后发现还是100但是没有执行卖出操作又转换为线程0，此时减一然后就变成99、98、97、96、95、这个时候立刻切换成线程1执行卖出操作，打印出来。 简单来说：CPU会在线程之间来回切换！好的，重点来了！Synchronized—同步1234567891011121314151617181920212223242526272829303132class A implements Runnable&#123; static int tickets=100; public void run() &#123; while(true) &#123; synchronized(this) &#123; if(tickets&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;); tickets--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class Thread4 &#123; public static void main(String[]args) &#123; A a=new A(); Thread t1=new Thread(a); Thread t2=new Thread(a); t1.start(); t2.start(); &#125;&#125; 结果如下： synchronized 关键字，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。它包括两种用法：synchronized 方法和 synchronized 块。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP手动搭建环境]]></title>
    <url>%2F2018%2F12%2F28%2FPHP%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[php环境手动搭建php下载路径https://windows.php.net/download（注意一点的是要下线程安全的Thread Safe） Apache下载路径http://httpd.apache.org/docs/current/platform/windows.html Mysql下载路径https://dev.mysql.com/downloads/mysql/ Apache的安装 这里注意，请先把你的Apache的目录放置好再进行安装，否则安装后再移动位置，会出问题进入Apache目录下的conf目录修改httpd.conf大概在38行附近修改成如下：路径使用自己Apache的安装位置12Define SRVROOT &quot;E:\Apache24&quot; ServerRoot &quot;$&#123;SRVROOT&#125;&quot; 用管理员模式开启CMD进入Apache的bin目录下 命令行httpd -k install进行安装可以使用httpd -t进行测试，是否安装成功 注意事项如果失败，导致原因有可能是： 端口被占用 解决办法： netstat -aon | findstr :80 查看端口是否正在被监听，如果被监听了，有两种方法1. 修改Apache的端口，打开Apache的conf目录下修改httpd.conf,查找Listen关键字 找到 Listen 80 修改到你想设置的端口即可 2. 停止正在监听的服务，打开资源管理器，找到对应的PID，停止运行 这里默认上面三个已经下载好而且已经安装好了 正题：Apache和PHP整合在Apache的conf目录下的httpd.conf文件中加入下面三行代码 12345678#加载PHP模块LoadModule php7_module &quot;E:/php7/php7apache2_4.dll&quot;#当执行后缀为php的文件，就去找这个模块执行AddType Application/x-httpd-php .php#载入php配置文件PHPIniDir &quot;E:/php7&quot; 路径选择你们的位置 在php目录下拷贝php.ini-development改名为php.ini在文件里面进行如下修改(目录为个人的目录)1extension_dir = &quot;E:/php7/ext&quot; 在apache里面有个htdocs目录在里面写入一个php文件比如:test.php123&lt;?php phpinfo(); ?&gt; 在浏览器输入localhost/test.php 如果能够正确显示则配置完成]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr单机版的搭建]]></title>
    <url>%2F2018%2F12%2F27%2FSolr%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Solr Solr是一个开源搜索平台，用于构建搜索应用程序。 它建立在Lucene(全文搜索引擎)之上。 Solr是企业级的，快速的和高度可扩展的。 使用Solr构建的应用程序非常复杂，可提供高性能。 solr的一些突出的特点： Restful APIs − 要与Solr通信，并非一定需要有Java编程技能。相反，您可以使用restful服务与它通信。可使用文件格式(如xml，json和.CSV)在Solr中作为输入文档，并以相同的文件格式获取结果。 全文搜索 - Solr提供了全文搜索所需的所有功能，例如令牌，短语，拼写检查，通配符和自动完成。 企业准备 - 根据企业/组织的需要，Solr可以部署在任何类型的系统(大或小)，如独立，分布式，云等。灵活和可扩展 - 通过扩展Java类并相应配置，可以轻松地定制Solr的组件。 NoSQL数据库 - Solr也可以用作大数据量级的NOSQL数据库，可以沿着集群分布搜索任务。 管理界面 - Solr提供了一个易于使用，用户友好，功能强大的用户界面，使用它可以执行所有可能的任务，如管理日志，添加，删除，更新和搜索文档。 高度可扩展 - 在使用Solr与Hadoop时，我们可以通过添加副本来扩展其容量。 以文本为中心并按相关性排序 - Solr主要用于搜索文本文档，结果根据与用户查询的相关性按顺序传送 Solr单机版的搭建：解压solr和tomcat12tar zxf solr-4.10.3.tgz.tgztar -zxf apache-tomcat-7.0.47.tar.gz 把solr的war包放到tomcat的webapp目录下1cp solr-4.10.3/dist/solr-4.10.3.war /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr.war cp solr-4.10.3/example/lib/ext/* /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/lib/123配置一下solrhome vim /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/web.xml12修改solr的web.xml vim /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/web.xml` 再重新启动一次Tomcat 在浏览器里访问一下 localhost:8080/solr会出现以下界面 整个Solr服务就启动完成了]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程和进程]]></title>
    <url>%2F2018%2F12%2F20%2F%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[计算机所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例 单核CPU也就是单个核心的CPU，每次只能执行一个进程，由于CPU在各进程之间快速切换，所以每个进程所执行的时间是不确定的。 举个例子： 假设你在看着食谱做美食，那么你就相当于CPU，食谱就是程序，而做美食的材料就是输入数据，进程就是，你在阅读食谱取食材以及制作美食的这一系列动作，假设你在做美食时候突然来了个电话，你可能会先熄火，然后脑海里知道自己现在做到哪个位置（保存当前状态），然后去接电话，处理完了后，你可能才回来厨房想想刚才做到哪里了，然后继续之前继续做 一个进程就是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被多个进程共享，CPU使用了某种调度算法决定何时停止一个进程的工作，并且转向另一个进程提供服务。 进程的创建：有四种主要的事件1、系统初始化 前台进程 守护进程2、正在运行的程序执行了创建进程的系统调用3、用户请求创建一个新进程4、一个批处理作业的初始化 进程的终止1、正常退出2、出错退出3、严重错误4、被其他进程给杀死 只可以有一个父进程，但可以有零个或者多个子进程 进程有三种状态：运行态，就绪态，阻塞态 ​ 为了实现进程模型，操作系统维护着一张表格（一个结构数组）即进程表，每个进程占用一个进程表的一个项，这张表包含了许多信息，比如程序计数器，堆栈指针，内存分配状况，等等从而保证了该进程被断掉后重新启动的时候，能够保存之前的信息。 线程为什么需要线程？ 首先，有了线程，我们可以不必考虑终端、定时器、和上下文的切换只需考虑并行进程。其次，线程比进程更加轻量级，速度会比用进程效率要提高很多。 每个单核处理器在某个时刻也是只能够执行一个线程的，这和进程是一样的，线程是CPU处理的基本单位，我们前面讨论的进程，是进程单线程模型。 同样的，线程也是有阻塞态、运行态、就绪态。 为了实现可移植的线程程序，IEEE在IEEE标准中定义了线程的标准，它定义的线程包叫做pthread 实现线程包有两种方法，第一种把整个线程包放在用户空间 从内核的角度上管理的就是单线程进程的模型，这样子尽管系统不支持线程，也可以进行实现 用C语言实现1234567891011121314151617181920212223#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define NUMBER 10void *hello(void *id)&#123; printf(&quot;Thread-----%d\n&quot;,id); pthread_exit(NULL);&#125;int main()&#123; pthread_t threads[NUMBER]; int status; int i; for(i=0;i&lt;NUMBER;i++)&#123; printf(&quot;Main---Creating thread%d\n&quot;,i); status = pthread_create(&amp;threads[i],NULL,hello,(void*)i); if(status!=0)&#123; printf(&quot;ErrorCode----&gt;%d\n&quot;,status); exit(-1); &#125; &#125; return 0;&#125; 在用户空间管理线程的时候会创建一个运行时的系统，由这个系统进行管理，每个进程都需要其专用的线程表，用来跟踪该进程中的线程。这些表和进程表相似，不过它仅仅记录的是各个线程的属性，如每个线程的程序计数器，堆栈指针，寄存器和状态。因为切换线程的时候不需要陷入到内核空间，不需要有上下文的切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。 用户线程还有一个优点，允许每个进程有自己定制的调度算法，这样子就有一个很好的可扩展性 如果某个线程阻塞了，就会导致整个进程的阻塞 在内核中实现线程 此时不再需要运行时的系统了，另外，每个进程中也没有线程表，内核中有用来记录系统中所有线程的线程表了，当某个线程希望创建一个新的线程的时候，就会进行一个系统的调用，这个系统调用通过对线程表的更新完成线程创建的工作。 内核的线程表里保存了每个线程的信息，这些信息和在用户空间中的线程是一样的，但是现在保存在内核中 由于在内核中创建线程的代价比较大，所以某些系统会采取一种方式：回收线程，当某个线程被撤销的时候，就标记为不可运行的，但是其内核数据的结构没有收到影响。再次创建一个新的线程的时候，就把这个线程给重新启动就可以了，这样子可以减少多次系统调用来开辟新的线程 混合实现 使用内核级的线程，然后将用户级的线程与某些或者全部内核线程多路复用，采取这种方式：开发人员就可以决定有多少个内核级的线程和多少个用户级线程即使多路复用，这个模型可以带来最大的灵活度 进程之间的通信比如说一个购票系统： 进程A和进程B，此时：进程A去买票（一共十张）：首先读出票数，把票数减一，然后把减一后的数据放回去 假设在第二个步骤的时候发生CPU 的切换，进程B去读票数，那么去读的时候此时票数还是10，然后进行减一后，放回去，再切回线程A，放回去，这里就有个问题：同一张票给了两个进程去卖了！这明显是不科学的。 为了有效避免进程的竞争问题这里需要做的就是互斥，那么什么是互斥呢？就是A在访问的时候，禁止B访问，这样子就能够进行一个有效的防止竞争了。 这里面设计很多种方法： 屏蔽中断：每个进程在刚刚进入临界区后立刻屏蔽所有中断，并在就有离开之前再打开终端，屏蔽中断后，时钟中断也会被屏蔽，CPU只有发生时钟中断或者其他中断才会进行切换，这样子，在屏蔽中断之后，CPU将不会进行切换 锁变量：共享一个变量（锁），初始值为0，当一个进程进入临界区的时候，就测试这把锁，如果该锁为0则进程把锁设置为1，然后进入，如果进入的时候锁的值为1，则等待，当出去临界区的时候再把锁的值改为0 严格轮换法： 严格轮换法同样也是针对一个临界区设置一个变量,假设为Turn。以两个进程为例子: 当Turn为0时,Process 0才能能进入临界区,否则等待。等Process 0离开临界区后,将Turn设置为1. 当Turn为1时,Process 1才能进入临界区,否则等待。等Process 1离开临界区后,将Turn设置为0.]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
