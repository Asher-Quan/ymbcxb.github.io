<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Laravel简单增删改查]]></title>
    <url>%2F2019%2F01%2F02%2FLaravel%E7%AE%80%E5%8D%95%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java线程]]></title>
    <url>%2F2018%2F12%2F28%2FJava%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是线程？ 线程是一个程序里的不同执行路径 一般的程序是从一个入口出发，沿着唯一的路径走到终点，而线程则使唯一的路径变成多条路径 以下是单线程操作 123456789101112131415161718192021class A extends Thread&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.run(); while(true) &#123; System.out.println(&quot;hello JAVA&quot;); &#125; &#125;&#125; 因为aa.run没有执行完毕，下面的while循环就不会执行，所以就是一直输出“hello world“再看看多线程操作 123456789101112131415161718192021class A extends Thread&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); while(true) &#123; System.out.println(&quot;hello JAVA&quot;); &#125; &#125;&#125; Thread中的start方法就是创建一个线程，并且自动调用run方法，直接调用run方法是不会创建一个线程的。执行一个线程，其实就是执行一个线程里面的run方法，一个Thread对象不能调用两次start方法，否则会抛出异常。把aa.run改成aa.start结果就是两个循环交替执行，这就是多线程。单线程就是一条路径，从头到尾执行。多线程就是有多条路径，每次都可以走不同的路径。 执行aa.start并不代表aa对象的线程就立刻执行，而是得到了能够被CPU执行的资格，也就是就绪的状态。创建线程的第二种方式： 12345678910111213141516171819202122class A implements Runnable&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125;public class Thread2 &#123; public static void main(String[]args) &#123; A aa=new A(); Thread th=new Thread(aa); th.start(); while(true) &#123; System.out.println(&quot;hello JAVA&quot;); &#125; &#125;&#125; Thread常用方法： setName（String）设置名字 currentThread（）返回正在执行线程的对象 getName（）返回线程的名字 12345678910111213141516171819class A extends Thread&#123; public void run() &#123; System.out.println(&quot;hello world&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); System.out.println(&quot;hello JAVA&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125; 123456789101112131415161718class A extends Thread&#123; public void run() &#123; System.out.println(&quot;hello world&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.setName(&quot;123&quot;); aa.start(); System.out.println(&quot;hello JAVA&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125; Thread的sleep方法sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。要捕获异常！ 123456789101112131415161718192021222324class A extends Thread&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+i); try&#123; Thread.sleep(1000); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); &#125;&#125; Thread的join方法：如a.join（）；暂停当前正在执行的线程，直到a的线程运行终止之后当前线程才有机会得到执行，注意：不是暂停a对象的线程，而是当前运行的线程12345678910111213141516171819202122232425262728class A extends Thread&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); try&#123; aa.join(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125; **Thread的优先级： getPriority:获取优先级 setPriority:设置优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。 线程调度器用数字表现，范围从一到十，一个线程默认是5。 通常优先级高的比优先级低的要先执行，但并不是一定的！因为实际开发中并不单纯依赖优先级来决定优先级的运行顺序** 1234567891011121314151617181920212223242526272829class A implements Runnable&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(&quot;A&quot;+i); &#125; &#125;&#125;class B implements Runnable&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(&quot;B&quot;+i); &#125; &#125;&#125;public class Thread3 &#123; public static void main(String[]args) &#123; Thread t1=new Thread(new A()); Thread t2=new Thread(new B()); t1.setPriority(Thread.MIN_PRIORITY); t2.setPriority(Thread.MAX_PRIORITY); t1.start(); t2.start(); &#125;&#125; 优先级越高！越容易被CPU先调用！ 线程的同步卖票系统！ 假如有三个地方，A,B,C同时卖票 假如代码写成这样 12345if(票数大于0)&#123; 买票 票数-1&#125; 当A发现票大于0的时候，本应该执行下一步，假如此时CPU切换的B线程的时候，发现票数大于0（因为在A线程里面，票数没有减一），当在B中发现票数大于0之后，假如CPU又切换到C线程里面，发现票数还是大于0（同理）假如票只有一张，那么此时就相当于一张票被卖了三次。这将产生错误！ 123456789101112131415161718192021222324252627282930class A implements Runnable&#123; private int tickets=100; public void run() &#123; while(true) &#123; if(tickets&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;); tickets--; &#125; else &#123; break; &#125; &#125; &#125;&#125;public class Thread4 &#123; public static void main(String[]args) &#123; A a=new A(); Thread t1=new Thread(a); t1.start(); A b=new A(); Thread t2=new Thread(b); t2.start(); &#125;&#125; 以上代码运行结果： 每张票都被卖出去两次！！！这是不合理的 导致这个的原因是a对象和b对象都有一个属于自己的tickets 100 那么接下来看以下程序 123456789101112131415161718192021222324252627282930class A implements Runnable&#123; static int tickets=100; public void run() &#123; while(true) &#123; if(tickets&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;); tickets--; &#125; else &#123; break; &#125; &#125; &#125;&#125;public class Thread4 &#123; public static void main(String[]args) &#123; A a=new A(); Thread t1=new Thread(a); t1.start(); A b=new A(); Thread t2=new Thread(b); t2.start(); &#125;&#125; 把票数改成静态的结果是这样的： 那么来分析一下这个结果是为什么，当Thread-0发现票数是100的时候执行卖出操作，然后立刻切换的线程1然后发现还是100但是没有执行卖出操作又转换为线程0，此时减一然后就变成99、98、97、96、95、这个时候立刻切换成线程1执行卖出操作，打印出来。 简单来说：CPU会在线程之间来回切换！好的，重点来了！Synchronized—同步1234567891011121314151617181920212223242526272829303132class A implements Runnable&#123; static int tickets=100; public void run() &#123; while(true) &#123; synchronized(this) &#123; if(tickets&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;); tickets--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class Thread4 &#123; public static void main(String[]args) &#123; A a=new A(); Thread t1=new Thread(a); Thread t2=new Thread(a); t1.start(); t2.start(); &#125;&#125; 结果如下： synchronized 关键字，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。它包括两种用法：synchronized 方法和 synchronized 块。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七巧板]]></title>
    <url>%2F2018%2F12%2F28%2F%E4%B8%83%E5%B7%A7%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;,style=&quot;border:1px solid #aaa;&quot;&gt;&lt;/canvas&gt; &lt;script&gt; var tangram=[ &#123;p:[&#123;x:0,y:0&#125;,&#123;x:800,y:0&#125;,&#123;x:400,y:400&#125;],color:&quot;blue&quot;&#125;, &#123;p:[&#123;x:0,y:0&#125;,&#123;x:400,y:400&#125;,&#123;x:0,y:800&#125;],color:&quot;#caff67&quot;&#125;, &#123;p:[&#123;x:800,y:0&#125;,&#123;x:800,y:400&#125;,&#123;x:600,y:600&#125;,&#123;x:600,y:200&#125;],color:&quot;#a594c0&quot;&#125;, &#123;p:[&#123;x:600,y:200&#125;,&#123;x:600,y:600&#125;,&#123;x:400,y:400&#125;],color:&quot;#ef3d61&quot;&#125;, &#123;p:[&#123;x:400,y:400&#125;,&#123;x:600,y:600&#125;,&#123;x:400,y:800&#125;,&#123;x:200,y:600&#125;],color:&quot;#f9f51a&quot;&#125;, &#123;p:[&#123;x:200,y:600&#125;,&#123;x:400,y:800&#125;,&#123;x:0,y:800&#125;],color:&quot;#fa8ecc&quot;&#125;, &#123;p:[&#123;x:800,y:400&#125;,&#123;x:800,y:800&#125;,&#123;x:400,y:800&#125;],color:&quot;#f6ca29&quot;&#125; ]; window.onload=function()&#123; var canvas=document.getElementById(&quot;canvas&quot;); if(canvas.getContext) &#123; var context=canvas.getContext(&apos;2d&apos;); &#125; else &#123; alert(&quot;当前浏览器不支持Canvas&quot;); &#125; for(var i=0;i&lt;tangram.length;i++) &#123; draw(tangram[i],context); &#125; function draw(piece,cxt) &#123; cxt.beginPath(); cxt.moveTo(piece.p[0].x,piece.p[0].y); for(var i=1;i&lt;piece.p.length;i++) &#123; cxt.lineTo(piece.p[i].x,piece.p[i].y); &#125; cxt.closePath(); cxt.fillStyle=piece.color; cxt.fill(); cxt.strokeStyle=&quot;black&quot;; cxt.lineWidth=3; cxt.stroke(); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP手动搭建环境]]></title>
    <url>%2F2018%2F12%2F28%2FPHP%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[php环境手动搭建php下载路径https://windows.php.net/download（注意一点的是要下线程安全的Thread Safe） Apache下载路径http://httpd.apache.org/docs/current/platform/windows.html Mysql下载路径https://dev.mysql.com/downloads/mysql/ Apache的安装 这里注意，请先把你的Apache的目录放置好再进行安装，否则安装后再移动位置，会出问题进入Apache目录下的conf目录修改httpd.conf大概在38行附近修改成如下：路径使用自己Apache的安装位置12Define SRVROOT &quot;E:\Apache24&quot; ServerRoot &quot;$&#123;SRVROOT&#125;&quot; 用管理员模式开启CMD进入Apache的bin目录下 命令行httpd -k install进行安装可以使用httpd -t进行测试，是否安装成功 注意事项如果失败，导致原因有可能是： 端口被占用 解决办法： netstat -aon | findstr :80 查看端口是否正在被监听，如果被监听了，有两种方法1. 修改Apache的端口，打开Apache的conf目录下修改httpd.conf,查找Listen关键字 找到 Listen 80 修改到你想设置的端口即可 2. 停止正在监听的服务，打开资源管理器，找到对应的PID，停止运行 这里默认上面三个已经下载好而且已经安装好了 正题：Apache和PHP整合在Apache的conf目录下的httpd.conf文件中加入下面三行代码 12345678#加载PHP模块LoadModule php7_module &quot;E:/php7/php7apache2_4.dll&quot;#当执行后缀为php的文件，就去找这个模块执行AddType Application/x-httpd-php .php#载入php配置文件PHPIniDir &quot;E:/php7&quot; 路径选择你们的位置 在php目录下拷贝php.ini-development改名为php.ini在文件里面进行如下修改(目录为个人的目录)1extension_dir = &quot;E:/php7/ext&quot; 在apache里面有个htdocs目录在里面写入一个php文件比如:test.php123&lt;?php phpinfo(); ?&gt; 在浏览器输入localhost/test.php 如果能够正确显示则配置完成]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer]]></title>
    <url>%2F2018%2F12%2F27%2Fcomposer%2F</url>
    <content type="text"><![CDATA[##composer]]></content>
      <categories>
        <category>技术分类</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr单机版的搭建]]></title>
    <url>%2F2018%2F12%2F27%2FSolr%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Solr Solr是一个开源搜索平台，用于构建搜索应用程序。 它建立在Lucene(全文搜索引擎)之上。 Solr是企业级的，快速的和高度可扩展的。 使用Solr构建的应用程序非常复杂，可提供高性能。 solr的一些突出的特点： Restful APIs − 要与Solr通信，并非一定需要有Java编程技能。相反，您可以使用restful服务与它通信。可使用文件格式(如xml，json和.CSV)在Solr中作为输入文档，并以相同的文件格式获取结果。 全文搜索 - Solr提供了全文搜索所需的所有功能，例如令牌，短语，拼写检查，通配符和自动完成。 企业准备 - 根据企业/组织的需要，Solr可以部署在任何类型的系统(大或小)，如独立，分布式，云等。灵活和可扩展 - 通过扩展Java类并相应配置，可以轻松地定制Solr的组件。 NoSQL数据库 - Solr也可以用作大数据量级的NOSQL数据库，可以沿着集群分布搜索任务。 管理界面 - Solr提供了一个易于使用，用户友好，功能强大的用户界面，使用它可以执行所有可能的任务，如管理日志，添加，删除，更新和搜索文档。 高度可扩展 - 在使用Solr与Hadoop时，我们可以通过添加副本来扩展其容量。 以文本为中心并按相关性排序 - Solr主要用于搜索文本文档，结果根据与用户查询的相关性按顺序传送 Solr单机版的搭建：解压solr和tomcat12tar zxf solr-4.10.3.tgz.tgztar -zxf apache-tomcat-7.0.47.tar.gz 把solr的war包放到tomcat的webapp目录下1cp solr-4.10.3/dist/solr-4.10.3.war /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr.war cp solr-4.10.3/example/lib/ext/* /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/lib/123配置一下solrhome vim /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/web.xml12修改solr的web.xml vim /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/web.xml` 再重新启动一次Tomcat 在浏览器里访问一下 localhost:8080/solr会出现以下界面 整个Solr服务就启动完成了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程和进程]]></title>
    <url>%2F2018%2F12%2F20%2F%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[计算机所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例 单核CPU也就是单个核心的CPU，每次只能执行一个进程，由于CPU在各进程之间快速切换，所以每个进程所执行的时间是不确定的。 举个例子： 假设你在看着食谱做美食，那么你就相当于CPU，食谱就是程序，而做美食的材料就是输入数据，进程就是，你在阅读食谱取食材以及制作美食的这一系列动作，假设你在做美食时候突然来了个电话，你可能会先熄火，然后脑海里知道自己现在做到哪个位置（保存当前状态），然后去接电话，处理完了后，你可能才回来厨房想想刚才做到哪里了，然后继续之前继续做 一个进程就是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被多个进程共享，CPU使用了某种调度算法决定何时停止一个进程的工作，并且转向另一个进程提供服务。 进程的创建：有四种主要的事件1、系统初始化 前台进程 守护进程2、正在运行的程序执行了创建进程的系统调用3、用户请求创建一个新进程4、一个批处理作业的初始化 进程的终止1、正常退出2、出错退出3、严重错误4、被其他进程给杀死 只可以有一个父进程，但可以有零个或者多个子进程 进程有三种状态：运行态，就绪态，阻塞态 ​ 为了实现进程模型，操作系统维护着一张表格（一个结构数组）即进程表，每个进程占用一个进程表的一个项，这张表包含了许多信息，比如程序计数器，堆栈指针，内存分配状况，等等从而保证了该进程被断掉后重新启动的时候，能够保存之前的信息。 线程为什么需要线程？ 首先，有了线程，我们可以不必考虑终端、定时器、和上下文的切换只需考虑并行进程。其次，线程比进程更加轻量级，速度会比用进程效率要提高很多。 每个单核处理器在某个时刻也是只能够执行一个线程的，这和进程是一样的，线程是CPU处理的基本单位，我们前面讨论的进程，是进程单线程模型。 同样的，线程也是有阻塞态、运行态、就绪态。 为了实现可移植的线程程序，IEEE在IEEE标准中定义了线程的标准，它定义的线程包叫做pthread 实现线程包有两种方法，第一种把整个线程包放在用户空间 从内核的角度上管理的就是单线程进程的模型，这样子尽管系统不支持线程，也可以进行实现 用C语言实现1234567891011121314151617181920212223#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define NUMBER 10void *hello(void *id)&#123; printf(&quot;Thread-----%d\n&quot;,id); pthread_exit(NULL);&#125;int main()&#123; pthread_t threads[NUMBER]; int status; int i; for(i=0;i&lt;NUMBER;i++)&#123; printf(&quot;Main---Creating thread%d\n&quot;,i); status = pthread_create(&amp;threads[i],NULL,hello,(void*)i); if(status!=0)&#123; printf(&quot;ErrorCode----&gt;%d\n&quot;,status); exit(-1); &#125; &#125; return 0;&#125; 在用户空间管理线程的时候会创建一个运行时的系统，由这个系统进行管理，每个进程都需要其专用的线程表，用来跟踪该进程中的线程。这些表和进程表相似，不过它仅仅记录的是各个线程的属性，如每个线程的程序计数器，堆栈指针，寄存器和状态。因为切换线程的时候不需要陷入到内核空间，不需要有上下文的切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。 用户线程还有一个优点，允许每个进程有自己定制的调度算法，这样子就有一个很好的可扩展性 如果某个线程阻塞了，就会导致整个进程的阻塞 在内核中实现线程 此时不再需要运行时的系统了，另外，每个进程中也没有线程表，内核中有用来记录系统中所有线程的线程表了，当某个线程希望创建一个新的线程的时候，就会进行一个系统的调用，这个系统调用通过对线程表的更新完成线程创建的工作。 内核的线程表里保存了每个线程的信息，这些信息和在用户空间中的线程是一样的，但是现在保存在内核中 由于在内核中创建线程的代价比较大，所以某些系统会采取一种方式：回收线程，当某个线程被撤销的时候，就标记为不可运行的，但是其内核数据的结构没有收到影响。再次创建一个新的线程的时候，就把这个线程给重新启动就可以了，这样子可以减少多次系统调用来开辟新的线程 混合实现 使用内核级的线程，然后将用户级的线程与某些或者全部内核线程多路复用，采取这种方式：开发人员就可以决定有多少个内核级的线程和多少个用户级线程即使多路复用，这个模型可以带来最大的灵活度 进程之间的通信比如说一个购票系统： 进程A和进程B，此时：进程A去买票（一共十张）：首先读出票数，把票数减一，然后把减一后的数据放回去 假设在第二个步骤的时候发生CPU 的切换，进程B去读票数，那么去读的时候此时票数还是10，然后进行减一后，放回去，再切回线程A，放回去，这里就有个问题：同一张票给了两个进程去卖了！这明显是不科学的。 为了有效避免进程的竞争问题这里需要做的就是互斥，那么什么是互斥呢？就是A在访问的时候，禁止B访问，这样子就能够进行一个有效的防止竞争了。 这里面设计很多种方法： 屏蔽中断：每个进程在刚刚进入临界区后立刻屏蔽所有中断，并在就有离开之前再打开终端，屏蔽中断后，时钟中断也会被屏蔽，CPU只有发生时钟中断或者其他中断才会进行切换，这样子，在屏蔽中断之后，CPU将不会进行切换 锁变量：共享一个变量（锁），初始值为0，当一个进程进入临界区的时候，就测试这把锁，如果该锁为0则进程把锁设置为1，然后进入，如果进入的时候锁的值为1，则等待，当出去临界区的时候再把锁的值改为0 严格轮换法： 严格轮换法同样也是针对一个临界区设置一个变量,假设为Turn。以两个进程为例子: 当Turn为0时,Process 0才能能进入临界区,否则等待。等Process 0离开临界区后,将Turn设置为1. 当Turn为1时,Process 1才能进入临界区,否则等待。等Process 1离开临界区后,将Turn设置为0.]]></content>
  </entry>
</search>
