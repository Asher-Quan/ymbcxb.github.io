<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>线程和进程</title>
      <link href="/2018/12/20/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/"/>
      <url>/2018/12/20/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>计算机所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例</p><p>单核CPU也就是单个核心的CPU，每次只能执行一个进程，由于CPU在各进程之间快速切换，所以每个进程所执行的时间是不确定的。</p><p>举个例子：</p><p>假设你在看着食谱做美食，那么你就相当于CPU，食谱就是程序，而做美食的材料就是输入数据，进程就是，你在阅读食谱取食材以及制作美食的这一系列动作，假设你在做美食时候突然来了个电话，你可能会先熄火，然后脑海里知道自己现在做到哪个位置（保存当前状态），然后去接电话，处理完了后，你可能才回来厨房想想刚才做到哪里了，然后继续之前继续做</p><p>一个进程就是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被多个进程共享，CPU使用了某种调度算法决定何时停止一个进程的工作，并且转向另一个进程提供服务。</p><p>进程的创建：有四种主要的事件<br>1、系统初始化<br>    前台进程<br>    守护进程<br>2、正在运行的程序执行了创建进程的系统调用<br>3、用户请求创建一个新进程<br>4、一个批处理作业的初始化</p><p>进程的终止<br>1、正常退出<br>2、出错退出<br>3、严重错误<br>4、被其他进程给杀死</p><p>只可以有一个父进程，但可以有零个或者多个子进程</p><p>进程有三种状态：<br>运行态，就绪态，阻塞态</p><p>​</p><p>为了实现进程模型，操作系统维护着一张表格（一个结构数组）即进程表，每个进程占用一个进程表的一个项，这张表包含了许多信息，比如程序计数器，堆栈指针，内存分配状况，等等从而保证了该进程被断掉后重新启动的时候，能够保存之前的信息。</p><p>线程<br>为什么需要线程？</p><p>首先，有了线程，我们可以不必考虑终端、定时器、和上下文的切换只需考虑并行进程。其次，线程比进程更加轻量级，速度会比用进程效率要提高很多。</p><p>每个单核处理器在某个时刻也是只能够执行一个线程的，这和进程是一样的，线程是CPU处理的基本单位，我们前面讨论的进程，是进程单线程模型。</p><p>同样的，线程也是有阻塞态、运行态、就绪态。</p><p>为了实现可移植的线程程序，IEEE在IEEE标准中定义了线程的标准，它定义的线程包叫做pthread</p><p>实现线程包有两种方法，第一种把整个线程包放在用户空间</p><p>从内核的角度上管理的就是单线程进程的模型，这样子尽管系统不支持线程，也可以进行实现</p><p>用C语言实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define NUMBER 10</span><br><span class="line">void *hello(void *id)&#123;</span><br><span class="line">    printf(&quot;Thread-----%d\n&quot;,id);</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t threads[NUMBER];</span><br><span class="line">    int status;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;NUMBER;i++)&#123;</span><br><span class="line">        printf(&quot;Main---Creating thread%d\n&quot;,i);</span><br><span class="line">        status = pthread_create(&amp;threads[i],NULL,hello,(void*)i);</span><br><span class="line">        if(status!=0)&#123;</span><br><span class="line">            printf(&quot;ErrorCode----&gt;%d\n&quot;,status);</span><br><span class="line">            exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在用户空间管理线程的时候会创建一个运行时的系统，由这个系统进行管理，每个进程都需要其专用的线程表，用来跟踪该进程中的线程。这些表和进程表相似，不过它仅仅记录的是各个线程的属性，如每个线程的程序计数器，堆栈指针，寄存器和状态。因为切换线程的时候不需要陷入到内核空间，不需要有上下文的切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。</p><p>用户线程还有一个优点，允许每个进程有自己定制的调度算法，这样子就有一个很好的可扩展性</p><p>如果某个线程阻塞了，就会导致整个进程的阻塞</p><p>在内核中实现线程</p><p>此时不再需要运行时的系统了，另外，每个进程中也没有线程表，内核中有用来记录系统中所有线程的线程表了，当某个线程希望创建一个新的线程的时候，就会进行一个系统的调用，这个系统调用通过对线程表的更新完成线程创建的工作。</p><p>内核的线程表里保存了每个线程的信息，这些信息和在用户空间中的线程是一样的，但是现在保存在内核中</p><p>由于在内核中创建线程的代价比较大，所以某些系统会采取一种方式：回收线程，当某个线程被撤销的时候，就标记为不可运行的，但是其内核数据的结构没有收到影响。再次创建一个新的线程的时候，就把这个线程给重新启动就可以了，这样子可以减少多次系统调用来开辟新的线程</p><p>混合实现</p><p>使用内核级的线程，然后将用户级的线程与某些或者全部内核线程多路复用，采取这种方式：开发人员就可以决定有多少个内核级的线程和多少个用户级线程即使多路复用，这个模型可以带来最大的灵活度</p><p>进程之间的通信<br>比如说一个购票系统：</p><p>进程A和进程B，此时：进程A去买票（一共十张）：首先读出票数，把票数减一，然后把减一后的数据放回去</p><p>假设在第二个步骤的时候发生CPU 的切换，进程B去读票数，那么去读的时候此时票数还是10，然后进行减一后，放回去，再切回线程A，放回去，这里就有个问题：同一张票给了两个进程去卖了！这明显是不科学的。</p><p>为了有效避免进程的竞争问题这里需要做的就是互斥，那么什么是互斥呢？就是A在访问的时候，禁止B访问，这样子就能够进行一个有效的防止竞争了。</p><p>这里面设计很多种方法：</p><p>屏蔽中断：每个进程在刚刚进入临界区后立刻屏蔽所有中断，并在就有离开之前再打开终端，屏蔽中断后，时钟中断也会被屏蔽，CPU只有发生时钟中断或者其他中断才会进行切换，这样子，在屏蔽中断之后，CPU将不会进行切换</p><p>锁变量：共享一个变量（锁），初始值为0，当一个进程进入临界区的时候，就测试这把锁，如果该锁为0则进程把锁设置为1，然后进入，如果进入的时候锁的值为1，则等待，当出去临界区的时候再把锁的值改为0</p><p>严格轮换法：</p><p>严格轮换法同样也是针对一个临界区设置一个变量,假设为Turn。以两个进程为例子:</p><p>当Turn为0时,Process 0才能能进入临界区,否则等待。等Process 0离开临界区后,将Turn设置为1.</p><p>当Turn为1时,Process 1才能进入临界区,否则等待。等Process 1离开临界区后,将Turn设置为0.</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
