<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Centos搭建git私服]]></title>
    <url>%2F2019%2F03%2F26%2FCentos%E6%90%AD%E5%BB%BAgit%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[Centos搭建GIT私服安装gitCentos默认自带Git 可以通过以下命令进行查看 1git --version 默认是1.8 创建用户123groupadd gitadduser git -g gitpassword git 先创建一个用户组 再在这个用户组里面创建一个用户 再给用户设置密码 创建authorized_keys文件1234567cd /home/gitmkdir .sshchmod 700 .sshtouch .ssh/authorized_keyschmod 600 .ssh/authorized_keyscd /homechown -R git:git git 要注意的是文件权限和所属用户。 (后续的git clone如果需要密码，很有可能是git用户没有访问authorized_keys文件的权限) 客户端创建密钥并上传1ssh-keygen -t rsa -C &quot;your_email&quot; 该命令会产生两个文件: id_rsa对应私钥，id_rsa.pub对应公钥。 将id_rsa.pub中的内容写到服务器的authorized_keys文件中。 如果有多个客户端，那么在authorized_keys文件中，一行保存一个客户端的公钥。 创建git仓库为了方便管理，所有的git仓库都置于同一目录下，假设为/home/gitrepo， 123cd /homemkdir gitrepochown git:git gitrepo 接下来创建git仓库：test.git 12cd gitrepogit init --bare test.git 把仓库所属用户改为git 1chown -R git:git test.git 注意每次新建的仓库，都要修改仓库的所属用户 git私服搭建完毕push 和 clone示例 打开git bash 1234git clone git@ip:/home/gitrepo/test.gitgit remote add origin git@ip:/home/gitrepo/test.gitgit push -u origin]]></content>
      <categories>
        <category>版本控制器</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-进阶]]></title>
    <url>%2F2019%2F01%2F31%2FGit-%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Git进阶本地分支管理一个项目如果是你一个人开发，那就没什么，反正就一份项目，你想做哪个模块就做哪个模块但是这样子开发效率慢啊 要是两个人开发，开发效率提高一倍，那么怎么合并起来呢？？？ 如果说两个人做的地方，刚好互不影响，那很简单，学过数学的人都知道，直接合并起来嘛 问题来了！！！ 如果两个人做的地方有重复怎么办？？？一行一行对比，然后一行行改?还是说一个人做完再让另外一个人做？那这和一个人做有什么区别 这就太麻烦了 所以引入了分支管理！这是个好东西 创建分支根据上图我们可以知道，我们首先是有一个主干的(称为master分支) 我们每次提交，会多一个新的节点 提交越多，master分支也会边长 创建分支的代码：(新的分支名字为dev) 1git branch dev 我们可以看到一个*标记在master，这代表着我们操控着master分支假设我们要切换分支： 1git checkout dev (我们也有一个更加方便的代码，创建分支同时切换到该分支上)： 1git checkout -b dev 接下来，我们执行一次提交 然后我又返回到master里再提交一次 合并分支首先切换到master分支将dev分支合并到master分支下 1git merge dev 删除分支1git branch -d dev GitHub上实现分支管理上面说这么多，其实为了熟悉一下命令，还有通过一些图来表明，每个操作，到底发生了什么 接下来才是实际开发中会用到的，结合GitHub上讲解 首先我拉取一下我Github，我仓库里只有一个A.txt,里面有句Hello 我新建两个文件夹用来模拟两台电脑 接着做如下操作 然后把文件都添加到本地仓库中 接着在Git2里推送到github上的分支下12git checkout -b devgit push -u origin dev 这样子在Github上就有分支了 接着Git去上传自己的到github的master下1git push -u origin master 在创建一个文件夹Git3 分别把两个分支拉下来 1234567git clone 路径进入仓库git checkout dev git clone -b dev(分支名) 路径git checkout mastergit merge devgit push -u origin master]]></content>
      <categories>
        <category>版本控制器</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门]]></title>
    <url>%2F2019%2F01%2F12%2FGit%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[版本控制器：首先了解Git之前要明白另外一样东西，那就是版本控制系统 什么叫版本控制系统呢？ 版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。 程序员写代码，学会一种版本控制器是必不可少的技能 写代码，少不了的就是不断的修改源代码，但是代码是一种很神奇的东西，你会发现，原本只有一个BUG的改着改着突然发现BUG数量不仅仅没有减少而且还增加，此时的心里感受，哈哈，应该要吐血，那么怎么办？我原来的代码也被我改掉了说白了就是已经没有的备份，那就凉了~ 好的，小白曾经是这么干的，比如说，出现BUG吗，那我要修改，修改之前，先拷贝一份现在的源文件，然后再去改，这样子就稳了 当然小白一开始做得还是很开心的，因为很简单啊，写的代码也不多，而且往往只是一个文件，随着小白的进步当中，代码往往牵涉到多个文件的修改，这样子也是可以ctrl+c和ctrl+v的，但是一是一个文件夹里密密麻麻的项目，二是，看着一堆副本一副本二，简直就是头疼啊！！！ 好啦，现在开始讲我们的版本控制器了 简单来说呢，版本控制器就是可以更加方便地对我们的代码进行管理 进入正题： Git:Git：分布式版本控制系统 那么有分布式那么就会有集中式，没错！ SVN就是集中式版本控制系统，本章不做介绍 Git很火的呢，怎么说，GitHub就是基于Git的基础上的 至于分布式版本系统控制系统和集中式版本控制系统，等我把Git和SVN讲解完再进行一个比较 Git的安装Git的安装可以参考官网https://git-scm.com/downloads直接下载后安装后就可以了，很简单 安装后在开始菜单中找到Git Bash鼠标右键也会有 Git的入门我首先创建了一个文件夹，专门进行讲解文件夹名字为Git，首先创建一个文件，名字为a.txt，内容为AAA 接下来进行提交 在文件夹里面右键 git Bash 初始化首先我们要初始化一个仓库，这个仓库是放在我们本机的 1git init 默认为隐藏的，要设置查看隐藏文件就可以看得到多了一个文件夹 添加将文件添加到仓库里 1git add a.txt 提交将文件提交到仓库里 1git commit -m &quot;version 1.0&quot; -m后面是本次提交的一个说明，就是提交的是什么东西(原则上可以省略，但是建议不要) git add 和 git commit的区别首先git add添加自己指定的文件git commit不可以，一次性将所有提交，不可指定文件 git add是先将文件添加到暂存区，git commit将暂存区里的文件一次性提交到仓库里！！！ 基本上简单的一个Git流程的上传部分就介绍完了 下载文件既然前面我们讲完了如何将文件上传到自己的仓库，那么我们现在要用到的情况下，怎么从仓库下载下来呢？？？ 现在为了模仿以下真实环境 我进行多了两次提交 第一次提交之前，在a.txt增加了一行BBB 第二次提交之前，在a.txt增加了一行CCC 接下来我们就要去查看记录了 1git log 当前TXT是这样子的 现在要恢复啦！！！见证奇迹的时刻——- 1git reset --hard HEAD^ 再打开文本，发现已经恢复了，用git log去查看的时候发现也确实少了一条记录HEAD代表的是当前版本HEAD^代表的是当前版本的上一个版本HEAD^^代表的是上上版本 HEAD~N 代表的是当前邦本的上N个版本 远程仓库GitHub是提供Git仓库托管服务的,所以首先要有一个GitHub账号 自行注册GitHub的账号，这个问题，不在这里描述了 其次注册完账号还有做一些事情 先创建一个SSH KEY 1ssh-keygen -t rsa -C &quot;邮箱&quot; 在C盘本地账号下有一个文件夹.ssh 里面有两个文件，分别是id_rsa.pub 和 id_rsa分别对应着公钥和私钥 登陆GitHub，打开Settings里有一个选项，SSH and GPG keys添加自己机子的公钥 因为Git支持SSH协议，所以添加了SSH KEY之后可以防止别人冒充来对我们的仓库进行恶意修改 添加文件到GitHub首先在GitHub里面创建一个Repository 比如说我创建了一个gitTest 然后回到git Bash添加远程仓库1git remote add origin git@github.com:用户名/仓库名字.git 那么对应删除远程仓库的命令：1git remote rm origin 现在我们添加成功之后，接下来就是要上传到远程仓库里面去了 1git push -u origin master 接着去刷新我们的仓库，发现文件已经提交上去了 GitHub上下载文件这个也很简单对应着一条命令就可以了 1git clone git@github.com:用户名/仓库名字.git 好了，本章对Git的介绍就讲到这里，这里只是入门，后面会有一些更加多的内容介绍，敬请关注~]]></content>
      <categories>
        <category>版本控制器</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取网易云音乐]]></title>
    <url>%2F2019%2F01%2F12%2FPython%E7%88%AC%E5%8F%96%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[Python爬取网易云音乐首先放网址： https://music.163.com/ 通过Network我们可以找到我们的音乐url存放的位置 那么我们就简单啦，知道Ajax的请求页面，我们当然就可以直接爬取了，但是： 这个FormData好像不简单，那我怎么请求呢？ 第一直觉，就感觉是被加密了，不愧是网易云，有一套呢 那么肯定就是和JS脱离不了关系了，找到JS，然后保存到本地进行分析一下 把代码保存到本地，进行一些操作 加密用到了四个参数，那么我们可以打印一下这四个参数 那么问题来了，这JS文件在我的本地，我怎么让网站进行加载呢？ 对的，这里要运用到一个工具，Fiddler4 这是个什么东西呢 它能够记录并检查所有你的电脑和互联网之间的Http通讯，设置断点，查看所有的进出Fiddler的数据（cookie,html,css,js） 大概就是，在客户端和服务器之间创建一个代理服务器来对之间进行交互通讯信息进行监控 下载安装完成之后还要对Fiddler4进行配置： Tools—》Options 更详细的介绍，这里就不多说了 那么大概界面是这样的 接着我们打开网易云官网 把core.js拖拉都右边，钩上相应的选项，在最下面找到要替换的JS，最后点击一下save 就能发现上面的路径变了，上图是我已经替换好的了 接下来：在网易云上搜索一首歌，打开控制台 你会发现，居然这样子了： 打印成功了！ 再看XHR里面 我们的重点是url这个，所以我们只用关注第一个打印的，显然ids就是歌曲的序号 多试几组可以看出来一个问题就是： 后三个参数是不用管的 那么歌曲的序号又要怎么获取呢？最终找到的结果是在 然而这个页面也是加密的，很强，没事 我们再看看后台打印的东西 span class = “s-fc7”又是什么东西呢？ 经过测试，发现这是固定的值 整个Json不同的地方在于s，传入歌名就可以了 呼 offset是偏移量，与翻页数有关系 好了，接下来又得去看我们的JS代码，去分析加密过程了 1234567891011121314151617181920212223242526272829303132333435363738function a(a) &#123; var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;; for (d = 0; a &gt; d; d += 1) e = Math.random() * b.length, e = Math.floor(e), c += b.charAt(e); return c &#125; function b(a, b) &#123; var c = CryptoJS.enc.Utf8.parse(b) , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;) , e = CryptoJS.enc.Utf8.parse(a) , f = CryptoJS.AES.encrypt(e, c, &#123; iv: d, mode: CryptoJS.mode.CBC &#125;); return f.toString() &#125; function c(a, b, c) &#123; var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,&quot;&quot;,c), e = encryptedString(d, a) &#125; function d(d, e, f, g) &#123; var h = &#123;&#125; , i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h &#125; function e(a, b, d, e) &#123; var f = &#123;&#125;; return f.encText = c(a + e, b, d), f &#125; window.asrsea = d 首先看函数d 函数d首先有个i，这个i是一个随机的十六位字符串， 然后进行了两次加密，第一次是第一个参数和第四个参数进行加密，把结果返回出来后与i字符串进行第二次加密，这个encText就是我们的params 而通过我们的刚才打印结果来看，后三个参数是固定的，然而i是随机的，也就是我们可以固定一个参数（一个最不可能的坑你，就是每次随机刚好就是随机到我的字符串），也就是说h.encSecKey=c(i,e,f)也是固定的，那也没什么好看的了 最主要的还是我们的params参数的第一次加密，因为第二次加密是在第一次加密的结果和一个固定的字符串，所以也没有讨论的必要了 首先看看我们的加密算法： 12345678910#AES加密算法def AES_encrypt(text, key, iv): pad = 16 - len(text) % 16 if type(text)==type(b&apos;&apos;): text = str(text, encoding=&apos;utf-8&apos;) text = text + pad * chr(pad) encryptor = AES.new(key, AES.MODE_CBC, iv) encrypt_text = encryptor.encrypt(text) encrypt_text = base64.b64encode(encrypt_text) return encrypt_text 这里，要安装一下Crypto模块，不然会报错，模块找不到 接下来就是源代码了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from Crypto.Cipher import AESimport requestsimport base64import osimport codecsimport jsonfrom pypinyin import lazy_pinyinfrom urllib.request import urlretrieve# 后三个参数和i的值（随机的十六位字符串）b = &apos;010001&apos;c = &apos;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&apos;d = &apos;0CoJUm6Qyw8W8jud&apos;#随机的十六位字符串def createSecretKey(size): return (&apos;&apos;.join(map(lambda xx: (hex(ord(xx))[2:]), str(os.urandom(size)))))[0:16]#AES加密算法def AES_encrypt(text, key, iv): pad = 16 - len(text) % 16 if type(text)==type(b&apos;&apos;): text = str(text, encoding=&apos;utf-8&apos;) text = text + str(pad * chr(pad)) encryptor = AES.new(key, AES.MODE_CBC, iv) encrypt_text = encryptor.encrypt(text) encrypt_text = base64.b64encode(encrypt_text) return encrypt_text#得到第一个加密参数def Getparams(a,SecretKey): #0102030405060708是偏移量，固定值 iv = &apos;0102030405060708&apos; h_encText = AES_encrypt(a,d,iv) h_encText = AES_encrypt(h_encText,SecretKey,iv) return h_encText#得到第二个加密参数def GetSecKey(text, pubKey, modulus): text = text[::-1] rs = int(codecs.encode(text.encode(&apos;utf-8&apos;), &apos;hex_codec&apos;), 16) ** int(pubKey, 16) % int(modulus, 16) return format(rs, &apos;x&apos;).zfill(256)#得到表单的两个参数def GetFormData(a): SecretKey = createSecretKey(16) params = Getparams(a,SecretKey) enSecKey = GetSecKey(SecretKey,b,c) data = &#123; &quot;params&quot;:str(params,encoding=&apos;utf-8&apos;), &quot;encSecKey&quot;:enSecKey &#125; return datadef getOnePatam(): # 查询id的url url = &apos;https://music.163.com/weapi/cloudsearch/get/web?csrf_token=&apos; #伪装头部 head = &#123; &apos;Host&apos;: &apos;music.163.com&apos;, &apos;Origin&apos;:&apos;https://music.163.com&apos;, &apos;Referer&apos;:&apos;https://music.163.com/search/&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;, &#125; print(&quot;输入你想要下载的歌手&quot;) song_name = input() #第一个参数 song_name = &apos;&apos;.join(lazy_pinyin(song_name)) key = &apos;&#123;hlpretag:&quot;&quot;,hlposttag:&quot;&lt;/span&gt;&quot;,s:&quot;&apos;+song_name+&apos;&quot;,type:&quot;1&quot;,csrf_token:&quot;&quot;,limit:&quot;30&quot;,total:&quot;true&quot;,offset:&quot;0&quot;&#125;&apos; FormData = GetFormData(key) html = requests.post(url,headers=head,data=FormData) result = json.loads(html.text) return result[&apos;result&apos;][&apos;songs&apos;]#下载器：def download(name,id): # 获取歌曲的url的路径 song_url = &quot;https://music.163.com/weapi/song/enhance/player/url?csrf_token=&quot; # 伪装头部 headers = &#123; &apos;Host&apos;: &apos;music.163.com&apos;, &apos;Origin&apos;: &apos;https://music.163.com&apos;, &apos;Referer&apos;: &apos;https://music.163.com/&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos; &#125; # 把上个页面查询到的id放到第二个页面的第一个参数上 a =str(&#123;&apos;ids&apos;: &quot;[&quot;+str(id)+&quot;]&quot;, &apos;br&apos;: 320000, &apos;csrf_token&apos;: &quot;&quot;&#125;) FormData = GetFormData(a) response = requests.post(song_url,data = FormData,headers=headers) json_dict = json.loads(response.content) song_url=json_dict[&apos;data&apos;][0][&apos;url&apos;] print(song_url) folder = os.path.exists(&apos;songs&apos;) if not folder: os.makedirs(&apos;songs&apos;) path = os.path.join(&apos;songs&apos;,name+&quot;.mp3&quot;) urlretrieve(song_url,filename=path)if __name__ == &apos;__main__&apos;: song_list = getOnePatam() for i in song_list: name = i[&apos;name&apos;] id = i[&apos;id&apos;] download(name,id) 以下是效果图 这次程序重点的是对加密的网页，学会如何去处理 有一点要强调一下，因为如果是中文，会导致加密的时候字符串长度不匹配的问题，所以只能用拼音，所以这里加了一个中文转拼音的库，pypinyin的lazy_pinyin()的方法]]></content>
      <categories>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr集群版的搭建]]></title>
    <url>%2F2019%2F01%2F10%2FSolr%E9%9B%86%E7%BE%A4%E7%89%88%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Solr集群版的搭建搭建Solr集群 首选需要配置zookeeper集群 先搭建四个tomcat 1234cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat01cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat02cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat03cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat04 1234vim tomcat01/conf/server.xmlvim tomcat02/conf/server.xmlvim tomcat03/conf/server.xmlvim tomcat04/conf/server.xml 给不同的Tomcat修改端口，tomcat01为81，tomcat02为82,以此类推，主要修改以下三个地方 把单机版的Solr放到Tomcat下 1234cp -r solr /home/app/solr-cloud/tomcat01/webapps/cp -r solr /home/app/solr-cloud/tomcat02/webapps/cp -r solr /home/app/solr-cloud/tomcat03/webapps/cp -r solr /home/app/solr-cloud/tomcat04/webapps/ 再复制四个solrhome到solr-cloud目录下 再修改每个solrhome下的solr.xml 注意写自己的端口号和IP地址 修改每个tomcat的solr的web.xml 修改catalina文件 1234vim tomcat01/bin/catalina.shvim tomcat02/bin/catalina.shvim tomcat03/bin/catalina.shvim tomcat04/bin/catalina.sh tomcat运行catalinda.sh脚本命令 配置JAVA_OPTS 1JAVA_OPTS=&quot;-DzkHost=192.168.25.130:2181,192.168.25.130:2182,192.168.25.130:2183&quot; 在solr文件下的example目录下的script目下的cloud-scripts目录下有个zkcli.sh 上传配置文件至zookeeper的命令 1./zkcli.sh -zkhost 192.168.25.130:2181,192.168.25.130:2182,192.168.25.130:2183 -cmd upconfig -confdir /home/quan/app/solr-cloud/solrhome01/collection1/conf/ -confname myconf 进入solr-cloud的zookeeper01中的bin目录下进行连接zookeeper 1./zkCli.sh -server 192.168.25.130:2182 检查一下 1./zkCli.sh -server 192.168.25.130:2182 myconf就是我们上传的 内容里面有我们上传的solr文件 整个搭建就完成了 开启四个Tomcat 1234/home/quan/app/solr-cloud/tomcat01/bin/startup.sh/home/quan/app/solr-cloud/tomcat02/bin/startup.sh/home/quan/app/solr-cloud/tomcat03/bin/startup.sh/home/quan/app/solr-cloud/tomcat04/bin/startup.sh SolrCloud创建Collection的命令 1http://192.168.25.130:8180/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;relicationFactor=2 SolrCloud删除Collection的命令 1http://192.168.25.130:8180/solr/admin/collections?action=DELETE&amp;name=collection1]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例]]></title>
    <url>%2F2019%2F01%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 说白了就是：就是使用设计模式，代码会更好。 单例模式：就是单个实例 那么单例模式有什么好处呢？ 很简单，首先，都是单个实例了，那么就可以怎样 一、实例控制 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。 二、灵活性 因为类控制了实例化过程，所以类可以灵活更改实例化过程。 但是还是有缺点的： 一、开销 虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。 二、可能的开发混淆 使用单例对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用new关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。 三、对象生存期 不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于.NET Framework的语言），只有单例类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如 C++），其他类可以删除对象实例，但这样会导致单例类中出现悬浮引用。。 单例模式根据实例化对象时机的不同分为两种 饿汉式 上代码 12345678910public class Single&#123; /*私有化，防止外部创建实例*/ private Single&#123;&#125; /*设置静态属性私有，防止外部通过类名访问*/ private static Single single = new Single(); /*设置静态方法*/ public static Single getInstance()&#123; return single; &#125;&#125; 这个很简单的 上面有个问题，当类加载的时候，就会实例化Single（），假如我加载完类，一段时间没用，而实例却已经早就创建了，着就会造成一个浪费。 通过这个问题，我们可以想，当我们需要实例的时候我们才去实例化，而不是通过类加载，那么我们可以这样子做 懒汉式 12345678910111213public class Single&#123; /*私有化，防止外部创建实例*/ private Single&#123;&#125; /*设置静态属性私有,先设空，需要的时候再实例化*/ private static Single single=null; /*设置静态方法*/ public static Single getInstance()&#123; if(single==null)&#123; single = new Single() &#125; return single &#125;&#125; 这样子，就没什么问题了 但是现在再思考一个问题，万一是多线程的时候呢？这样就有问题的了 这样子我们就需要加一个锁 12345678910111213141516171819public class Single&#123; /*私有化，防止外部创建实例*/ private Single&#123;&#125; /*设置静态属性私有,先设空，需要的时候再实例化*/ private static Single single=null; /*设置静态方法*/ public static Single getInstance()&#123; /*两重判空是为了提高效率*/ if(single==null)&#123; /*上锁*/ synchronized(Single.Class)&#123; if (single==null) &#123; single = new Single() &#125; &#125; &#125; return single; &#125;&#125; 这样子整个单例模式就做得比较好了]]></content>
      <categories>
        <category>设计模式</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程]]></title>
    <url>%2F2018%2F12%2F28%2FJava%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是线程？ 线程是一个程序里的不同执行路径 一般的程序是从一个入口出发，沿着唯一的路径走到终点，而线程则使唯一的路径变成多条路径 以下是单线程操作 123456789101112131415161718192021class A extends Thread&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.run(); while(true) &#123; System.out.println(&quot;hello JAVA&quot;); &#125; &#125;&#125; 因为aa.run没有执行完毕，下面的while循环就不会执行，所以就是一直输出“hello world“再看看多线程操作 123456789101112131415161718192021class A extends Thread&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); while(true) &#123; System.out.println(&quot;hello JAVA&quot;); &#125; &#125;&#125; Thread中的start方法就是创建一个线程，并且自动调用run方法，直接调用run方法是不会创建一个线程的。执行一个线程，其实就是执行一个线程里面的run方法，一个Thread对象不能调用两次start方法，否则会抛出异常。把aa.run改成aa.start结果就是两个循环交替执行，这就是多线程。单线程就是一条路径，从头到尾执行。多线程就是有多条路径，每次都可以走不同的路径。 执行aa.start并不代表aa对象的线程就立刻执行，而是得到了能够被CPU执行的资格，也就是就绪的状态。创建线程的第二种方式： 12345678910111213141516171819202122class A implements Runnable&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125;public class Thread2 &#123; public static void main(String[]args) &#123; A aa=new A(); Thread th=new Thread(aa); th.start(); while(true) &#123; System.out.println(&quot;hello JAVA&quot;); &#125; &#125;&#125; Thread常用方法： setName（String）设置名字 currentThread（）返回正在执行线程的对象 getName（）返回线程的名字 12345678910111213141516171819class A extends Thread&#123; public void run() &#123; System.out.println(&quot;hello world&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); System.out.println(&quot;hello JAVA&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125; 123456789101112131415161718class A extends Thread&#123; public void run() &#123; System.out.println(&quot;hello world&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.setName(&quot;123&quot;); aa.start(); System.out.println(&quot;hello JAVA&quot;); System.out.println(Thread.currentThread().getName()); &#125;&#125; Thread的sleep方法sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。要捕获异常！ 123456789101112131415161718192021222324class A extends Thread&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+i); try&#123; Thread.sleep(1000); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); &#125;&#125; Thread的join方法：如a.join（）；暂停当前正在执行的线程，直到a的线程运行终止之后当前线程才有机会得到执行，注意：不是暂停a对象的线程，而是当前运行的线程12345678910111213141516171819202122232425262728class A extends Thread&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125;public class Thread1 &#123; public static void main(String[]args) &#123; A aa=new A(); aa.start(); try&#123; aa.join(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125; **Thread的优先级： getPriority:获取优先级 setPriority:设置优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。 线程调度器用数字表现，范围从一到十，一个线程默认是5。 通常优先级高的比优先级低的要先执行，但并不是一定的！因为实际开发中并不单纯依赖优先级来决定优先级的运行顺序** 1234567891011121314151617181920212223242526272829class A implements Runnable&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(&quot;A&quot;+i); &#125; &#125;&#125;class B implements Runnable&#123; public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(&quot;B&quot;+i); &#125; &#125;&#125;public class Thread3 &#123; public static void main(String[]args) &#123; Thread t1=new Thread(new A()); Thread t2=new Thread(new B()); t1.setPriority(Thread.MIN_PRIORITY); t2.setPriority(Thread.MAX_PRIORITY); t1.start(); t2.start(); &#125;&#125; 优先级越高！越容易被CPU先调用！ 线程的同步卖票系统！ 假如有三个地方，A,B,C同时卖票 假如代码写成这样 12345if(票数大于0)&#123; 买票 票数-1&#125; 当A发现票大于0的时候，本应该执行下一步，假如此时CPU切换的B线程的时候，发现票数大于0（因为在A线程里面，票数没有减一），当在B中发现票数大于0之后，假如CPU又切换到C线程里面，发现票数还是大于0（同理）假如票只有一张，那么此时就相当于一张票被卖了三次。这将产生错误！ 123456789101112131415161718192021222324252627282930class A implements Runnable&#123; private int tickets=100; public void run() &#123; while(true) &#123; if(tickets&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;); tickets--; &#125; else &#123; break; &#125; &#125; &#125;&#125;public class Thread4 &#123; public static void main(String[]args) &#123; A a=new A(); Thread t1=new Thread(a); t1.start(); A b=new A(); Thread t2=new Thread(b); t2.start(); &#125;&#125; 以上代码运行结果： 每张票都被卖出去两次！！！这是不合理的 导致这个的原因是a对象和b对象都有一个属于自己的tickets 100 那么接下来看以下程序 123456789101112131415161718192021222324252627282930class A implements Runnable&#123; static int tickets=100; public void run() &#123; while(true) &#123; if(tickets&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;); tickets--; &#125; else &#123; break; &#125; &#125; &#125;&#125;public class Thread4 &#123; public static void main(String[]args) &#123; A a=new A(); Thread t1=new Thread(a); t1.start(); A b=new A(); Thread t2=new Thread(b); t2.start(); &#125;&#125; 把票数改成静态的结果是这样的： 那么来分析一下这个结果是为什么，当Thread-0发现票数是100的时候执行卖出操作，然后立刻切换的线程1然后发现还是100但是没有执行卖出操作又转换为线程0，此时减一然后就变成99、98、97、96、95、这个时候立刻切换成线程1执行卖出操作，打印出来。 简单来说：CPU会在线程之间来回切换！好的，重点来了！Synchronized—同步1234567891011121314151617181920212223242526272829303132class A implements Runnable&#123; static int tickets=100; public void run() &#123; while(true) &#123; synchronized(this) &#123; if(tickets&gt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;); tickets--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class Thread4 &#123; public static void main(String[]args) &#123; A a=new A(); Thread t1=new Thread(a); Thread t2=new Thread(a); t1.start(); t2.start(); &#125;&#125; 结果如下： synchronized 关键字，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。它包括两种用法：synchronized 方法和 synchronized 块。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP手动搭建环境]]></title>
    <url>%2F2018%2F12%2F28%2FPHP%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[php环境手动搭建php下载路径https://windows.php.net/download（注意一点的是要下线程安全的Thread Safe） Apache下载路径http://httpd.apache.org/docs/current/platform/windows.html Mysql下载路径https://dev.mysql.com/downloads/mysql/ Apache的安装 这里注意，请先把你的Apache的目录放置好再进行安装，否则安装后再移动位置，会出问题进入Apache目录下的conf目录修改httpd.conf大概在38行附近修改成如下：路径使用自己Apache的安装位置12Define SRVROOT &quot;E:\Apache24&quot; ServerRoot &quot;$&#123;SRVROOT&#125;&quot; 用管理员模式开启CMD进入Apache的bin目录下 命令行httpd -k install进行安装可以使用httpd -t进行测试，是否安装成功 注意事项如果失败，导致原因有可能是： 端口被占用 解决办法： netstat -aon | findstr :80 查看端口是否正在被监听，如果被监听了，有两种方法1. 修改Apache的端口，打开Apache的conf目录下修改httpd.conf,查找Listen关键字 找到 Listen 80 修改到你想设置的端口即可 2. 停止正在监听的服务，打开资源管理器，找到对应的PID，停止运行 这里默认上面三个已经下载好而且已经安装好了 正题：Apache和PHP整合在Apache的conf目录下的httpd.conf文件中加入下面三行代码 12345678#加载PHP模块LoadModule php7_module &quot;E:/php7/php7apache2_4.dll&quot;#当执行后缀为php的文件，就去找这个模块执行AddType Application/x-httpd-php .php#载入php配置文件PHPIniDir &quot;E:/php7&quot; 路径选择你们的位置 在php目录下拷贝php.ini-development改名为php.ini在文件里面进行如下修改(目录为个人的目录)1extension_dir = &quot;E:/php7/ext&quot; 在apache里面有个htdocs目录在里面写入一个php文件比如:test.php123&lt;?php phpinfo(); ?&gt; 在浏览器输入localhost/test.php 如果能够正确显示则配置完成]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr单机版的搭建]]></title>
    <url>%2F2018%2F12%2F27%2FSolr%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Solr Solr是一个开源搜索平台，用于构建搜索应用程序。 它建立在Lucene(全文搜索引擎)之上。 Solr是企业级的，快速的和高度可扩展的。 使用Solr构建的应用程序非常复杂，可提供高性能。 solr的一些突出的特点： Restful APIs − 要与Solr通信，并非一定需要有Java编程技能。相反，您可以使用restful服务与它通信。可使用文件格式(如xml，json和.CSV)在Solr中作为输入文档，并以相同的文件格式获取结果。 全文搜索 - Solr提供了全文搜索所需的所有功能，例如令牌，短语，拼写检查，通配符和自动完成。 企业准备 - 根据企业/组织的需要，Solr可以部署在任何类型的系统(大或小)，如独立，分布式，云等。灵活和可扩展 - 通过扩展Java类并相应配置，可以轻松地定制Solr的组件。 NoSQL数据库 - Solr也可以用作大数据量级的NOSQL数据库，可以沿着集群分布搜索任务。 管理界面 - Solr提供了一个易于使用，用户友好，功能强大的用户界面，使用它可以执行所有可能的任务，如管理日志，添加，删除，更新和搜索文档。 高度可扩展 - 在使用Solr与Hadoop时，我们可以通过添加副本来扩展其容量。 以文本为中心并按相关性排序 - Solr主要用于搜索文本文档，结果根据与用户查询的相关性按顺序传送 Solr单机版的搭建：解压solr和tomcat12tar zxf solr-4.10.3.tgz.tgztar -zxf apache-tomcat-7.0.47.tar.gz 把solr的war包放到tomcat的webapp目录下1cp solr-4.10.3/dist/solr-4.10.3.war /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr.war cp solr-4.10.3/example/lib/ext/* /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/lib/123配置一下solrhome vim /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/web.xml12修改solr的web.xml vim /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/web.xml` 再重新启动一次Tomcat 在浏览器里访问一下 localhost:8080/solr会出现以下界面 整个Solr服务就启动完成了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程和进程]]></title>
    <url>%2F2018%2F12%2F20%2F%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[计算机所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例 单核CPU也就是单个核心的CPU，每次只能执行一个进程，由于CPU在各进程之间快速切换，所以每个进程所执行的时间是不确定的。 举个例子： 假设你在看着食谱做美食，那么你就相当于CPU，食谱就是程序，而做美食的材料就是输入数据，进程就是，你在阅读食谱取食材以及制作美食的这一系列动作，假设你在做美食时候突然来了个电话，你可能会先熄火，然后脑海里知道自己现在做到哪个位置（保存当前状态），然后去接电话，处理完了后，你可能才回来厨房想想刚才做到哪里了，然后继续之前继续做 一个进程就是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被多个进程共享，CPU使用了某种调度算法决定何时停止一个进程的工作，并且转向另一个进程提供服务。 进程的创建：有四种主要的事件1、系统初始化 前台进程 守护进程2、正在运行的程序执行了创建进程的系统调用3、用户请求创建一个新进程4、一个批处理作业的初始化 进程的终止1、正常退出2、出错退出3、严重错误4、被其他进程给杀死 只可以有一个父进程，但可以有零个或者多个子进程 进程有三种状态：运行态，就绪态，阻塞态 ​ 为了实现进程模型，操作系统维护着一张表格（一个结构数组）即进程表，每个进程占用一个进程表的一个项，这张表包含了许多信息，比如程序计数器，堆栈指针，内存分配状况，等等从而保证了该进程被断掉后重新启动的时候，能够保存之前的信息。 线程为什么需要线程？ 首先，有了线程，我们可以不必考虑终端、定时器、和上下文的切换只需考虑并行进程。其次，线程比进程更加轻量级，速度会比用进程效率要提高很多。 每个单核处理器在某个时刻也是只能够执行一个线程的，这和进程是一样的，线程是CPU处理的基本单位，我们前面讨论的进程，是进程单线程模型。 同样的，线程也是有阻塞态、运行态、就绪态。 为了实现可移植的线程程序，IEEE在IEEE标准中定义了线程的标准，它定义的线程包叫做pthread 实现线程包有两种方法，第一种把整个线程包放在用户空间 从内核的角度上管理的就是单线程进程的模型，这样子尽管系统不支持线程，也可以进行实现 用C语言实现1234567891011121314151617181920212223#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define NUMBER 10void *hello(void *id)&#123; printf(&quot;Thread-----%d\n&quot;,id); pthread_exit(NULL);&#125;int main()&#123; pthread_t threads[NUMBER]; int status; int i; for(i=0;i&lt;NUMBER;i++)&#123; printf(&quot;Main---Creating thread%d\n&quot;,i); status = pthread_create(&amp;threads[i],NULL,hello,(void*)i); if(status!=0)&#123; printf(&quot;ErrorCode----&gt;%d\n&quot;,status); exit(-1); &#125; &#125; return 0;&#125; 在用户空间管理线程的时候会创建一个运行时的系统，由这个系统进行管理，每个进程都需要其专用的线程表，用来跟踪该进程中的线程。这些表和进程表相似，不过它仅仅记录的是各个线程的属性，如每个线程的程序计数器，堆栈指针，寄存器和状态。因为切换线程的时候不需要陷入到内核空间，不需要有上下文的切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。 用户线程还有一个优点，允许每个进程有自己定制的调度算法，这样子就有一个很好的可扩展性 如果某个线程阻塞了，就会导致整个进程的阻塞 在内核中实现线程 此时不再需要运行时的系统了，另外，每个进程中也没有线程表，内核中有用来记录系统中所有线程的线程表了，当某个线程希望创建一个新的线程的时候，就会进行一个系统的调用，这个系统调用通过对线程表的更新完成线程创建的工作。 内核的线程表里保存了每个线程的信息，这些信息和在用户空间中的线程是一样的，但是现在保存在内核中 由于在内核中创建线程的代价比较大，所以某些系统会采取一种方式：回收线程，当某个线程被撤销的时候，就标记为不可运行的，但是其内核数据的结构没有收到影响。再次创建一个新的线程的时候，就把这个线程给重新启动就可以了，这样子可以减少多次系统调用来开辟新的线程 混合实现 使用内核级的线程，然后将用户级的线程与某些或者全部内核线程多路复用，采取这种方式：开发人员就可以决定有多少个内核级的线程和多少个用户级线程即使多路复用，这个模型可以带来最大的灵活度 进程之间的通信比如说一个购票系统： 进程A和进程B，此时：进程A去买票（一共十张）：首先读出票数，把票数减一，然后把减一后的数据放回去 假设在第二个步骤的时候发生CPU 的切换，进程B去读票数，那么去读的时候此时票数还是10，然后进行减一后，放回去，再切回线程A，放回去，这里就有个问题：同一张票给了两个进程去卖了！这明显是不科学的。 为了有效避免进程的竞争问题这里需要做的就是互斥，那么什么是互斥呢？就是A在访问的时候，禁止B访问，这样子就能够进行一个有效的防止竞争了。 这里面设计很多种方法： 屏蔽中断：每个进程在刚刚进入临界区后立刻屏蔽所有中断，并在就有离开之前再打开终端，屏蔽中断后，时钟中断也会被屏蔽，CPU只有发生时钟中断或者其他中断才会进行切换，这样子，在屏蔽中断之后，CPU将不会进行切换 锁变量：共享一个变量（锁），初始值为0，当一个进程进入临界区的时候，就测试这把锁，如果该锁为0则进程把锁设置为1，然后进入，如果进入的时候锁的值为1，则等待，当出去临界区的时候再把锁的值改为0 严格轮换法： 严格轮换法同样也是针对一个临界区设置一个变量,假设为Turn。以两个进程为例子: 当Turn为0时,Process 0才能能进入临界区,否则等待。等Process 0离开临界区后,将Turn设置为1. 当Turn为1时,Process 1才能进入临界区,否则等待。等Process 1离开临界区后,将Turn设置为0.]]></content>
  </entry>
</search>
