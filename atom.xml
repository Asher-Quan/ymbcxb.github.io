<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小Q博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-19T01:13:50.938Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ymbcxb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM---内存溢出</title>
    <link href="http://yoursite.com/2019/08/06/JVM---%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2019/08/06/JVM---内存溢出/</id>
    <published>2019-08-05T16:28:57.000Z</published>
    <updated>2019-08-19T01:13:50.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java虚拟机结构模型："><a href="#Java虚拟机结构模型：" class="headerlink" title="Java虚拟机结构模型："></a>Java虚拟机结构模型：</h3><img src="/2019/08/06/JVM---内存溢出/01.png"><p>先普及几个指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx等价于-XX:InitialHeapSize 初始化堆内存</span><br><span class="line">-Xms等价于-XX:MaxHeapSize 最大堆内存</span><br></pre></td></tr></table></figure><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</strong></p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p><strong>如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-Xmx1M -Xms1M</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMStackOOM</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[]arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">           <span class="keyword">new</span> JVMStackOOM().start();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"Thread-135" Exception in thread "Thread-130" java.lang.OutOfMemoryError: Java heap space</span></span><br></pre></td></tr></table></figure><p>注明：单线程下无论是栈帧太大还是虚拟机容量太小，都是抛出StackOverflowError</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p><strong>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</strong></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xmx32M -Xms32M</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;HeapOOM&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HeapOOM());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></span><br></pre></td></tr></table></figure><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常</strong></p><p>这里使用的JDK8，JDK8以前是永久代，JDK8是元空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK8:-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</span></span><br><span class="line"><span class="comment"> * JDK7以下:-XX:PermSize=8m -XX:MaxPermSize=8m</span></span><br><span class="line"><span class="comment"> * 非堆内存溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">noHeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj, args1));</span><br><span class="line">            <span class="comment">//无限创建动态代理，生成Class对象</span></span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决内存溢出的办法"><a href="#解决内存溢出的办法" class="headerlink" title="解决内存溢出的办法"></a>解决内存溢出的办法</h4><h5 id="1-导出内存映像文件"><a href="#1-导出内存映像文件" class="headerlink" title="1.导出内存映像文件"></a>1.导出内存映像文件</h5><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用jmap -dump:format=b,file=heap.prof pid   (pid可以用jps查看)(这个方法只能记录当前的堆栈信息)</span><br></pre></td></tr></table></figure><img src="/2019/08/06/JVM---内存溢出/02.png"></li></ol><h5 id="2-使用MAT分析内存溢出"><a href="#2-使用MAT分析内存溢出" class="headerlink" title="2.使用MAT分析内存溢出"></a>2.使用MAT分析内存溢出</h5><p>下载链接： <a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a> </p><p>打开软件左上角File—&gt;Open Heap Dump—&gt;选择对应的hprof文件</p><img src="/2019/08/06/JVM---内存溢出/03.jpg"><p>怀疑的一个问题：主线程占了百分之97.3的内存，内存在“Java.Lang.Objult[]”的一个实例中累积</p><p>如果觉得不够清楚可以接着看别的地方：</p><img src="/2019/08/06/JVM---内存溢出/04.png"><img src="/2019/08/06/JVM---内存溢出/05.jpg"><img src="/2019/08/06/JVM---内存溢出/06.jpg"><p>这里可以看得更加清楚是哪个位置的哪个类的哪个变量引起的内存溢出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java虚拟机结构模型：&quot;&gt;&lt;a href=&quot;#Java虚拟机结构模型：&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机结构模型：&quot;&gt;&lt;/a&gt;Java虚拟机结构模型：&lt;/h3&gt;&lt;img src=&quot;/2019/08/06/JVM---内存溢出/
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM---jstack</title>
    <link href="http://yoursite.com/2019/08/06/JVM---jstack/"/>
    <id>http://yoursite.com/2019/08/06/JVM---jstack/</id>
    <published>2019-08-05T16:27:15.000Z</published>
    <updated>2019-08-19T01:13:04.862Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM之Jstack使用"><a href="#JVM之Jstack使用" class="headerlink" title="JVM之Jstack使用"></a>JVM之Jstack使用</h3><p><em>jstack</em>是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出Java 应用程序中线程堆栈信息</p><p>首先需要了解以下线程的几个状态</p><img src="/2019/08/06/JVM---jstack/01.jpg"><h4 id="解决CPU飙高问题"><a href="#解决CPU飙高问题" class="headerlink" title="解决CPU飙高问题"></a>解决CPU飙高问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; test()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; test()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>top指令能够实时显示系统中各个进程的资源占用状况</p><p>运行前的情况</p><img src="/2019/08/06/JVM---jstack/02.jpg"><p>运行后的情况</p><img src="/2019/08/06/JVM---jstack/03.png"><p>执行jstack命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 4468 &gt; 4468.txt</span><br></pre></td></tr></table></figure><p>查看该Pid下的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 4468 -H</span><br></pre></td></tr></table></figure><img src="/2019/08/06/JVM---jstack/04.png"><p>发现有两个线程的CPU利用率比较高</p><p>下载下来4468.txt查看一下</p><img src="/2019/08/06/JVM---jstack/05.jpg"><p>怎么去定位到我们的线程呢？</p><p>我们刚才可以查看到有两个线程的CPU利用率比较高分别的pid对应为4479和4478</p><p>要转为16进制，分别为：117f 和 117e</p><p>在4468.txt查看这两个数字去进行定位到该线程</p><img src="/2019/08/06/JVM---jstack/06.png"><p>根据Demo.test(Demo.java:12)可以明白问题的原因</p><h4 id="解决死锁问题"><a href="#解决死锁问题" class="headerlink" title="解决死锁问题"></a>解决死锁问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object object2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.test01()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.test02()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法还是一样，我们直接来看生成的txt文件</p><p>查看txt的末尾</p><img src="/2019/08/06/JVM---jstack/07.png"><p>找到一个死锁问题，并且对应的类和方法都写得很清楚，很容易就能排除这个问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JVM之Jstack使用&quot;&gt;&lt;a href=&quot;#JVM之Jstack使用&quot; class=&quot;headerlink&quot; title=&quot;JVM之Jstack使用&quot;&gt;&lt;/a&gt;JVM之Jstack使用&lt;/h3&gt;&lt;p&gt;&lt;em&gt;jstack&lt;/em&gt;是jdk自带的线程堆栈分析工具
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="http://yoursite.com/2019/08/04/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/04/HashMap源码分析/</id>
    <published>2019-08-03T22:58:38.000Z</published>
    <updated>2019-08-03T17:17:22.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><p>最简单的一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(&quot;a&quot;,&quot;a&quot;);</span><br></pre></td></tr></table></figure><p>从构造函数开始分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来执行put函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下hash函数做了什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析下hash算法(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16）</p><p>hashCode的值是32位二进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设h得到的值是：      10010001 10010101 10110000 11110001</span><br><span class="line">右移16位得到的值是:    00000000 00000000 10010001 10010101</span><br><span class="line">异或(同为0,不同为1)：  10010001 10010101 00100001 01100100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设h得到的值是：      10010001 00000000 00000000 00000000</span><br><span class="line">右移16位得到的值是:    00000000 00000000 00000000 10010001</span><br><span class="line">异或(同为0,不同为1)：  10010001 00000000 00000000 10010001</span><br></pre></td></tr></table></figure><p>通过这种方式，可以提高1的分布变得相对均匀一些</p><p>为什么要变得相对均匀呢?我们接着看</p><p>查看putVal的函数</p><p>由于代码比较长，我这里分段来显示且直接在代码里进行解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        //定义了一个Node数组，Node这个类里面包含了四个属性，hash值，Key，Value，指向下一个Node的指针</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        //对table进行一个判空操作，table是一个Node数组</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        //如果为空则走resize()</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">      ......（省略其余代码）</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>resize()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">//将table赋值给oldTab</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       //oldCap为0</span><br><span class="line">       int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">       int oldThr = threshold;</span><br><span class="line">       int newCap, newThr = 0;</span><br><span class="line">       //目前oldCap为0</span><br><span class="line">       ....（省略部分代码）</span><br><span class="line">       else &#123;</span><br><span class="line">       //赋值新的空间和新的阈值</span><br><span class="line">       //static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">       //DEFAULT_LOAD_FACTOR = 0.75f</span><br><span class="line">       //新的空间是16，新的阈值是12</span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       ....（省略部分代码）</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">       //申请16大小的空间</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">        ....（省略部分代码）</span><br><span class="line">       return newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>回到putVal函数</p><p>此时n得到的值为16</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">....（省略部分代码）</span><br><span class="line">//进行取余</span><br><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">....（省略部分代码）</span><br></pre></td></tr></table></figure><p>tab[i = (n - 1) &amp; hash]单独抽出来解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 16 二进制码:    0001 0000</span><br><span class="line">n-1=15：           0000 1111</span><br><span class="line">假设hash值是:       0000 0001</span><br><span class="line">取余运算后的结果是：  0000 0001</span><br></pre></td></tr></table></figure><p>当n是2的幂次方，减一后再去取余一定能保证，前面的都是0</p><p>这里就可以解决了一个问题，节约内存  而且进行与h操作的速度会很快</p><p>上面提到过为什么hash值要尽可能地均匀，如果尽可能地均匀，在这里进行取余运算的时候，hash冲突会降低</p><p>继续看源码回到putVal函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">//如果不为空，就插值</span><br><span class="line">tab[i] = newNode(hash, key, value, null);</span><br><span class="line">else&#123;</span><br><span class="line">//产生了Hash冲突</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">    //判断hash值，key，是否一致</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">     ....（省略部分代码）</span><br><span class="line">     //如果一致，将原先的key对应的值做一个替换</span><br><span class="line">     if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看源码回到putVal函数</p><p>假设hash值，key不是一致，另外一种冲突怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> //判断p是不是树形节点，至于TreeNode是什么呢？就是红黑树</span><br><span class="line"> else if (p instanceof TreeNode)</span><br><span class="line"> //如果是树形节点的，就按照红黑树的方式，插入节点</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">else &#123;</span><br><span class="line">//如果不是树形节点,以链表的方式，插入节点</span><br><span class="line">//这里有一个binCount计数，计算这个链表的长度</span><br><span class="line">    for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">        if ((e = p.next) == null) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, null);</span><br><span class="line">        //如果这个链表的长度大于8-1</span><br><span class="line">        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">        //接下来我们来看下treeifyBin</span><br><span class="line">        treeifyBin(tab, hash);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">   ....（省略部分代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看下treeifyBin()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">        int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        //判断是否为空和容量是不是太小</span><br><span class="line">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        //如果是，则要重新调整容量</span><br><span class="line">            resize();</span><br><span class="line">        //否则</span><br><span class="line">        else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        //将单链表转换成红黑树</span><br><span class="line">            ....（省略部分代码）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再回到我们的putVal函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (e != null) &#123; // existing mapping for key</span><br><span class="line">    V oldValue = e.value;</span><br><span class="line">    if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">    e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line">//修改的数量</span><br><span class="line">++modCount;</span><br><span class="line">//判断size（实际容量）是否大于阈值，初始值为12</span><br><span class="line">if (++size &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br></pre></td></tr></table></figure><p>再次回到resize()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">    //判断是否大于最大值，若已经大于最大值，则将阈值设置为Integer的最大值</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //否则，将阈值扩大一倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    ....（省略部分代码）</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    //生成新得一个容量数组</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    //将oldTab的节点插入到newTab中</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">       ....（省略部分代码）</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于get和remove方法在这里不过多讲解，相对于set的构建过程比较简单</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>HashMap包括了数组，链表，红黑树</li><li>数组容量为2的幂：<ol><li>提高运算速度</li><li>增加散列度，降低冲突</li><li>减少内存碎片</li></ol></li><li>hash函数：hashcode的高16位和低16位进行异或求模，增加散列度，降低冲突</li><li>插入冲突：通过单链表解决冲突，如果链表长度超过8，进行链表和红黑树的转换，以提高查询速度</li><li>扩容的条件：实际节点数大于容量的四分之三，扩容后进行数据排布</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HashMap源码分析&quot;&gt;&lt;a href=&quot;#HashMap源码分析&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码分析&quot;&gt;&lt;/a&gt;HashMap源码分析&lt;/h3&gt;&lt;p&gt;最简单的一个例子&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合支付宝-当面付(二)</title>
    <link href="http://yoursite.com/2019/08/02/SpringBoot%E6%95%B4%E5%90%88%E6%94%AF%E4%BB%98%E5%AE%9D-%E5%BD%93%E9%9D%A2%E4%BB%98(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2019/08/02/SpringBoot整合支付宝-当面付(二)/</id>
    <published>2019-08-02T09:51:10.000Z</published>
    <updated>2019-08-02T06:08:46.373Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/01.png"><p>在上一篇简单将一个支付宝Demo跑起来后，现在需要整合到我们的springBoot项目，虽然说是整合SpringBoot，但是，你SSM也都是可以的</p><p>我先简单写一个SpringBoot的Demo</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/02.png"><p>maven导入了一些与alipay相关的其余依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.10&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;commons-configuration&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;commons-configuration&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.10&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;commons-lang&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;core&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.8.5&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.3&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里注意一下：</p><p><strong>支付宝给的Demo的Gson是2.3.1版本，我这里使用SpringBoot2.x的时候需要修改为2.6版本以上</strong></p><p>主要是在··AlipayController里面</p><p>其实就是把支付宝的Demo里面的test_trade_precreate()函数引入进来而已</p><p>这里为了防止小伙伴出错，我这里贴一下我的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import com.alipay.api.AlipayResponse;</span><br><span class="line">import com.alipay.api.response.AlipayTradePrecreateResponse;</span><br><span class="line">import com.alipay.demo.trade.config.Configs;</span><br><span class="line">import com.alipay.demo.trade.model.ExtendParams;</span><br><span class="line">import com.alipay.demo.trade.model.GoodsDetail;</span><br><span class="line">import com.alipay.demo.trade.model.builder.AlipayTradePrecreateRequestBuilder;</span><br><span class="line">import com.alipay.demo.trade.model.result.AlipayF2FPrecreateResult;</span><br><span class="line">import com.alipay.demo.trade.service.AlipayTradeService;</span><br><span class="line">import com.alipay.demo.trade.service.impl.AlipayTradeServiceImpl;</span><br><span class="line">import com.alipay.demo.trade.utils.ZxingUtils;</span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author ymbcxb</span><br><span class="line"> * @title</span><br><span class="line"> * @Package com.example.demo</span><br><span class="line"> * @date 2019/8/2 10:10</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class AlipayController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static AlipayTradeService tradeService;</span><br><span class="line"></span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(AlipayController.class);</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/pay&quot;)</span><br><span class="line">    public String pay()&#123;</span><br><span class="line">        test_trade_precreate();</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        /** 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数</span><br><span class="line">         *  Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录</span><br><span class="line">         */</span><br><span class="line">        Configs.init(&quot;zfbinfo.properties&quot;);</span><br><span class="line"></span><br><span class="line">        /** 使用Configs提供的默认参数</span><br><span class="line">         *  AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new</span><br><span class="line">         */</span><br><span class="line">        tradeService = new AlipayTradeServiceImpl.ClientBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test_trade_precreate() &#123;</span><br><span class="line">        // (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线，</span><br><span class="line">        // 需保证商户系统端不能重复，建议通过数据库sequence生成，</span><br><span class="line">        String outTradeNo = &quot;tradeprecreate&quot; + System.currentTimeMillis()</span><br><span class="line">                + (long) (Math.random() * 10000000L);</span><br><span class="line"></span><br><span class="line">        // (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费”</span><br><span class="line">        String subject = &quot;xxx品牌xxx门店当面付扫码消费&quot;;</span><br><span class="line"></span><br><span class="line">        // (必填) 订单总金额，单位为元，不能超过1亿元</span><br><span class="line">        // 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】</span><br><span class="line">        String totalAmount = &quot;0.01&quot;;</span><br><span class="line"></span><br><span class="line">        // (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段</span><br><span class="line">        // 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】</span><br><span class="line">        String undiscountableAmount = &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">        // 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号)</span><br><span class="line">        // 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID</span><br><span class="line">        String sellerId = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        // 订单描述，可以对交易或商品进行一个详细地描述，比如填写&quot;购买商品2件共15.00元&quot;</span><br><span class="line">        String body = &quot;购买商品3件共20.00元&quot;;</span><br><span class="line"></span><br><span class="line">        // 商户操作员编号，添加此参数可以为商户操作员做销售统计</span><br><span class="line">        String operatorId = &quot;test_operator_id&quot;;</span><br><span class="line"></span><br><span class="line">        // (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持</span><br><span class="line">        String storeId = &quot;test_store_id&quot;;</span><br><span class="line"></span><br><span class="line">        // 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持</span><br><span class="line">        ExtendParams extendParams = new ExtendParams();</span><br><span class="line">        extendParams.setSysServiceProviderId(&quot;2088100200300400500&quot;);</span><br><span class="line"></span><br><span class="line">        // 支付超时，定义为120分钟</span><br><span class="line">        String timeoutExpress = &quot;120m&quot;;</span><br><span class="line"></span><br><span class="line">        // 商品明细列表，需填写购买商品详细信息，</span><br><span class="line">        List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;GoodsDetail&gt;();</span><br><span class="line">        // 创建一个商品信息，参数含义分别为商品id（使用国标）、名称、单价（单位为分）、数量，如果需要添加商品类别，详见GoodsDetail</span><br><span class="line">        GoodsDetail goods1 = GoodsDetail.newInstance(&quot;goods_id001&quot;, &quot;xxx小面包&quot;, 1000, 1);</span><br><span class="line">        // 创建好一个商品后添加至商品明细列表</span><br><span class="line">        goodsDetailList.add(goods1);</span><br><span class="line"></span><br><span class="line">        // 继续创建并添加第一条商品信息，用户购买的产品为“黑人牙刷”，单价为5.00元，购买了两件</span><br><span class="line">        GoodsDetail goods2 = GoodsDetail.newInstance(&quot;goods_id002&quot;, &quot;xxx牙刷&quot;, 500, 2);</span><br><span class="line">        goodsDetailList.add(goods2);</span><br><span class="line"></span><br><span class="line">        // 创建扫码支付请求builder，设置请求参数</span><br><span class="line">        AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder()</span><br><span class="line">                .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo)</span><br><span class="line">                .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body)</span><br><span class="line">                .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams)</span><br><span class="line">                .setTimeoutExpress(timeoutExpress)</span><br><span class="line">                //                .setNotifyUrl(&quot;http://www.test-notify-url.com&quot;)//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置</span><br><span class="line">                .setGoodsDetailList(goodsDetailList);</span><br><span class="line"></span><br><span class="line">        AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder);</span><br><span class="line">        switch (result.getTradeStatus()) &#123;</span><br><span class="line">            case SUCCESS:</span><br><span class="line">                log.info(&quot;支付宝预下单成功: )&quot;);</span><br><span class="line"></span><br><span class="line">                AlipayTradePrecreateResponse response = result.getResponse();</span><br><span class="line">                dumpResponse(response);</span><br><span class="line"></span><br><span class="line">                // 需要修改为运行机器上的路径</span><br><span class="line">                String filePath = String.format(&quot;F:/qr-%s.png&quot;,</span><br><span class="line">                        response.getOutTradeNo());</span><br><span class="line">                log.info(&quot;filePath:&quot; + filePath);</span><br><span class="line">                ZxingUtils.getQRCodeImge(response.getQrCode(), 256, filePath);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case FAILED:</span><br><span class="line">                log.error(&quot;支付宝预下单失败!!!&quot;);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case UNKNOWN:</span><br><span class="line">                log.error(&quot;系统异常，预下单状态未知!!!&quot;);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                log.error(&quot;不支持的交易状态，交易返回异常!!!&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 简单打印应答</span><br><span class="line">    private void dumpResponse(AlipayResponse response) &#123;</span><br><span class="line">        if (response != null) &#123;</span><br><span class="line">            log.info(String.format(&quot;code:%s, msg:%s&quot;, response.getCode(), response.getMsg()));</span><br><span class="line">            if (StringUtils.isNotEmpty(response.getSubCode())) &#123;</span><br><span class="line">                log.info(String.format(&quot;subCode:%s, subMsg:%s&quot;, response.getSubCode(),</span><br><span class="line">                        response.getSubMsg()));</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(&quot;body:&quot; + response.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用函数的时候，因为我这里只是个Demo，没做太多操作，请小伙伴们根据自己的实际情况进行传参</p><p><strong>强调一点 ZxingUtils.getQRCodeImge(response.getQrCode(), 256, filePath);是生成的二维码</strong></p><p><strong>要扫这个工具生成的二维码才可以</strong></p><p>重点：</p><p>上支付宝官方的图</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/03.png"><p>支付成功后的回调！当我们支付成功的时候，支付宝会根据我们事先定义好的接口，发起回调，前提是这个接口必须是公网可以访问的才行，有两种方法，申请一个公网Ip地址，或者使用内网穿透，这里我来使用一下内网穿透，内网穿透的工具很多，关于内网穿透的知识，可以参看我的另外一篇博客 内网穿透</p><p>这里我设置一下我的回调接口</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/04.png"><p>写个Controller进行Debug</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/05.png"><p>运行项目，进行一次支付，可以接收到回调</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/06.png"><p>官方文档：<a href="https://docs.open.alipay.com/203/105286/" target="_blank" rel="noopener">https://docs.open.alipay.com/203/105286/</a>有关异步回调的一些说明</p><p>我把一些注意点强调一下：</p><ol><li><strong>程序执行完后必须打印输出“success”（不包含引号）。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）</strong></li><li><strong>程序执行完成后，该页面不能执行页面跳转。如果执行页面跳转，支付宝会收不到success字符，会被支付宝服务器判定为该页面程序运行出现异常，而重发处理结果通知</strong></li><li><strong>cookies、session等在此页面会失效，即无法获取这些数据</strong></li></ol><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/07.png"><p>按照步骤做就可以了</p><p>我这里直接贴代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/alipay_callback&quot;)</span><br><span class="line">    public Object alipayCallback(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();</span><br><span class="line">        Map requestParams = request.getParameterMap();</span><br><span class="line">        for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">            String name = (String) iter.next();</span><br><span class="line">            String[] values = (String[]) requestParams.get(name);</span><br><span class="line">            String valueStr = &quot;&quot;;</span><br><span class="line">            for (int i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">                valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            params.put(name, valueStr);</span><br><span class="line">        &#125;</span><br><span class="line">        if(params == null || params.size() == 0)&#123;</span><br><span class="line">            return &quot;failed&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;支付宝回调,sign: &#123;&#125;, trade_status: &#123;&#125;, 参数: &#123;&#125;&quot;, params.get(&quot;sign&quot;), params.get(&quot;trade_status&quot;), params.toString());</span><br><span class="line"></span><br><span class="line">        //验证回调的正确性</span><br><span class="line">        params.remove(&quot;sign_type&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean alipayRSACheck = AlipaySignature.rsaCheckV2(params, Configs.getAlipayPublicKey(), &quot;utf-8&quot;, Configs.getSignType());</span><br><span class="line">            if (!alipayRSACheck) &#123;</span><br><span class="line">                //非法请求</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (AlipayApiException e) &#123;</span><br><span class="line">            log.error(&quot;支付宝验证回调异常&quot;, e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //验证各种数据</span><br><span class="line">        //业务代码</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里注意一点，用SpringBoot打包的时候，如果按照平时的方法打包，会报错，找不到Alipay的类（SSM同理）</p><p>在maven里面</p><p>加上下面的配置</p><p>外部jar包根据实际情况自行进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                    &lt;compilerArguments&gt;</span><br><span class="line">                        &lt;extdirs&gt;$&#123;project.basedir&#125;/src/main/resources/lib&lt;/extdirs&gt;</span><br><span class="line">                    &lt;/compilerArguments&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/08/02/SpringBoot整合支付宝-当面付(二)/01.png&quot;&gt;
&lt;p&gt;在上一篇简单将一个支付宝Demo跑起来后，现在需要整合到我们的springBoot项目，虽然说是整合SpringBoot，但是，你SSM也都是可以的&lt;/p&gt;
&lt;p&gt;我
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="支付宝当面付" scheme="http://yoursite.com/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%BD%93%E9%9D%A2%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合支付宝-当面付(一)</title>
    <link href="http://yoursite.com/2019/08/02/SpringBoot%E6%95%B4%E5%90%88%E6%94%AF%E4%BB%98%E5%AE%9D-%E5%BD%93%E9%9D%A2%E4%BB%98(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/08/02/SpringBoot整合支付宝-当面付(一)/</id>
    <published>2019-08-02T08:10:15.000Z</published>
    <updated>2019-08-02T01:54:27.842Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/01.png"><p>闲话不多讲直接上干货</p><p>以下是当面付的Demo</p><p><a href="https://docs.open.alipay.com/54/104506" target="_blank" rel="noopener">https://docs.open.alipay.com/54/104506</a></p><p>这里我们先下载Java版的下来看看</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/02.jpg"><p>这是一个Eclipse版的Web项目，我这里使用的工具是IDEA，需要转换一下</p><p>点击File—&gt;Project Structure</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/03.png"><p>添加好之后点击右下角Apply，项目会多一个web目录</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/04.jpg"><p>选择好项目的模块右下角点击Apply</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/05.png"><p>将原先的webroot下面jsp和图片放到web下</p><p>启动项目,进入二维码支付</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/06.jpg"><p>启动项目会报错，查看控制台，会看到乱码，产生问题原因是我们没有在zfbinfo.properties写对应的配置</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/07.png"><p>我们需要去蚂蚁金服开放平台登陆入驻，</p><p>做好登陆入驻后：</p><p>在右上角点击管理中心—–&gt;开发中心——&gt;研发服务</p><p>我们使用沙箱环境</p><p>里面有APPID等信息，对应填上我们的配置文件里面就可以了</p><p>我们现在是开发环境：（需要修改的配置项）</p><p>把支付宝网关的地址<a href="https://openapi.alipay.com/gateway.do修改为https://openapi.alipaydev.com/gateway.do" target="_blank" rel="noopener">https://openapi.alipay.com/gateway.do修改为https://openapi.alipaydev.com/gateway.do</a></p><p>appid：对应的APPID</p><p>pid：商户UID</p><p>密钥生成：</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/08.jpg"><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/09.png"><p>将生成的商户应用密钥的私钥和公钥对应配置到zfbinfo.properties中的private_key和public_key中</p><p>我们使用：SHA256withRsa对应支付宝公钥</p><p>在沙箱应用的</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/10.png"><p>点击查看应用公钥，点击修改，将刚才生成的商户应用公钥粘贴进去，修改完成后，点击查看支付宝公钥</p><p>将支付宝公钥配置到zfbinfo.properties的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#SHA256withRsa对应支付宝公钥</span><br><span class="line">alipay_public_key=xxxxxxxxx</span><br></pre></td></tr></table></figure><p>重启项目</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/11.png"><p>成功了之后用我们的支付宝扫一下</p><p>停！我们要使用沙箱专用的支付宝才行</p><p>我们在沙箱工具里面<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=tool" target="_blank" rel="noopener">https://openhome.alipay.com/platform/appDaily.htm?tab=tool</a></p><p>下载沙箱版的钱包，账号密码和支付密码，在对应的沙箱账号里面有显示</p><p>本文篇幅有点过长，决定使用两篇文章来写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/08/02/SpringBoot整合支付宝-当面付(一)/01.png&quot;&gt;
&lt;p&gt;闲话不多讲直接上干货&lt;/p&gt;
&lt;p&gt;以下是当面付的Demo&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.open.alipay.com/54/10450
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="支付宝当面付" scheme="http://yoursite.com/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%BD%93%E9%9D%A2%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者</title>
    <link href="http://yoursite.com/2019/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85/"/>
    <id>http://yoursite.com/2019/08/01/设计模式-建造者/</id>
    <published>2019-08-01T09:20:11.000Z</published>
    <updated>2019-08-01T04:36:23.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><strong>将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表示</strong></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>如果一个对象有非常复杂的内部结构，可以把复杂对象的创建和适用分离</p><p>扩展性好，建造类之间独立</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>产生多余的Builder</p><p>产生的内部发生变化，建造者都要修改，成本较大</p><p>适用于规模固定的场景</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>创建一个产品类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Product &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Double price;</span><br><span class="line">    //隐藏了get和set方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个产品的一个构建者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface ProductBuilder &#123;</span><br><span class="line">    void buildProductName(String name);</span><br><span class="line">    void buildProductPrice(Double price);</span><br><span class="line">    Product makeProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现产品构建者的实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ProductActualBuilder implements ProductBuilder &#123;</span><br><span class="line"></span><br><span class="line">    private Product product = new Product();</span><br><span class="line"></span><br><span class="line">    public void buildProductName(String name) &#123;</span><br><span class="line">        product.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void buildProductPrice(Double price) &#123;</span><br><span class="line">        product.setPrice(price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Product makeProduct() &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上一张图以表示它们之间的关系</p><img src="/2019/08/01/设计模式-建造者/01.png"><p>测试Demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ProductBuilder productBuilder = new ProductActualBuilder();</span><br><span class="line">        productBuilder.buildProductName(&quot;aaa&quot;);</span><br><span class="line">        productBuilder.buildProductPrice(100.0);</span><br><span class="line">        Product product = productBuilder.makeProduct();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子我们就完成了建造者设计模式的一个完整demo了</p><h4 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h4><p>这一个设计模式下来，看上去，和我们直接调用set方法没啥区别，的确，就是一样样的</p><p>buildProductName和setProductName，从某个角度，可以看似一样的东西，但是，一般来讲，我们从名字上可以取分set就是设值操作，build是一个更为抽象的东西，我build一个房子，里面包含了许多build步骤，而我set一个房子，从名字中就是设置一个名字的什么什么</p><p>而本次案例当中build方法比较简单，只是为了来说明一下构建者模式仅此而已</p><p>接下来我们来写一个链式调用的构建者模式</p><p>一样是Product类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Product &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Double price;</span><br><span class="line"></span><br><span class="line">    public Product(ProductBuilder productBuilder)&#123;</span><br><span class="line">        this.name = productBuilder.name;</span><br><span class="line">        this.price = productBuilder.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ProductBuilder&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private Double price;</span><br><span class="line">        public ProductBuilder buildProductName(String name)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public ProductBuilder buildProductPrice(Double price)&#123;</span><br><span class="line">            this.price = price;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Product build()&#123;</span><br><span class="line">            return new Product(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别的地方在于，在Product类里面实现了构建者</p><p>TestDemo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       Product product = new Product.ProductBuilder().buildProductName(&quot;build&quot;)</span><br><span class="line">               .buildProductPrice(100.2).build();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子，代码更加精简</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>建造者，用于对复杂对象的构造、初始化，与工厂模式不同的是，建造者的目的在于把复杂构造过程从不同对象展现中抽离出来，使得同样的构造工序可以展现出不同的产品对象。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; title=&quot;建造者模式&quot;&gt;&lt;/a&gt;建造者模式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表示&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透</title>
    <link href="http://yoursite.com/2019/07/13/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://yoursite.com/2019/07/13/内网穿透/</id>
    <published>2019-07-13T13:55:00.000Z</published>
    <updated>2019-07-13T07:22:56.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是内网和外网"><a href="#什么是内网和外网" class="headerlink" title="什么是内网和外网"></a>什么是内网和外网</h3><p>所谓内网就是内部建立的局域网络或办公网络。举个例：一家公司或一个家庭有多台计算机，他们利用不同网络布局将这一台或多台计算机或其它设备连接起来构成一个局部的办公或者资源共享网络，我们就称它为内部网络，也叫内网。</p><img src="/2019/07/13/内网穿透/01.jpg"><p>所谓外网就是通过一个网关或网桥与其它网络系统连接，相对于自己的内网来说，连接的其它网络系统就称为外部网络，也叫外网。举例说明：当一家公司或一个家庭的所有电脑网络想要与公司或家庭以外的网络连接（比如连接互连网），相对于这家公司或家庭，其它网络（或互连网）就称为外网！</p><h3 id="为什么需要内网穿透"><a href="#为什么需要内网穿透" class="headerlink" title="为什么需要内网穿透"></a>为什么需要内网穿透</h3><p>简单来说：</p><p><strong>当内网中的主机没有静态IP地址却要被外网稳定访问时可以使用内网穿透</strong></p><p>在互联网中唯一定位一台主机的方法是通过公网的IP地址，但固定IP是一种非常稀缺的资源，不可能给每个公司都分配一个，且许多中小公司不愿意为高昂的费用买单，多数公司直接或间接的拨号上网，电信部门会给接入网络的用户分配IP地址，以前上网用户少的时候基本分配的都是临时的静态IP地址，租约过了之后可能会更换成另一个IP地址，这样外网访问就不稳定，因为内网的静态IP地址一直变化，为了解决这个问题可以使用动态域名解析的办法变换域名指向的静态IP地址。但是现在越来越多的上网用户使得临时分配的静态IP地址也不够用了，电信部门开始分配一些虚拟的静态IP地址，这些IP是公网不能直接访问的，如以125开头的一些IP地址，以前单纯的动态域名解析就不好用了。</p><h3 id="内网穿透的定义与障碍"><a href="#内网穿透的定义与障碍" class="headerlink" title="内网穿透的定义与障碍"></a>内网穿透的定义与障碍</h3><p><strong>当内网中的主机没有静态IP地址要被外网稳定访问时可以使用内网穿透</strong></p><p><strong>障碍一</strong>：位于局域网内的主机有两套 IP 地址，一套是局域网内的 IP 地址，通常是动态分配的，仅供局域网内的主机间通信使用；一套是经过网关转换后的外网 IP 地址，用于与外网程序进行通信。</p><img src="/2019/07/13/内网穿透/02.png"><p>障碍二：位于不同局域网内的两台主机，即使是知道了对方的 IP 地址和端口号，“一厢情愿”地将数据包发送过去，对方也是接收不到的。</p><p>因为出于安全起见，除非是主机主动向对方发出了连接请求（这时会在该主机的数据结构中留下一条记录），否则，当主机接收到数据包时，如果在其数据结构中查询不到对应的记录，那些不请自来的数据包将会被丢弃。</p><img src="/2019/07/13/内网穿透/03.png"><p><strong>解决办法：要想解决以上两大障碍，我们需要借助一台具有公网 IP 的服务器进行桥接。</strong></p><h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><p>ngrok是一个反向代理，通过在公共的端点和本地运行的Web服务器之间建立一个安全的通道。ngrok可捕获和分析所有通道上的流量，便于后期分析与响应。</p><img src="/2019/07/13/内网穿透/04.png"><p>没有ngrok的时候</p><p>作为一个Web开发者，我们有时候会需要临时地将一个本地的Web网站部署到外网，以供他人体验评价或协助调试等等，通常我们会这么做：</p><ol><li><p>找到一台运行于外网的Web服务器</p></li><li><p>服务器上有网站所需要的环境，否则自行搭建</p></li><li><p>将网站部署到服务器上</p></li><li>调试结束后，再将网站从服务器上删除</li></ol><p>有ngrok的时候</p><ol><li>首先注册并下载ngrok，得到一串授权码</li><li>ngrok -authtoken 你的授权码 80，80是你本地Web服务的端口，而之后ngrok会记住你的授权码，直接ngrok 80就OK了</li><li>你会得到一串网址，通过这个网址就可以访问你本地的Web服务了</li></ol><p>去官方注册个账号或者使用github账号登陆一下,有步骤介绍</p><img src="/2019/07/13/内网穿透/05.png"><p>下载ngrok，这里以Windows为例子</p><p>下载的是一个压缩包，解压后，用CMD进入到该目录下执行以下命令,后面是一个token值，随便打即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ngrok authtoken (authtoken看自己的token值，登陆之后在Auth下可以查看)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ngrok http 8080</span><br></pre></td></tr></table></figure><img src="/2019/07/13/内网穿透/06.jpg"><p>解析来我们就可以拿着对应的域名来访问了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是内网和外网&quot;&gt;&lt;a href=&quot;#什么是内网和外网&quot; class=&quot;headerlink&quot; title=&quot;什么是内网和外网&quot;&gt;&lt;/a&gt;什么是内网和外网&lt;/h3&gt;&lt;p&gt;所谓内网就是内部建立的局域网络或办公网络。举个例：一家公司或一个家庭有多台计算机，他们利用不
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://yoursite.com/2019/06/23/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yoursite.com/2019/06/23/布隆过滤器/</id>
    <published>2019-06-23T14:51:43.000Z</published>
    <updated>2019-07-13T05:55:16.893Z</updated>
    
    <content type="html"><![CDATA[<p>先探讨一个问题？</p><p>现在有50亿个电话号码，现在要快速准确判断这些电话号码是否已经存在？</p><ol><li>数据库查询？太慢了</li><li>数据使用集合存放在内存？内存浪费</li><li>布隆过滤器！</li></ol><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><h4 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h4><p>它实际上是一个很长的二进制向量和一系列随机映射函数</p><h4 id="布隆过滤器的实现原理"><a href="#布隆过滤器的实现原理" class="headerlink" title="布隆过滤器的实现原理"></a>布隆过滤器的实现原理</h4><p>当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>画个图描述一下</p><img src="/2019/06/23/布隆过滤器/01.jpg"><h4 id="布隆过滤器的误差率"><a href="#布隆过滤器的误差率" class="headerlink" title="布隆过滤器的误差率"></a>布隆过滤器的误差率</h4><p>直观因素：m/n的比率，hash函数的个数</p><p>1个元素，1个hash函数，任意一个比特为1的概率为1/m，依然为0的概率为1-1/m</p><p>k给函数，依然为0的概率为（1-1/m）^k，n个元素，依然为0的概率为(1-1/m)^nk</p><p>被设置为1的概率为1-(1-1/m)^nk</p><p>新元素权重的概率为（1-(1-1/m)^nk）^k</p><h4 id="本地布隆过滤器"><a href="#本地布隆过滤器" class="headerlink" title="本地布隆过滤器"></a>本地布隆过滤器</h4><p>使用Guava来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class BloomFilterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //构建布隆过滤器</span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(new Funnel&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void funnel(String s, PrimitiveSink primitiveSink) &#123;</span><br><span class="line">                primitiveSink.putString(s, Charsets.UTF_8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,10000,0.0001);</span><br><span class="line">        //插入数据</span><br><span class="line">        for (int i = 0 ; i &lt; 1000 ; i++)&#123;</span><br><span class="line">            bloomFilter.put(&quot;i_&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        //测试结果</span><br><span class="line">        for (int i = 0 ; i &lt; 1005 ; i++)&#123;</span><br><span class="line">            if(!bloomFilter.mightContain(&quot;i_&quot;+i))&#123;</span><br><span class="line">                System.out.println(&quot;no&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于Redis的布隆过滤器"><a href="#基于Redis的布隆过滤器" class="headerlink" title="基于Redis的布隆过滤器"></a>基于Redis的布隆过滤器</h4><p>redis 在 4.0 的版本中加入了 module 功能，布隆过滤器可以通过 module 的形式添加到 redis 中，所以使用 redis 4.0 以上的版本可以通过加载 module 来使用 redis 中的布隆过滤器</p><p>在Docker中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker run -d -p 6379:6379 --name bloomfilter redislabs/rebloom</span><br><span class="line">&gt; docker exec -it bloomfilter redis-cli</span><br><span class="line"># redis-cli</span><br><span class="line"># 127.0.0.1:6379&gt;</span><br><span class="line"># 127.0.0.1:6379&gt; BF.ADD newFilter foo</span><br><span class="line">(integer) 1</span><br><span class="line"># 127.0.0.1:6379&gt; BF.EXISTS newFilter foo</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先探讨一个问题？&lt;/p&gt;
&lt;p&gt;现在有50亿个电话号码，现在要快速准确判断这些电话号码是否已经存在？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库查询？太慢了&lt;/li&gt;
&lt;li&gt;数据使用集合存放在内存？内存浪费&lt;/li&gt;
&lt;li&gt;布隆过滤器！&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;布隆
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis-缓存设计</title>
    <link href="http://yoursite.com/2019/05/27/Redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/05/27/Redis-缓存设计/</id>
    <published>2019-05-27T14:49:16.000Z</published>
    <updated>2019-05-29T05:38:25.468Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/27/Redis-缓存设计/01.png"><h3 id="缓存有什么作用？"><a href="#缓存有什么作用？" class="headerlink" title="缓存有什么作用？"></a>缓存有什么作用？</h3><p>先来看一幅图</p><img src="/2019/05/27/Redis-缓存设计/02.png"><p>缓存主要带来了什么好处呢？</p><ol><li><p>加速读写</p><p>因为缓存通常都是全内存的（例如Redis、Memcache），而存储层通常读写性能不够强悍（例如MySQL），通过缓存的使用可以有效地加速读写，优化用户体验</p></li><li><p>降低后端负载</p><p>帮助后端减少访问量和复杂计算（例如很复杂的SQL语句），在很大程度降低了后端的负载</p></li></ol><p>当然，缓存能够给我们带来好的方便，但是也加大了开发者的开发成本</p><p>接下来我们就来学习下如何使用Redis来设计缓存，以及注意的问题：</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存中的数据通常都是有生命周期的，需要在指定时间后被删除或更新，这样可以保证缓存空间在一个可控的范围。</p><p>三种策略：</p><h4 id="LRU-LFU-FIFO算法剔除"><a href="#LRU-LFU-FIFO算法剔除" class="headerlink" title="LRU/LFU/FIFO算法剔除"></a>LRU/LFU/FIFO算法剔除</h4><p>通常用于缓存使用量超过了预设的最大值时候，如何对现有的数据进行剔除。例如Redis使用maxmemory-policy这个配置作为内存最大值后对于数据的剔除策略,还要设置maxmemory（最大内存）</p><p>maxmemory 默认为0（代表不限制Redis的内存使用）</p><p>maxmemory-policy有六种策略</p><ol><li>noeviction: 不进行置换，表示即使内存达到上限也不进行置换，所有能引起内存增加的命令都会返回error</li><li>allkeys-lru: 优先删除掉最近最不经常使用的key，用以保存新数据</li><li>volatile-lru: 只从设置失效（expire set）的key中选择最近最不经常使用的key进行删除，用以保存新数据</li><li>allkeys-random: 随机从all-keys中选择一些key进行删除，用以保存新数据</li><li>volatile-random: 只从设置失效（expire set）的key中，选择一些key进行删除，用以保存新数据</li><li>volatile-ttl: 只从设置失效（expire set）的key中，选出存活时间（TTL）最短的key进行删除，用以保存新数据</li></ol><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>使用简单，只用修改对应的配置文件就可以</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>数据的清理由选择算法决定，开发人员只能选择置换内存的算法策略，所以数据的一致性是最差的</p><h4 id="超时剔除"><a href="#超时剔除" class="headerlink" title="超时剔除"></a>超时剔除</h4><p>超时剔除通过给缓存数据设置过期时间，让其在过期时间后自动删除，Redis提供了expire命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ EXPIRE key time(s)</span><br></pre></td></tr></table></figure><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>使用简单，只需要设置对应key的过期时间即可</p><p>能够允许在一段时间内的数据不一致或者是数据对实际业务影响不大的场景，此方案还是很好的解决方案</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>数据不一致：如果，数据对实际业务影响比较大的场景，谨慎使用，特别涉及到金钱交易的情况下</p><h4 id="主动更新"><a href="#主动更新" class="headerlink" title="主动更新"></a>主动更新</h4><p>应用方对于数据的一致性要求高，需要在真实数据更新后，立即更新缓存数据。例如可以利用消息系统或者其他方式通知缓存更新</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>可以根据自己的业务需求来完成缓存的更新，解决了单纯使用expire设置过期时间的局限性</p><p>一致性最高，但如果主动更新发生了问题，那么这条数据很可能很长时间不会更新，所以建议结合超时剔除一起使用效果会更好</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>维护成本会比较高，开发者需要自己来完成更新，并保证更新操作的正确性</p><img src="/2019/05/27/Redis-缓存设计/03.png"><p>有两个建议：</p><ol><li>低一致性业务建议配置最大内存和淘汰策略的方式使用</li><li>高一致性业务可以结合使用超时剔除和主动更新，这样即使主动更新出了问题，也能保证数据过期时间后删除脏数据</li></ol><h3 id="缓存粒度"><a href="#缓存粒度" class="headerlink" title="缓存粒度"></a>缓存粒度</h3><p>很多时候我们缓存的值是后端Mysql或者别的数据库查询出来的值，因为一般来说，复杂的查询比较费时，所以查询出来放进redis是一个比较明智的做法</p><p>那么我们要缓存多少，缓存到一个什么层度呢？</p><p>比如说：缓存所有列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:&#123;id&#125; &apos;select * from user where id=&#123;id&#125;&apos;</span><br></pre></td></tr></table></figure><p>缓存部分列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set user:&#123;id&#125; &apos;select &#123;importantColumn1&#125;, &#123;important Column2&#125; ... &#123;importantColumnN&#125;</span><br><span class="line">from user where id=&#123;id&#125;&apos;</span><br></pre></td></tr></table></figure><p>这个问题就是缓存粒度问题</p><p>缓存全部数据要比部分数据占用更多的空间，可能存在以下问题：</p><ol><li>全部数据会造成内存的浪费</li><li>全部数据可能每次传输产生的网络流量会比较大，耗时相对较大，在极端情况下会阻塞网络</li><li>全部数据的序列化和反序列化的CPU开销更大</li></ol><img src="/2019/05/27/Redis-缓存设计/04.png"><p>缓存粒度问题是一个容易被忽视的问题，如果使用不当，可能会造成很多无用空间的浪费，网络带宽的浪费，代码通用性较差等情况，需要综合数据通用性、空间占用比、代码维护性三点进行取舍</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><img src="/2019/05/27/Redis-缓存设计/05.png"><p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，当被别人恶意访问查询一个不存在的数据的时候，请求就会访问到存储层（Mysql），当请求量很大的情况下，Mysql是承受不了的，可能造成后端存储宕掉，而且缓存层也失去了保护存储层的意义</p><p>解决办法：</p><ol><li><p>缓存空对象</p><p>当第2步存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源，缺点：</p><ol><li><p>缓存层中存了更多的键，需要更多的内存空间(也是一种危害)</p><p><strong>措施：是将这类的Key设置一个较短的过期时间</strong></p></li><li><p>缺点：缓存层和存储层的短暂不一致</p><p><strong>措施：可以利用消息系统或者其他方式清除掉缓存层中的空对象</strong></p></li></ol></li><li><p>布隆过滤器</p><p>在访问缓存层之前，将存在的key用布隆过滤器提前保存起来,当访问不存在的key的时候，布隆过滤器直接返回，可以避免访问缓存层和存储层</p></li><li><p>使用互斥锁：根据key获取value值为空时，锁上，从数据库中load数据后再释放锁（适合并发量比较低的情况，因为并发量很大的情况下，会导致阻塞和死锁的情况）</p></li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>由于缓存层承载大量请求，当cache服务异常/脱机，流量打向了后端的存储层，造成存储层也会级联宕机的情<br>况，除了缓存服务异常和脱机的情况，还有另外一种情况：缓存key大片面积失效（时间到期）也会导致缓存雪崩</p><img src="/2019/05/27/Redis-缓存设计/06.png"><p>关于解决缓存服务异常和脱机需要注意的几个问题:</p><ol><li><p>保证缓存层服务高可用性</p><p>如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务</p></li><li><p>依赖隔离组件为后端限流并降级</p><p>我们需要对重要的资源（例如Redis、MySQL、HBase、外部接口）都进行隔离，让每种资源都单独运行在自己的线程池中，即使个别资源出现了问题，对其他服务没有影响</p></li><li><p>提前演练</p><p>演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定</p></li></ol><p>解决方案：</p><ol><li>在设置缓存时候，不设置统一的过期时间，而是在一个范围内随机设置过期时间，以防止大量的key同时过期</li><li>使用互斥锁：根据key获取value值为空时，锁上，从数据库中load数据后再释放锁（适合并发量比较低的情况，因为并发量很大的情况下，会导致阻塞和死锁的情况）</li><li>提前使用互斥锁，比如key10S过期，在内部使用一个标识key 8S过期，假设标识key过期的时候，就给对应的Key延长过期时间</li><li>双缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，如果A没有则读B，并且更新A缓存和B缓存（对存储的消耗比较大）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/27/Redis-缓存设计/01.png&quot;&gt;
&lt;h3 id=&quot;缓存有什么作用？&quot;&gt;&lt;a href=&quot;#缓存有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;缓存有什么作用？&quot;&gt;&lt;/a&gt;缓存有什么作用？&lt;/h3&gt;&lt;p&gt;先来看一
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-抽象工厂</title>
    <link href="http://yoursite.com/2019/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>http://yoursite.com/2019/05/27/设计模式-抽象工厂/</id>
    <published>2019-05-27T10:25:23.000Z</published>
    <updated>2019-05-27T03:40:39.951Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p><strong>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口</strong></p><ul><li>客户端（应用层）不依赖于产品类实例如何被创建，实现等细节</li><li>强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码</li><li>具体产品在应用层代码隔离，无需关系创建细节</li><li>将一个系列的产品族一起创建</li></ul><p>产品族：这里画个图来帮助理解</p><img src="/2019/05/27/设计模式-抽象工厂/01.jpg"><p>比如说，小米的所有子产品都属于一个产品族</p><p>前面学的工厂方法所关注的就是产品等级结构：就如图中的小米电脑和苹果电脑，都属于电脑</p><p>这里的抽象工厂关注的是一个产品族:我们只需要指出一个产品所处于的产品族以及所属的等级结构就能唯一确定这个产品（举个例子：从小米工厂取出的手机——》就是小米手机）</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>工厂接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 品牌工厂</span><br><span class="line"> */</span><br><span class="line">public interface BrandFactory &#123;</span><br><span class="line">    Phone getPhone();//获得手机</span><br><span class="line">    LapTop getLapTop();//获得手提电脑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个抽象实体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 手提电脑</span><br><span class="line"> */</span><br><span class="line">public abstract class LapTop &#123;</span><br><span class="line">    public abstract void produce();//生产手提电脑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 手机</span><br><span class="line"> */</span><br><span class="line">public abstract class Phone &#123;</span><br><span class="line">    public abstract void produce();//生产手机</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个具体的工厂:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 苹果工厂</span><br><span class="line"> */</span><br><span class="line">public class AppleFactory implements BrandFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone getPhone() &#123;</span><br><span class="line">        return new ApplePhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LapTop getLapTop() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 小米工厂</span><br><span class="line"> */</span><br><span class="line">public class MiFactory implements BrandFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone getPhone() &#123;</span><br><span class="line">        return new MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LapTop getLapTop() &#123;</span><br><span class="line">        return new MiLapTop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个手机的实现类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 小米手机</span><br><span class="line"> */</span><br><span class="line">public class MiPhone extends Phone &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产小米手机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 苹果手机</span><br><span class="line"> */</span><br><span class="line">public class ApplePhone extends Phone &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产苹果手机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个笔记本的实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 苹果笔记本</span><br><span class="line"> */</span><br><span class="line">public class AppleLapTop extends LapTop &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产苹果笔记本&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 小米笔记本</span><br><span class="line"> */</span><br><span class="line">public class MiLapTop extends LapTop &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产小米笔记本&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下类图</p><img src="/2019/05/27/设计模式-抽象工厂/02.jpg"><p>写个测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BrandFactory brandFactory = new MiFactory();</span><br><span class="line">        Phone phone = brandFactory.getPhone();</span><br><span class="line">        LapTop lapTop = brandFactory.getLapTop();</span><br><span class="line">        phone.produce();//输出生产小米手机</span><br><span class="line">        lapTop.produce();//输出小米笔记本</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>在抽象工厂里面，对于应用层，根本不关心手机和笔记本的实现过程，只关心对应的一个工厂，在哪个工厂取得的产品也就是什么工厂的产品，还是上面的例子（小米工厂拿到的手机就是小米手机）</strong></p><p>应用层代码和具体的手机是解耦的，和具体的笔记本电脑也是解耦的</p><p>工厂方法和抽象工厂的最大区别是：</p><p><strong>工厂方法关注的是同一产品等级，抽象工厂关注的是产品族</strong></p><p>抽象工厂</p><p>优点：</p><ol><li>应用层代码不和具体的产品发生依赖，只和具体的产品族工厂发生依赖</li><li>从某个工厂取出的产品，一定是属于这个工厂的产品</li><li>扩展性好，比如增加一个华为的品牌，只用增加一个工厂，一个手机，一个笔记本即可，其余不用发生改变（符合开闭原则）<strong>产品等级稳定的情况下</strong></li></ol><p>缺点：</p><ol><li>新增产品等级的时候，会在原有的结构上进行较大的改动（比如说，增加一个小米生产的别的产品）此时就违背了开闭原则，所以要注意场景使用</li></ol><p><strong>举个真实的例子：在java.sql这个包下Connection这个接口里面PrepareStatement和Statement都是属于一个产品族在这里，就使用到了抽象工厂的设计模式</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;抽象工厂&quot;&gt;&lt;a href=&quot;#抽象工厂&quot; class=&quot;headerlink&quot; title=&quot;抽象工厂&quot;&gt;&lt;/a&gt;抽象工厂&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端（
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Cluster常见问题</title>
    <link href="http://yoursite.com/2019/05/26/Redis-Cluster%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/26/Redis-Cluster常见问题/</id>
    <published>2019-05-26T13:00:30.000Z</published>
    <updated>2019-05-26T12:03:58.697Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/26/Redis-Cluster常见问题/01.png"><h3 id="集群完整性"><a href="#集群完整性" class="headerlink" title="集群完整性"></a>集群完整性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 默认为yes</span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure><p>默认的配置保证了两个问题：</p><ul><li>集群中的161384个槽全部可用，保证了集群的完整性</li><li>节点故障或者故障转移的时候，进行set操作会报 (error) CLUSTERRDOWN The cluster is down</li></ul><p>一个节点坏了，整个集群都不可用了，这在实际业务上是有问题的</p><p>所以我们通常需要将它修改为no</p><h3 id="带宽消耗"><a href="#带宽消耗" class="headerlink" title="带宽消耗"></a>带宽消耗</h3><p>RedisCluster会定期进行Ping/Pong进行心跳检测，也会进行信息的一个交互</p><p>官方建议RedisCluster的节点数量不要超过1000个，因为RedisCluster对带宽的消耗很高</p><p>主要来自下面三个方面</p><ul><li>消息发送频率，节点发现与其他节点最后通信时间超过cluster-node-timeout/2时会直接发送ping消息</li><li>消息数据量：slots槽数组（2KB空间）和整个集群1/10的状态数据（10个节点的状态数据约1KB）</li><li>节点部署的机器规模：集群分布的机器越多且每台机器划分的节点数越均匀，则集群内整体的可用带宽就越高</li></ul><p>举个例子：</p><p>规模：节点200个，20台物理机（每台10个节点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-node-timeout = 15000</span><br></pre></td></tr></table></figure><p>ping/pong的带宽为25Mb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-node-timeout = 20000</span><br></pre></td></tr></table></figure><p>ping/pong带宽会低于15Mb</p><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><ol><li>避免多业务使用一个集群，大业务可以多集群</li><li>cluster-node-timeout:带宽和故障转移速度的均衡</li><li>尽量均匀分配到多机器上，保证高可用和带宽</li></ol><h3 id="Pub-Sub广播"><a href="#Pub-Sub广播" class="headerlink" title="Pub/Sub广播"></a>Pub/Sub广播</h3><p>问题：publish在集群每个节点广播：加重带宽</p><p>解决：针对这种情况建议使用sentinel结构专门用于Pub/Sub功能，从而<br>规避这一问题。</p><h3 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h3><p>集群内特定节点<strong>数据量</strong>过大将导致节点之间负载不均，影响集群均衡和运维成本。</p><p>数据倾斜主要分为以下几种：</p><ol><li><p>·节点和槽分配严重不均。</p><p>当节点对应槽数量不均匀时，可以使用redis-trib.rb rebalance命令进行平衡</p></li><li><p>·不同槽对应键数量差异过大。</p><p>通过命令：cluster countkeysinslot{slot}可以获取槽对应的键数量，识别出哪些槽映射了过多的键。再通过命令clustergetkeysinslot{slot}{count}循环迭代出槽下所有的键。</p></li><li><p>·集合对象包含大量元素。</p><p>对于大集合对象的识别可以使用redis-cli–bigkeys命令识别</p></li><li><p>·内存相关配置不一致。</p><p>当集群大量使用hash、set等数据结构时，如果内存压缩数据结构配置不一致，极端情况下会相差数倍的内存，从而造成节点内存量倾斜。</p></li></ol><h3 id="请求倾斜"><a href="#请求倾斜" class="headerlink" title="请求倾斜"></a>请求倾斜</h3><p>集群内特定节点<strong>请求量/流量</strong>过大将导致节点之间负载不均，影响集群均衡和运维成本。</p><p>避免方式如下：</p><ol><li>合理设计键，热点大集合对象做拆分或使用hmget替代hgetall避免整体读取。</li><li>不要使用热键作为hash_tag，避免映射到同一槽。</li><li>对于一致性要求不高的场景，客户端可使用本地缓存减少热键调用。</li></ol><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="只读连接"><a href="#只读连接" class="headerlink" title="只读连接"></a>只读连接</h4><p>集群模式下从节点不接受任何读写请求，发送过来的键命令会重定向到负责槽的主节点上（其中包括它的主节点）</p><p>当需要使用从节点分担主节点读压力时，可以使用readonly命令打开客户端连接只读状态。</p><p><strong>注意：readonly是连接级别生效，每次连接都要开启一遍才可以</strong></p><img src="/2019/05/26/Redis-Cluster常见问题/02.png"><h4 id="读写分离-1"><a href="#读写分离-1" class="headerlink" title="读写分离"></a>读写分离</h4><p>问题：复制延迟，读取过期数据，从节点故障</p><p>集群模式下读写分离涉及对客户端修改如下：</p><ol><li>维护每个主节点可用从节点列表</li><li>针对读命令维护请求节点路由</li><li>从节点新建连接开启readonly转态</li></ol><p><strong>集群模式下读写分离成本比较高，可以直接扩展主节点数量提高集群性能，一般不建议集群模式下做读写分离</strong></p><p>集群读写分离有时用于特殊业务场景如：</p><ol><li>利用复制的最终一致性使用多个从节点做跨机房部署降低读命令网络延迟。</li><li>主节点故障转移时间过长，业务端把读请求路由给从节点保证读操作可用。</li></ol><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>应用Redis集群时，常需要把单机Redis数据迁移到集群环境。redis-trib.rb工具提供了导入功能，用于数据从单机向集群环境迁移的场景，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-trib.rb import host:port --from &lt;arg&gt; --copy --replace</span><br></pre></td></tr></table></figure><img src="/2019/05/26/Redis-Cluster常见问题/03.png"><p>redis-trib.rb import命令内部采用批量scan和migrate的方式迁移数据。这<br>种迁移方式存在以下缺点：</p><ol><li>迁移只能从单机节点向集群环境导入数据。</li><li>不支持在线迁移数据，迁移数据时应用方必须停写，无法平滑迁移<br>数据。</li><li>迁移过程中途如果出现超时等错误，不支持断点续传只能重新全量<br>导入。</li><li>使用单线程进行数据迁移，大数据量迁移速度过慢</li></ol><p>正因为这些问题，社区开源了很多迁移工具，这里推荐一款唯品会开发的redis-migrate-tool，该工具可满足大多数Redis迁移需求，特点如下：</p><ol><li>·支持单机、Twemproxy、Redis Cluster、RDB/AOF等多种类型的数据迁移</li><li>工具模拟成从节点基于复制流迁移数据，从而支持在线迁移数据，业务方不需要停写</li><li>采用多线程加速数据迁移过程且提供数据校验和查看迁移状态等功能</li></ol><h3 id="集群VS单机"><a href="#集群VS单机" class="headerlink" title="集群VS单机"></a>集群VS单机</h3><h4 id="集群限制"><a href="#集群限制" class="headerlink" title="集群限制"></a>集群限制</h4><ol><li>key批量操作支持有限：mget，mset必须在一个slot上</li><li>key事务和Lua支持有限：操作的key必须在一个节点上</li><li>key是数据分区的最小粒度，不支持bigkey</li><li>不支持多个数据库：集群下只有一个db0</li><li>复制只支持复制一层，不支持树形复制结构</li></ol><h4 id="思考分布式Redis"><a href="#思考分布式Redis" class="headerlink" title="思考分布式Redis"></a>思考分布式Redis</h4><ol><li>RedisCluster:用来满足容量和性能的扩展性，但是要看业务来使用</li><li>大多数情况客户端性能会降低</li><li>命令无法跨节点使用</li><li>Lua和事务无法跨节点使用</li><li>客户端维护更加复杂</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/26/Redis-Cluster常见问题/01.png&quot;&gt;
&lt;h3 id=&quot;集群完整性&quot;&gt;&lt;a href=&quot;#集群完整性&quot; class=&quot;headerlink&quot; title=&quot;集群完整性&quot;&gt;&lt;/a&gt;集群完整性&lt;/h3&gt;&lt;figure clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis-Cluster(集群)</title>
    <link href="http://yoursite.com/2019/05/20/Redis-Cluster(%E9%9B%86%E7%BE%A4)/"/>
    <id>http://yoursite.com/2019/05/20/Redis-Cluster(集群)/</id>
    <published>2019-05-20T12:03:44.000Z</published>
    <updated>2019-05-25T05:51:02.731Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/20/Redis-Cluster(集群)/01.png"><h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>为什么要引入Redis集群</p><p>单机会造成什么问题，官方说法：单机Redis支持十万的并发量，如果我需要二十万呢？三十万呢？这时候就要用到Redis集群，撇开Redis集群不说，集群，就是用来分担单机的压力，无论是访问的压力，查询的压力还是流量的压力，为什么通常都要使用集群来解决呢？比如电脑内存不够往往会想着买一条内存条，但是还不够呢？一台电脑不断加装，成本越来越贵，很不划算，当成本大于我重新买一台电脑的时候，我当然选择两台电脑就是这个意思，更何况通常集群都是上百台呢</p><h3 id="RedisCluster的安装"><a href="#RedisCluster的安装" class="headerlink" title="RedisCluster的安装"></a>RedisCluster的安装</h3><h4 id="原生安装"><a href="#原生安装" class="headerlink" title="原生安装"></a>原生安装</h4><h5 id="配置节点"><a href="#配置节点" class="headerlink" title="配置节点"></a>配置节点</h5><p>启动6个redis，配置的端口从7000-7005，以下是配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/redis/data&quot;</span><br><span class="line">logfile &quot;7000.log&quot;</span><br><span class="line">dbfilename &quot;dump-7000.rdb&quot;</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line">cluster-require-full-coverage no</span><br></pre></td></tr></table></figure><img src="/2019/05/20/Redis-Cluster(集群)/02.png"><h5 id="配置meet"><a href="#配置meet" class="headerlink" title="配置meet"></a>配置meet</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster meet 127.0.0.1 7001</span><br><span class="line">$ redis-cli -p 7000 cluster meet 127.0.0.1 7002</span><br><span class="line">$ redis-cli -p 7000 cluster meet 127.0.0.1 7003</span><br><span class="line">$ redis-cli -p 7000 cluster meet 127.0.0.1 7004</span><br><span class="line">$ redis-cli -p 7000 cluster meet 127.0.0.1 7005</span><br></pre></td></tr></table></figure><h4 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h4><p>编写一个脚本addslots.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start=$1</span><br><span class="line">end=$2</span><br><span class="line">port=$3</span><br><span class="line">for slot in `seq $&#123;start&#125; $&#123;end&#125;`</span><br><span class="line">do</span><br><span class="line">    redis-cli -p $&#123;port&#125; cluster addslots $&#123;slot&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>分配槽给节点，这里我有六个redis，但是我只分配将槽分成三份，另外三份来用做slave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sh addslots.sh 0 5461 7000</span><br><span class="line">$ sh addslots.sh 5462 10922 7001</span><br><span class="line">$ sh addslots.sh 10923 16383 7002</span><br></pre></td></tr></table></figure><img src="/2019/05/20/Redis-Cluster(集群)/03.png"><h4 id="主从分配"><a href="#主从分配" class="headerlink" title="主从分配"></a>主从分配</h4><p>上面将槽分配给了7000，7001，7002，将其对应的slave是7003，7004，7005</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#replicate后面接对应节点的id号，id号可以看我上面那张图，一一对应的，在redis-cli下通过cluster nodes可以查询</span><br><span class="line">$ redis-cli -p 7003 cluster replicate 84b0e3f7ba4d7a709d8b25fe4844b66296af71d8</span><br><span class="line">$ redis-cli -p 7004 cluster replicate 6b17f1a9bb7ee845c1d8c012c2805df76fb9b943</span><br><span class="line">$ redis-cli -p 7005 cluster replicate e32dd59b6b1205ca88050e2124c40ba37200a674</span><br></pre></td></tr></table></figure><img src="/2019/05/20/Redis-Cluster(集群)/04.png"><p>安装结束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000</span><br><span class="line">$ set k1 v1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>可以进入redis-cli后能够进行set操作了</p><h4 id="官方工具安装"><a href="#官方工具安装" class="headerlink" title="官方工具安装"></a>官方工具安装</h4><p>首先按照步骤按照一下官方工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://cache.ruby-lang.org/pub/ruby/2.6/ruby-2.6.3.tar.gz</span><br><span class="line">cd ruby-2.6.3</span><br><span class="line">./configure -prefix=/usr/local/ruby</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">wget http://rubygems.org/downloads/redis-3.3.0.gem</span><br><span class="line">gem install -l redis-3.3.0.gem</span><br><span class="line">gem list -- check redis gem</span><br></pre></td></tr></table></figure><p>然后和上面一样，跑六个节点，全部启动起来</p><p>8000-8005端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 8005</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/redis/data&quot;</span><br><span class="line">logfile &quot;8005.log&quot;</span><br><span class="line">dbfilename &quot;dump-8005.rdb&quot;</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-8005.conf</span><br><span class="line">cluster-require-full-coverage no</span><br></pre></td></tr></table></figure><p>进入redis下的src目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /redis/src</span><br><span class="line">#使用工具来创建集群,其中数量1代表一个主节点配置1个从节点</span><br><span class="line">$ ./redis-trib.rb create --replicas 1 127.0.0.1:8000 127.0.0.1:8001 127.0.0.1:8002 127.0.0.1:8003 127.0.0.1:8004 127.0.0.1:8005</span><br></pre></td></tr></table></figure><img src="/2019/05/20/Redis-Cluster(集群)/05.jpg"><p>对上面没问题可以输入yes</p><p>可以通过以下命令，查看集群是否搭建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 8000 cluster nodes</span><br><span class="line">$ redis-cli -p 8000 cluster info</span><br></pre></td></tr></table></figure><h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><ol><li><p>启动两个独立的redis，其中8006和8007是独立的</p><img src="/2019/05/20/Redis-Cluster(集群)/06.png"></li><li><p>将集群种的节点对独立的节点进行meet操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 8000 cluster meet 127.0.0.1 8006</span><br><span class="line">$ redis-cli -p 8000 cluster meet 127.0.0.1 8007</span><br></pre></td></tr></table></figure></li><li><p>主从的分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 8006 cluster replicate 8007的runId</span><br></pre></td></tr></table></figure></li><li><p>分配槽，使用redis-trib的工具</p><p>进入 src目录下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:8000</span><br></pre></td></tr></table></figure></li></ol><p>分配完成</p><img src="/2019/05/20/Redis-Cluster(集群)/08.jpg"><h3 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h3><p>./redis-trib.rb reshard – from 不要的节点的runId –to 分配的节点的runId –slots 多少个槽 1366 让哪个端口去执行<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard --from 9334fcdbc2453637e86f1b6664a8c86413eb87d4 --to d576410d1da0cd11f29035550ef0eaf81a811ea7 --slots 1366 127.0.0.1:8007</span><br></pre></td></tr></table></figure><p>按照这个方法可以把槽分配给其他节点</p><p>把所有槽都分配完成后，可以去删除节点</p><p>./redis-trib.rb del-node 分配一个Ip地址:端口 运行的runId</p><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb del-node 127.0.0.1:8000 9334fcdbc2453637e86f1b6664a8c86413eb87d4</span><br></pre></td></tr></table></figure><img src="/2019/05/20/Redis-Cluster(集群)/09.jpg"><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>首先简单讲一下ASK重定向和Moved重定向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入redis-cli</span><br><span class="line">$ redis-cli -p 8000</span><br><span class="line">$ set k1 v1</span><br><span class="line">(error) MOVED 12706 192.168.25.155:8002</span><br></pre></td></tr></table></figure><p>这个就是MOVED异常</p><p>什么意思呢？就是说，当你要设置一个key的时候，如果当前这个key的hash值计算出来的槽不在当前节点，就会报错，错误会告诉你应该去哪个节点里面进行一个set操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入集群下的redis-cli</span><br><span class="line">$ redis-cli -c -p 8000</span><br><span class="line">$ set k1 v1</span><br><span class="line">-&gt; Redirected to slot [12706] located at 192.168.25.155:8002</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>这就是Moved重定向，会自动帮我们进行一个重定向到8002端口的Redis然后进行一个set操作</p><p>接下来讲讲ASK重定向</p><p>什么是ASK重定向呢？</p><p>ask异常是在槽的迁移过程才会发生的</p><p>什么意思呢，比如访问k1这个槽的节点的时候，节点报ASK异常，说明这个k1当前在我这个节点，但k1这个槽即将迁移到新的节点当中，ask的重定向会返回一个迁移到的目标节点的信息</p><img src="/2019/05/20/Redis-Cluster(集群)/10.png"><p>Smart客户端,会识别ask异常和moved异常来进行一个对节点的切换</p><p>JavaDemo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class JedisClusterDemo &#123;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(JedisClusterDemo.class);</span><br><span class="line">    private Set&lt;HostAndPort&gt; nodeSet = new HashSet&lt;&gt;();</span><br><span class="line">    private JedisCluster jedisCluster = null;</span><br><span class="line">    private List&lt;String&gt; hostPortList = new ArrayList&lt;&gt;();</span><br><span class="line">    @Before</span><br><span class="line">    public void setup()&#123;</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8000&quot;);</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8001&quot;);</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8002&quot;);</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8003&quot;);</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8004&quot;);</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8005&quot;);</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();</span><br><span class="line">        for(String hostPort : hostPortList)&#123;</span><br><span class="line">            String[] arr = hostPort.split(&quot;:&quot;);</span><br><span class="line">            if(arr.length != 2)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(new HostAndPort(arr[0],Integer.parseInt(arr[1])));</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            jedisCluster = new JedisCluster(nodeSet,1000,7,jedisPoolConfig);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testDemo()&#123;</span><br><span class="line">        jedisCluster.set(&quot;k1&quot;,&quot;v1&quot;);</span><br><span class="line">        System.out.println(jedisCluster.get(&quot;k1&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    @After</span><br><span class="line">    public void destroy()&#123;</span><br><span class="line">        if (jedisCluster != null)&#123;</span><br><span class="line">            jedisCluster.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/20/Redis-Cluster(集群)/01.png&quot;&gt;
&lt;h3 id=&quot;Redis集群&quot;&gt;&lt;a href=&quot;#Redis集群&quot; class=&quot;headerlink&quot; title=&quot;Redis集群&quot;&gt;&lt;/a&gt;Redis集群&lt;/h3&gt;&lt;p&gt;为
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Sentinel(哨兵)</title>
    <link href="http://yoursite.com/2019/05/19/Redis-Sentinel(%E5%93%A8%E5%85%B5)/"/>
    <id>http://yoursite.com/2019/05/19/Redis-Sentinel(哨兵)/</id>
    <published>2019-05-19T10:29:57.000Z</published>
    <updated>2019-05-20T04:01:44.130Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/19/Redis-Sentinel(哨兵)/01.png"><h3 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h3><h4 id="手动故障的转移"><a href="#手动故障的转移" class="headerlink" title="手动故障的转移"></a>手动故障的转移</h4><img src="/2019/05/19/Redis-Sentinel(哨兵)/02.jpg"><p>假设master出现故障了，两个slave都出现了问题</p><p>这时候应该怎么解决呢？</p><ol><li><p>将上面的slave做一个slaveof no one的操作，将其变为独立的master</p></li><li><p>将客户端指向新的master</p></li><li>将下面的slave指向新的master</li></ol><img src="/2019/05/19/Redis-Sentinel(哨兵)/03.png"><p>这个过程实际操作起来还是比较麻烦的，虽然说我们是可以使用脚本来进行执行，但是，编写脚本的所需要的能力还是比较大，怎么判断redis节点出现问题，怎么通知客户端去重新指向等等的问题</p><h4 id="写能力和存储能力受限"><a href="#写能力和存储能力受限" class="headerlink" title="写能力和存储能力受限"></a>写能力和存储能力受限</h4><p>在主从复制的架构上，master节点负责写，slave节点负责读，即便有多个从节点，但这些从节点存储的数据也只是主节点的数据副本，实际上也就相当于数据只存储在主节点一台机器中</p><h3 id="Redis-Sentinel-架构"><a href="#Redis-Sentinel-架构" class="headerlink" title="Redis Sentinel 架构"></a>Redis Sentinel 架构</h3><img src="/2019/05/19/Redis-Sentinel(哨兵)/04.png"><p>首先，你可以把一个sentinel想象是一个redis的进程，不同的是sentinel不负责存储数据，它是负责对redis的一个故障判断、故障转移以及通知客户端的功能。另外，由上图可以看出sentinel不是一个而是多个，这样一来可以保证我们判断故障的一个公平性（后面可以设置几个sentinel认为节点有故障才算数），同时也保证了我们的高可用（即当一个sentinel节点挂了，仍然可以保证我们这个sentinel机制是完美的）。</p><p>​        那对客户端来说就再也不会直接从redis中获取信息，也就是说在我们客户端中不会记录redis的地址（某个IP），而是记录sentinel的地址，这样我们可以直接从sentinel获取的redis地址，因为sentinel会对所有的master、slave进行监控，它是知道到底谁才是真正的master的，例如我们故障转移，这时候对于sentinel来说，master是变了的，然后通知客户端。而客户端根本不用关心到底谁才是真正的master，只关心sentinel告知的master。</p><h3 id="Redis-Sentinel故障转移的步骤"><a href="#Redis-Sentinel故障转移的步骤" class="headerlink" title="Redis Sentinel故障转移的步骤"></a>Redis Sentinel故障转移的步骤</h3><ol><li><p>多个sentinel发现并确认master有问题。</p></li><li><p>选举出一个sentinel作为领导。（因为故障转移一系列操作只需要一个sentinel就可以完成）</p></li><li><p>从多个slave中选出一个slave作为新的master</p></li><li><p>通知其余slave成为新的master的slave</p></li><li><p>通知客户端主从变化（这样客户端就不会有读取失败的问题）</p></li><li><p>等待老的master复活成为新的master的slave（sentinel依然会对老的master进行监控是否复活）</p></li></ol><p>这里简单提一下：我们的一套sentinel是可以监听多套master+slave的组合，这样可以有效节省资源，其中每套master+slave会使用一个master-name作为一个标识。</p><h3 id="Redis-Sentinel演示"><a href="#Redis-Sentinel演示" class="headerlink" title="Redis Sentinel演示"></a>Redis Sentinel演示</h3><p>首先配置两个Redis，一主二从</p><p>主：port：8000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 8000</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-8000.pid</span><br><span class="line">logfile &quot;8000.log&quot;</span><br><span class="line">dir &quot;/redis/data&quot;</span><br></pre></td></tr></table></figure><p>从节点：port:8001和8002</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">port 8001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-8001.pid</span><br><span class="line">logfile &quot;8001.log&quot;</span><br><span class="line">dir &quot;/redis/data&quot;</span><br><span class="line">slaveof 127.0.0.1 8000</span><br><span class="line">-----------------------------------</span><br><span class="line">port 8002</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-8002.pid</span><br><span class="line">logfile &quot;8002.log&quot;</span><br><span class="line">dir &quot;/redis/data&quot;</span><br><span class="line">slaveof 127.0.0.1 8000</span><br></pre></td></tr></table></figure><p>启动redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server redis-8000.conf</span><br><span class="line">$ redis-server redis-8001.conf</span><br><span class="line">$ redis-server redis-8002.conf</span><br></pre></td></tr></table></figure><p>配置sentinel</p><img src="/2019/05/19/Redis-Sentinel(哨兵)/05.jpg"><p>先从redis文件夹下拷贝sentinel.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat sentinel.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot; &gt; redis-sentinel-26379.conf</span><br></pre></td></tr></table></figure><p>进行修改配置文件redis-sentinel-26379.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#端口号</span><br><span class="line">port 26379</span><br><span class="line">#以守护进程的方式启动</span><br><span class="line">daemonize yes</span><br><span class="line">#哨兵sentinel的工作目录</span><br><span class="line">dir /redis/data</span><br><span class="line">#日志文件名</span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line"># 监控名字为mymaster 的master 主机号为127.0.0.1 端口号为8000 当有两个sentinel认为这个master有问题就会执行相应的措施</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 8000 2</span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"># 故障转移的超时时间 failover-timeout</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><p>启动sentinel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-sentinel redis-sentinel-26379.conf</span><br></pre></td></tr></table></figure><p>再去查看一下配置文件</p><img src="/2019/05/19/Redis-Sentinel(哨兵)/06.png"><p>发生配置文件发生了改变，删除掉一些默认配置，而且加上了一些配置信息，比如从节点的信息（因为我们一开始指定主节点的时候，sentinel会获取主节点的信息，从而知道了slave的信息）</p><p>在创建两个sentinel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed &quot;s/26379/26380/g&quot; redis-sentinel-26379.conf &gt; redis-sentinel-26380.conf</span><br><span class="line">$ sed &quot;s/26379/26381/g&quot; redis-sentinel-26379.conf &gt; redis-sentinel-26381.conf</span><br><span class="line">#开启redis-sentinel</span><br><span class="line">$ redis-sentinel redis-sentinel-26380.conf</span><br><span class="line">$ redis-sentinel redis-sentinel-26381.conf</span><br></pre></td></tr></table></figure><p>可以查看redis-sentinel 26381的信息或者26382的信息都是可以发现sentinel的数量已经变成了3个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 26381 info sentinel</span><br></pre></td></tr></table></figure><img src="/2019/05/19/Redis-Sentinel(哨兵)/07.png"><h3 id="使用客户端观察"><a href="#使用客户端观察" class="headerlink" title="使用客户端观察"></a>使用客户端观察</h3><p>Java代码：</p><p>这里要注意一点，如果是本机则没事，如果是用虚拟机的朋友要把上面的127.0.0.1写成具体的虚拟机地址，比如我这里就是192.168.25.155，如果用的是Docker的朋友们，可以先commit然后再在启动的时候请使用–network=host（使用宿主机的IP地址）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class JedisSentinelPoolDemo &#123;</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(JedisSentinelPoolDemo.class);</span><br><span class="line">    private String masterName = &quot;mymaster&quot;;</span><br><span class="line">    private Set&lt;String&gt; sentine = new HashSet&lt;String&gt;();</span><br><span class="line">    private JedisSentinelPool jedisSentinelPool;</span><br><span class="line">    @Before</span><br><span class="line">    public void setup()&#123;</span><br><span class="line">        sentine.add(&quot;192.168.25.155:26379&quot;);</span><br><span class="line">        sentine.add(&quot;192.168.25.155:26380&quot;);</span><br><span class="line">        sentine.add(&quot;192.168.25.155:26381&quot;);</span><br><span class="line">        jedisSentinelPool = new JedisSentinelPool(masterName,sentine);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test01()&#123;</span><br><span class="line">        int counter = 0;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            counter++;</span><br><span class="line">            try(Jedis jedis = jedisSentinelPool.getResource())&#123;</span><br><span class="line">                int index =  new Random().nextInt(100000);</span><br><span class="line">                String key = &quot;k-&quot;+index;</span><br><span class="line">                String value = &quot;v-&quot;+index;</span><br><span class="line">                jedis.set(key,value);</span><br><span class="line">                if(counter % 100 == 0)&#123;</span><br><span class="line">                    logger.info(&quot;&#123;&#125; value is &#123;&#125;&quot;,key,jedis.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(10);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                logger.error(e.getMessage(),e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们的master是8000，如果停止掉master（模仿宕机）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redid-cli -p 8000 shutdown</span><br></pre></td></tr></table></figure><p>Java客户端会报错，稍等一会，会发现，日志继续输出？？？</p><p>这就是我们的Redis的Sentinel的机制</p><p>Sentinel会去检测Redis中的master是否故障，从而自动的将故障进行一个转移</p><p>这都是我们Sentinel去做的，省下了人工去操控的一个麻烦的过程</p><h3 id="Sentinel的三个定时任务"><a href="#Sentinel的三个定时任务" class="headerlink" title="Sentinel的三个定时任务"></a>Sentinel的三个定时任务</h3><ol><li>每十秒对每个sentinel对master和slave执行info，可以发现slave节点和确认主从节点的关系</li><li>每两秒每个sentinel通过master节点的channel交换信息</li><li>每一秒每个sentinel对其他sentinel和redis执行ping（心跳检测）</li></ol><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 节点多久没响应，就对这个节点做主观下线</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br></pre></td></tr></table></figure><p>主观下线和客观下线的区别在于，主观下线仅仅是依赖于单独的一个sentinel，而客观下线相当于，超过多少个quorum 都认为这个节点是下线了，那么，这个节点从客观的角度，就是下线了，此时就叫做客观下线</p><h3 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h3><p>只需要一个sentinel节点就可以完成故障的转移</p><ul><li>每个主观下线的Sentinel节点向其他Sentinel节点发送命令，要求将它设置为领导者</li><li>收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送的命令，那么将会同意该请求，否则拒绝</li><li>如果该Sentinel节点发现自己的票数已经超过Sentinel集合的半数而且超过quorum，那么将成为领导者</li><li>如果该过程有多个Sentinel节点成为了领导者，将进行一次重新选举</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis Sentinel是Redis的高可用实现方案：</p><ul><li>故障发现</li><li>故障自动转移</li><li>配置中心</li><li>客户端通知</li></ul><p><strong>Redis Sentinel从Redis2.8版本开始才正式生产使用，之前版本生产不可用</strong></p><p><strong>Redis Sentinel的Sentinel节点个数应该为奇数</strong></p><p><strong>Redis Sentinel节点不负责读写，负责监控，和管理节点</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/19/Redis-Sentinel(哨兵)/01.png&quot;&gt;
&lt;h3 id=&quot;主从复制的问题&quot;&gt;&lt;a href=&quot;#主从复制的问题&quot; class=&quot;headerlink&quot; title=&quot;主从复制的问题&quot;&gt;&lt;/a&gt;主从复制的问题&lt;/h3&gt;&lt;h4
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-主从复制</title>
    <link href="http://yoursite.com/2019/05/18/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/18/Redis-主从复制/</id>
    <published>2019-05-18T14:52:43.000Z</published>
    <updated>2019-05-19T05:46:03.691Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/18/Redis-主从复制/01.png"><h3 id="单机版的Redis"><a href="#单机版的Redis" class="headerlink" title="单机版的Redis"></a>单机版的Redis</h3><p>单机版的Redis能够支持十万的QPS（<em>QPS</em>是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准）</p><p>假设需要一百万怎么办？那就多台Redis实现集群</p><p>单机版的Redis，万一坏了，怎么办，数据没了怎么办？那就多台Redis进行数据的一个复制</p><p>所以有了Redis的主从复制的概念</p><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>主从复制可以理解为，一主多从或者一主一丛（一个主节点可以有多个从节点，一个从节点只能有一个主节点，数据流向是单向的，只能从master到slave）</p><p>可以做数据副本，也可以提高扩展读的性能</p><p>还可以做读写分离</p><h3 id="Redis主从复制的配置"><a href="#Redis主从复制的配置" class="headerlink" title="Redis主从复制的配置"></a>Redis主从复制的配置</h3><p>实现主从复制有以下两种方式</p><ul><li>slaveof命令</li><li>配置文件</li></ul><p>上demo，首先是用slaveof</p><p>先走一遍主节点的配置文件redis-6379.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line">dir /redis/data</span><br><span class="line">#关闭RDB的save配置</span><br></pre></td></tr></table></figure><p>再走一遍从节点的配置文件redis-6380.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">logfile &quot;6380.log&quot;</span><br><span class="line">dbfilename dump-6380.rdb</span><br><span class="line">dir /redis/data</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">#关闭RDB的save配置</span><br></pre></td></tr></table></figure><p>启动两个redis</p><p>先查看6379端口的redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ info replication</span><br></pre></td></tr></table></figure><img src="/2019/05/18/Redis-主从复制/02.png"><p>然后查看6380端口的redis</p><img src="/2019/05/18/Redis-主从复制/03.jpg"><p>根据上面的两个图，可以看到6379的redis是显示master也就是主节点</p><p>而6380的redis是现实slave也就是从节点</p><p>接下来是实例操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在6379端口的redis进行set</span><br><span class="line">$ set k1 v1</span><br><span class="line"># 在6380端口的redis进行get</span><br><span class="line">$ get k1</span><br></pre></td></tr></table></figure><p>会发现6380的redis是可以get到的</p><p>如果想将6380的redis变为单独的节点，也就是从节点的</p><p>可以动态修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ slaveof no one</span><br><span class="line">#再查看信息的分片，会发现，变成master节点了</span><br><span class="line">$ info replication</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>主从复制的时候，我们并没有开启RDB和AOP，但是为什么从节点能够把主节点的数据来进行一个记录呢？</p><p>这是因为主从复制的时候会自动触发RDB的产生，实质是主节点fork出一个子进程来进行数据的一个传输（相当于bgsave）</p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><img src="/2019/05/18/Redis-主从复制/04.jpg"><ol><li>内部使用psync ? -1 这个命令第一个参数是runId，第二个参数是偏移量，而由于是第一次复制，slave不知道master的runId，也不知道自己偏移量，这时候会传一个问号和-1，告诉master节点是第一次同步</li><li>当master接受到psync ？ -1 时，就知道slave是要全量复制，就会将自己的runID和offset告知slave</li><li>slave会将master信息保存</li><li>master这时会做一个RDB的生成（bgsave）</li><li>将RDB发送给slave</li><li>将复制缓冲区记录的操作也发送给slave</li><li>slave清空自己的所有老数据</li><li>slave这时就会加载RDB文件以及复制缓冲区数据，完成同步。</li></ol><h4 id="全量复制的开销"><a href="#全量复制的开销" class="headerlink" title="全量复制的开销"></a>全量复制的开销</h4><ol><li>bgsave的开销，每次bgsave需要fork子进程，对内存和CPU的开销很大</li><li>RDB文件网络传输的时间（网络带宽）</li><li>从节点清空数据的时间</li><li>从节点加载RDB的时间</li><li>可能的AOF重写时间（如果我们的从节点开启了AOF，则加载完RDB后会对AOF进行一个重写，保证AOF是最新的）</li></ol><h3 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>读写分离在数据库层面还是用得挺多的，大多数业务都是读多写少的场景，所以，进行读写分离，能够将读的流量分摊到别的节点中</p><p>当然也会存在一些问题：</p><ol><li>复制数据延迟（数据复制的延迟，当主节点发生阻塞的时候，会导致读写不一致）</li><li>读到过期的数据（主节点删除过期key的时候还没同步到从节点的时候，从节点会有很多脏数据）</li><li>从节点故障（从节点宕机之后，如何将访问这个节点的请求进行一个转移）</li></ol><h4 id="主从配置不一致"><a href="#主从配置不一致" class="headerlink" title="主从配置不一致"></a>主从配置不一致</h4><ol><li>mamemory不一致会导致丢失数据</li><li>数据结构优化参数的不一致，导致主从内存不一致</li></ol><h4 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h4><ol><li>第一次全量复制<ul><li>不可避免（但是可以减少危害，小主节点的情况下和在低峰值的情况下做第一次全量复制）</li></ul></li><li>节点运行ID不匹配（主节点重启，运行ID发生了变化）<ul><li>不可避免</li><li>可以使用故障转移的方式，当主节点发生故障的时候，从节点去接替当作主节点</li></ul></li><li>复制积压缓冲区不足（网络中断，部分复制无法满足）<ul><li>增大复制缓冲区配置rel_backlog_size</li></ul></li></ol><h4 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h4><ol><li>单主节点复制风暴（主节点重启，或者更换主节点的情况下，会进行大批量的全量复制）<ul><li>更换节点的拓扑图（没有一个完美的拓扑图，应该结合自己的实际场合来考虑）</li></ul></li><li>单机器的复制风暴（主节点所在的机器挂掉，换一个新的机器，也会进行大批量的全量复制）<ul><li>主节点分散多台机器上面</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/18/Redis-主从复制/01.png&quot;&gt;
&lt;h3 id=&quot;单机版的Redis&quot;&gt;&lt;a href=&quot;#单机版的Redis&quot; class=&quot;headerlink&quot; title=&quot;单机版的Redis&quot;&gt;&lt;/a&gt;单机版的Redis&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-持久化</title>
    <link href="http://yoursite.com/2019/05/17/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/17/Redis-持久化/</id>
    <published>2019-05-17T15:36:07.000Z</published>
    <updated>2019-08-05T14:55:38.381Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/17/Redis-持久化/01.png"><h3 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h3><p>redis所有数据都是保存在内存当中的，对数据的更新将保存到磁盘上，称之为数据的持久化</p><p>如果没有持久化，那断电，宕机，都会导致一个数据的缺失</p><h3 id="持久化的两种方式"><a href="#持久化的两种方式" class="headerlink" title="持久化的两种方式"></a>持久化的两种方式</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>Redis的数据是存储在内存当中的，RDB是通过快照的方式，将内存中的数据存储到硬盘当中的一个文件，这个文件就是RDB文件</p><h5 id="RDB的三种触发机制"><a href="#RDB的三种触发机制" class="headerlink" title="RDB的三种触发机制"></a>RDB的三种触发机制</h5><ul><li>save(同步)：占用的内存比较小，对性能开销没那么大，但是一旦数据比较多的时候，就会导致阻塞</li><li>bgsave(异步)：fork出子进程，子进程来进行一个save操作，不会导致阻塞，但是相对内存的消耗会比较大</li><li>自动</li><li>全量复制</li><li>debug reload</li></ul><p>在演示之前，我们需要对我们redis.conf配置文件来进行一个配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 以守护进程的方式启动</span><br><span class="line">daemonize yes</span><br><span class="line"># 当运行多个redis服务时，需要指定不同的pid文件和端口</span><br><span class="line">pidfile /var/run/redis:6379.pid</span><br><span class="line"># 以端口号为6379启动</span><br><span class="line">port 6379</span><br><span class="line"># 配置日志文件的存放位置</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line"># 存储至本地数据库时（持久化到rdb文件）是否压缩数据，默认为yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">#当bgsave执行失败的时候，是否停止redis的工作</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">#是否校验格式</span><br><span class="line">rdbchecksum yes</span><br><span class="line">#rdb文件名</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line"># 工作目录（按照自己的电脑进行一个配置）</span><br><span class="line">dir /redis/data</span><br></pre></td></tr></table></figure><h6 id="save（同步机制）"><a href="#save（同步机制）" class="headerlink" title="save（同步机制）"></a>save（同步机制）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#执行set方法</span><br><span class="line">$ set k1 v1</span><br><span class="line">#手动save保存</span><br><span class="line">$ save</span><br></pre></td></tr></table></figure><p>查看data目录下，会发现有一个文件dump6379.rdb</p><p>删除文件再进行下一个实验</p><h6 id="bgsave（异步机制）"><a href="#bgsave（异步机制）" class="headerlink" title="bgsave（异步机制）"></a>bgsave（异步机制）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#执行set方法</span><br><span class="line">$ set k1 v1</span><br><span class="line">#手动bgsave保存</span><br><span class="line">$ bgsave</span><br></pre></td></tr></table></figure><p>同样的，再data目录下，会发现有一个文件dump6379.rdb</p><p>删除文件再进行下一个实验</p><h6 id="自动（根据配置文件的配置）"><a href="#自动（根据配置文件的配置）" class="headerlink" title="自动（根据配置文件的配置）"></a>自动（根据配置文件的配置）</h6><p>我们查看一下redis.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 比如默认配置文件中的设置，就设置了三个条件</span><br><span class="line">#</span><br><span class="line"># save 900 1 900秒内至少有1个key被改变</span><br><span class="line"># save 300 10 300秒内至少有300个key被改变</span><br><span class="line"># save 60 10000 60秒内至少有10000个key被改变</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>我这里将值修改如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 10 1</span><br></pre></td></tr></table></figure><p>重启redis</p><p>redis-cli shutdown</p><p>redis-server redis.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#完成一次set</span><br><span class="line">$ set k1 v1</span><br></pre></td></tr></table></figure><p>同样的，再data目录下，会发现有一个文件dump6379.rdb</p><h6 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h6><p>全量复制的内容会在下一篇文章里描述，这里大致说一下，就是当有主从节点的情况下，从节点会复制主节点的数据，此时主节点会进行一个RDB的生成（与上述说的三种配置无关）</p><h6 id="debug-reload-和-shutdown"><a href="#debug-reload-和-shutdown" class="headerlink" title="debug reload 和 shutdown"></a>debug reload 和 shutdown</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在redis-cli模式下，以下两条命令都可以使redis发生持久化，生成RDB文件</span><br><span class="line">$ debug reload</span><br><span class="line">$ shutdown</span><br></pre></td></tr></table></figure><h5 id="RDB的问题"><a href="#RDB的问题" class="headerlink" title="RDB的问题"></a>RDB的问题</h5><h6 id="耗时，耗性能"><a href="#耗时，耗性能" class="headerlink" title="耗时，耗性能"></a>耗时，耗性能</h6><p>耗时，全部数据都要写入一个新的文件，O（N）</p><p>fork(),，数据量很大的情况下，写的时候会占用很大内存</p><p>硬盘的IO性能</p><h6 id="不可控，丢失数据"><a href="#不可控，丢失数据" class="headerlink" title="不可控，丢失数据"></a>不可控，丢失数据</h6><p>这是最最重要的问题，你耗时，我大不了久一点，你好性能，大不了就堆配置</p><p>丢数据可不行啊，这是最大的问题</p><p>为什么会丢数据呢？？？</p><p>save和bgsave都是要手动触发</p><p>而配置文件的自动生成rdb文件也是有间隔的，总会存在丢失数据的可能性</p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOP就解决了上述一个问题，AOP的原理是这样子的，我每次执行一个set k1 v1的时候就回去AOF文件中去进行一个记录，说白了就是一个日志功能，万一，我执行完set后宕机了，只需要把日志里的动作再做一遍就可以保证数据的恢复</p><h5 id="AOF的工作流程"><a href="#AOF的工作流程" class="headerlink" title="AOF的工作流程"></a>AOF的工作流程</h5><ol><li>命令写入:所有的写入命令会追加到aof_buf(缓冲区)中</li><li>文件同步:AOF缓冲区根据对应的策略向硬盘做同步操作</li><li>文件重写:随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩<br>的目的</li><li>重启加载:当Redis服务器重启时，可以加载AOF文件进行数据恢复</li></ol><img src="/2019/05/17/Redis-持久化/03.png"><h5 id="AOF的三种策略"><a href="#AOF的三种策略" class="headerlink" title="AOF的三种策略"></a>AOF的三种策略</h5><h6 id="always：每次都写进"><a href="#always：每次都写进" class="headerlink" title="always：每次都写进"></a>always：每次都写进</h6><h6 id="everysec：每一秒写进一次"><a href="#everysec：每一秒写进一次" class="headerlink" title="everysec：每一秒写进一次"></a>everysec：每一秒写进一次</h6><h6 id="no：根据操作系统决定"><a href="#no：根据操作系统决定" class="headerlink" title="no：根据操作系统决定"></a>no：根据操作系统决定</h6><p><strong>一般来说，折中考虑，会选择everysec，即可保证数据的丢失不会太大，也可以保证IO的开销会没那么大</strong></p><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>什么是AOF重写，举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ set k1 1</span><br><span class="line">$ incr k1</span><br><span class="line">$ incr k1</span><br></pre></td></tr></table></figure><p>AOF会记录三条命令，但是，其实三条命令可以简化成一条命令的，会大大减少我们的AOF的文件，大大加速我们恢复的速度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ set k1 3</span><br></pre></td></tr></table></figure><h5 id="AOF重写的两种方式"><a href="#AOF重写的两种方式" class="headerlink" title="AOF重写的两种方式"></a>AOF重写的两种方式</h5><ul><li>bgrewriteaof，会fork出一个子进程来进行AOF的重写</li><li>配置文件<ul><li>auto-aof-rewrite-min-size：AOF文件需要重写的大小是多少</li><li>auto-aof-rewrite-percentage：下一次重写距离这一次重写需要在文件提升多少的百分比的时候进行</li><li>aof_current_size：统计当前AOF的大小</li><li>aof_base_size：AOF上次启动和重写的尺寸</li></ul></li></ul><img src="/2019/05/17/Redis-持久化/02.jpg"><p><strong>上demo</strong></p><p>首先还是要修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#开启append only模式之后，redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件中</span><br><span class="line">appendonly yes</span><br><span class="line">#AOF的文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">#默认使用everysec策略</span><br><span class="line">appendfsync everysec</span><br><span class="line">#是否会在append的时候，由于请求过长，而阻止</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">#默认的aof的最小文件大小，以及增长率</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">#当aof文件出错的时候，重启的时候是否忽略错误</span><br><span class="line">aof-load truncated yes</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 插入两条数据</span><br><span class="line">$ set k1 v1</span><br><span class="line">$ set k2 v2</span><br></pre></td></tr></table></figure><p>去data目录下会发现有aof的文件生成</p><p>把文件删除掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 手动生成AOF文件</span><br><span class="line">$ bgrewriteaof</span><br></pre></td></tr></table></figure><p>可以看到也是有AOF文件生成的</p><h4 id="RDB与AOF的区别"><a href="#RDB与AOF的区别" class="headerlink" title="RDB与AOF的区别"></a>RDB与AOF的区别</h4><table><thead><tr><th>命令</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table><h5 id="RDB的选择"><a href="#RDB的选择" class="headerlink" title="RDB的选择"></a>RDB的选择</h5><ul><li>在单机操作大多数情况下，建议关闭</li><li>当数据恢复的量级比较大的情况下建议开启</li><li>在集群的情况下，建议从节点开</li></ul><h5 id="AOF的最佳选择"><a href="#AOF的最佳选择" class="headerlink" title="AOF的最佳选择"></a>AOF的最佳选择</h5><ul><li>在单机大多数操作情况下，建议开启</li><li>AOF重写集中管理（防止Redis自动做重写操作而导致fork太多引起的内存不足等问题）</li><li>建议使用everysec策略</li></ul><h5 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h5><p>AOF和RDB文件都可以用于服务器重启时的数据恢复</p><img src="/2019/05/17/Redis-持久化/04.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/17/Redis-持久化/01.png&quot;&gt;
&lt;h3 id=&quot;什么是持久化&quot;&gt;&lt;a href=&quot;#什么是持久化&quot; class=&quot;headerlink&quot; title=&quot;什么是持久化&quot;&gt;&lt;/a&gt;什么是持久化&lt;/h3&gt;&lt;p&gt;redis所有数据都是保存
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂方法</title>
    <link href="http://yoursite.com/2019/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/05/14/设计模式-工厂方法/</id>
    <published>2019-05-14T09:34:58.000Z</published>
    <updated>2019-05-14T08:02:50.154Z</updated>
    
    <content type="html"><![CDATA[<p>首先在介绍工厂方法之前，先介绍一个新的概念，简单工厂</p><p><strong>简单工厂不是一种设计模式</strong></p><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><ul><li>由一个工厂对象来决定创建出哪一种产品类的示例</li><li>工厂类负责适合创建的对象比较少的场景</li><li>应用层只用传入工厂类的参数，对于如何创建，不关心创建对象的细节</li><li>工厂类的职责较重，因为所有对象创建都由工厂类，万一工厂类出了问题，会影响很大</li></ul><p>先上Demo,比如我这里是一个玩具厂，生产的玩具有蜘蛛侠和钢铁侠吧,不用简单工厂模式的设计下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义一个玩具抽象类</span><br><span class="line"> */</span><br><span class="line">abstract class AbstractToy &#123;</span><br><span class="line">    public abstract void produce();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 蜘蛛侠</span><br><span class="line"> */</span><br><span class="line">class SpiderManToy extends Toy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;我是蜘蛛侠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 钢铁侠</span><br><span class="line"> */</span><br><span class="line">class IronManToy extends Toy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;我是钢铁侠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class TestDemo&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Toy toy = new IronManToy();</span><br><span class="line">        toy.produce();</span><br><span class="line">        toy = new SpiderManToy();</span><br><span class="line">        toy.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面存在一个什么问题呢？</p><p>现在我们只有两个玩具而已，如果是三个，四个呢？不断添加一个类来继承我们的抽象类吗？然后不断自己new一个类，这就是高耦合，实现类你要自己编写，业务层你又要自己编写，太麻烦了，看下面示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 玩具工厂类</span><br><span class="line"> */</span><br><span class="line">class ToyFactory&#123;</span><br><span class="line">    public static Toy getToy(String name)&#123;</span><br><span class="line">        if(&quot;IronMan&quot;.equalsIgnoreCase(name))&#123;</span><br><span class="line">            return new IronManToy();</span><br><span class="line">        &#125;else if(&quot;SpiderMan&quot;.equalsIgnoreCase(name))&#123;</span><br><span class="line">            return new SpiderManToy();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Toy toy = ToyFactory.getToy(&quot;IronMan&quot;);</span><br><span class="line">        toy.produce();</span><br><span class="line">        toy = ToyFactory.getToy(&quot;spiderman&quot;);</span><br><span class="line">        toy.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，将实现类和业务逻辑代码去分开了，业务层只需要去传参数，就可以获取到对应的实现类，如何获取到的细节可以完全不用管理，减少了实业务层和实现层的耦合度，可以分开两个人去对这两个模块进行一个单独的管理，也不会出现问题，业务层只需要传参，工厂那边负责对参数的接收和返回具体的一个实现类以及实现类的编写</p><p>以上，业务层已经很好了，但是工厂那一块我们是用了if…else…if这种方法特别不好，写工厂的人，还是和一开始一样，既要自己new具体的实现类，又要编写工厂类，其实本质还是没有发生改变，只是从业务层的麻烦移到工厂上了而已，以上就是我们的简单工厂的做法，所以说，为什么简单工厂只能适合少部分的实例的创建，就是因为一旦管理较多类的情况下，就会导致代码很冗余</p><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><ul><li>定义一个创建对象的接口，<strong>让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行</strong></li><li>适用于创建对象需要大量重复代码的时候</li><li>应用层不依赖于产品类的实现细节</li><li>一个类通过其子类来指定创建哪个对象</li></ul><p>重点再说一次：<strong>让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义一个玩具抽象类</span><br><span class="line"> */</span><br><span class="line">abstract class Toy &#123;</span><br><span class="line">    public abstract void produce();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 蜘蛛侠</span><br><span class="line"> */</span><br><span class="line">class SpiderManToy extends Toy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;我是蜘蛛侠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 钢铁侠</span><br><span class="line"> */</span><br><span class="line">class IronManToy extends Toy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;我是钢铁侠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 玩具工厂类</span><br><span class="line"> */</span><br><span class="line">abstract class ToyFactory &#123;</span><br><span class="line">    public abstract Toy getToy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 蜘蛛侠工厂</span><br><span class="line"> */</span><br><span class="line">class SpiderManToyFactory extends ToyFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Toy getToy() &#123;</span><br><span class="line">        return new SpiderManToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 钢铁侠工厂</span><br><span class="line"> */</span><br><span class="line">class IronManToyFactory extends ToyFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Toy getToy() &#123;</span><br><span class="line">        return new IronManToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ToyFactory toyFactory = new SpiderManToyFactory();</span><br><span class="line">        Toy toy = toyFactory.getToy();</span><br><span class="line">        toy.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里上一个类图：</p><img src="/2019/05/14/设计模式-工厂方法/01.png"><p>一共包含三个大角色，产品，工厂，调用者</p><p>其中产品里包含了具体的产品实现</p><p>工厂里包含了具体的工厂用来创建具体的产品</p><h4 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 玩具工厂类</span><br><span class="line"> */</span><br><span class="line">class ToyFactory&#123;</span><br><span class="line"></span><br><span class="line">    public static Toy getToy(Class c) &#123;</span><br><span class="line">        AbstractToy toy = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            toy = (Toy) Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return toy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class TestDemo&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Toy toy = ToyFactory.getToy(IronManToy.class);</span><br><span class="line">        toy.produce();</span><br><span class="line">        toy = ToyFactory.getToy(SpiderManToy.class);</span><br><span class="line">        toy.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我使用了反射来解决了在业务层只需要传参数而不用关心其实例创建过程的细节，而每次添加新的类的时候，也不需要修改到工厂类的代码</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里讲了三种方法，最后进行一个总结</p><p>其中，简单工厂适合实例少的场景，优点是简单，易懂，缺点是违反了开闭原则</p><p>工厂方法，有点是，适用实例多的场景，遵循开闭原则，缺点是，比较繁琐</p><p>使用简单工厂配合反射，可以解决开闭原则的问题，缺点是使用反射会使程序的效率降低</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先在介绍工厂方法之前，先介绍一个新的概念，简单工厂&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单工厂不是一种设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; class=&quot;headerlink&quot; title=&quot;简单工厂&quot;&gt;&lt;/a&gt;简单工
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker-本地镜像发布到阿里云</title>
    <link href="http://yoursite.com/2019/05/11/Docker-%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    <id>http://yoursite.com/2019/05/11/Docker-本地镜像发布到阿里云/</id>
    <published>2019-05-10T19:48:47.000Z</published>
    <updated>2019-05-10T12:59:45.344Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/11/Docker-本地镜像发布到阿里云/01.jpg"><p>前面讲到了DockerFile</p><p>DockerFile是什么来的呢？这里重温一下，DockerFile就是用来构建我们的Docker镜像文件</p><p>为什么要学DockerFile?因为拉取的镜像往往功能比较单一，我们有时候会需要根据不同的业务来对我们的虚拟机进行一些定制，这时候就有两种方法可选，一种是DockerFile，一种是执行docker commit,其中DockerFile的灵活性更加高但同时也带有一定的学习难度</p><p>本次主要讲解的是<strong>本地镜像发布到阿里云</strong></p><p>为什么要这么做呢？</p><p>这和我们的代码需要被管理是一个道理，而且，好的东西，开源，不也挺好的吗</p><h4 id="本地镜像发布到阿里云的流程"><a href="#本地镜像发布到阿里云的流程" class="headerlink" title="本地镜像发布到阿里云的流程"></a>本地镜像发布到阿里云的流程</h4><img src="/2019/05/11/Docker-本地镜像发布到阿里云/02.jpg"><p>图片看上去很复杂，这里大致解释一下，首先找到一个没有被指向的地方开始看，入口就是DockerFile了，DockerFile build之后成为一个镜像，Docker跑起来就是一个容器，还有两个，一个是阿里云，一个是私有云，说白了就是，你推上去的这个镜像，希不希望让别人能够看到的意思</p><h4 id="镜像的生成方法"><a href="#镜像的生成方法" class="headerlink" title="镜像的生成方法"></a>镜像的生成方法</h4><ol><li>DockerFile</li><li>docker commit</li></ol><h4 id="将本地镜像推送到阿里云"><a href="#将本地镜像推送到阿里云" class="headerlink" title="将本地镜像推送到阿里云"></a>将本地镜像推送到阿里云</h4><p>首先进入阿里云控制台创建一个镜像仓库用来存放镜像，代码源我这里选择的是本地仓库</p><img src="/2019/05/11/Docker-本地镜像发布到阿里云/03.jpg"><p>点击管理进入</p><img src="/2019/05/11/Docker-本地镜像发布到阿里云/04.jpg"><p>找到 3. 将镜像推送到Registry</p><img src="/2019/05/11/Docker-本地镜像发布到阿里云/05.png"><img src="/2019/05/11/Docker-本地镜像发布到阿里云/06.png"><img src="/2019/05/11/Docker-本地镜像发布到阿里云/07.png"><p>接下来就可以在自己仓库里面可以看到自己push后的镜像</p><h4 id="将阿里云的镜像拉取到本地"><a href="#将阿里云的镜像拉取到本地" class="headerlink" title="将阿里云的镜像拉取到本地"></a>将阿里云的镜像拉取到本地</h4><p>直接docker push 自己的镜像</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里涉及到的三条命令</p><ol><li>用docker登陆阿里云</li><li>用docker push到阿里云</li><li>用docker pull从阿里云拉取到本地 </li></ol><p>这里三条的命令都可以在我的仓库管理里面可以清楚查看，也不用过多的解释</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/11/Docker-本地镜像发布到阿里云/01.jpg&quot;&gt;
&lt;p&gt;前面讲到了DockerFile&lt;/p&gt;
&lt;p&gt;DockerFile是什么来的呢？这里重温一下，DockerFile就是用来构建我们的Docker镜像文件&lt;/p&gt;
&lt;p&gt;为什么要
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-原型</title>
    <link href="http://yoursite.com/2019/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/05/05/设计模式-原型/</id>
    <published>2019-05-05T08:23:10.000Z</published>
    <updated>2019-05-05T02:39:46.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型设计模式"><a href="#原型设计模式" class="headerlink" title="原型设计模式"></a>原型设计模式</h3><p>什么是原型设计模式呢？可以根据我们的名字来推测就是，首先要有个原型，然后根据原型不断来产生新的东西</p><h4 id="普通的一个例子"><a href="#普通的一个例子" class="headerlink" title="普通的一个例子"></a>普通的一个例子</h4><p>看以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Demo&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">class Use&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Demo&gt; list = new ArrayList&lt;Demo&gt;(); </span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            list.add(new Demo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码，逻辑上没什么问题，就是new了100个Demo的实例嘛</p><p>但是</p><p>我这里new了100次啊，100次啊！！！</p><p>太浪费了CPU内存了，结合我们对单例模式的了解，我们可不可以写成单例？肯定可以啊，但是单例获取的只是一个实例，假设我的业务需求真的需要100个呢？难道真的没办法只能new 100次了吗？？</p><h4 id="原型登场"><a href="#原型登场" class="headerlink" title="原型登场"></a>原型登场</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Demo implements Cloneable&#123;</span><br><span class="line">    private static Demo demo = new Demo();</span><br><span class="line">    //禁止实例化</span><br><span class="line">    private Demo()&#123;&#125;;</span><br><span class="line">    //唯一接口获取实例</span><br><span class="line">    public static Demo getDemo() throws CloneNotSupportedException&#123;</span><br><span class="line">        return demo.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    //重写clone方法</span><br><span class="line">    @Override</span><br><span class="line">    protected Demo clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return (Demo)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Use&#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        List&lt;Demo&gt; list = new ArrayList&lt;Demo&gt;(); </span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            list.add(Demo.getDemo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里，原型设计模式核心思想是用到了克隆，克隆这个方法其实就是进行了一个内存块的复制，在创建对象成本较大，如初始化占用较长时间、占用大量cpu资源等，新的对象可以通过原型对象复制产生新的对象。</strong></p><p>因为我们的原型设计模式设计到内存块的复制，这里就会产生两个问题</p><ul><li>浅复制</li><li>深复制</li></ul><p>了解对象和引用的区别的朋友都知道，如果单纯拷贝一个内存块，是完全不够的，为什么呢？因为引用！所以上述例子是实现不了引用类型的拷贝</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>看以下例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Demo implements Cloneable &#123;</span><br><span class="line">private static Demo demo = new Demo();</span><br><span class="line">public A a = new A();</span><br><span class="line"></span><br><span class="line">// 禁止实例化</span><br><span class="line">private Demo() &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 唯一接口获取实例</span><br><span class="line">public static Demo getDemo() throws CloneNotSupportedException &#123;</span><br><span class="line">return demo.clone();</span><br><span class="line">&#125;</span><br><span class="line">// 重写clone方法</span><br><span class="line">@Override</span><br><span class="line">protected Demo clone() throws CloneNotSupportedException &#123;</span><br><span class="line">return (Demo) super.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Use &#123;</span><br><span class="line">public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">Demo demo1 = Demo.getDemo();</span><br><span class="line">Demo demo2 = Demo.getDemo();</span><br><span class="line">System.out.println(&quot;demo1:&quot; + demo1);</span><br><span class="line">System.out.println(&quot;demo2:&quot; + demo2);</span><br><span class="line">System.out.println(&quot;demo1:&quot; + demo1.a);</span><br><span class="line">System.out.println(&quot;demo2:&quot; + demo2.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">demo1:demo02.Demo@15db9742</span><br><span class="line">demo2:demo02.Demo@6d06d69c</span><br><span class="line">demo1:demo02.A@7852e922</span><br><span class="line">demo2:demo02.A@7852e922</span><br></pre></td></tr></table></figure><p>出现了一个结果：Object的地址是一样的，说明这里的object是同一个对象，没有实现到拷贝，这就是所谓的浅拷贝，这里上一幅图以供理解</p><img src="/2019/05/05/设计模式-原型/01.jpg"><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class A implements Cloneable&#123;</span><br><span class="line">@Override</span><br><span class="line">protected A clone() throws CloneNotSupportedException &#123;</span><br><span class="line">return (A)super.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Demo implements Cloneable &#123;</span><br><span class="line">private static Demo demo = new Demo();</span><br><span class="line">public A a = new A();</span><br><span class="line"></span><br><span class="line">// 禁止实例化</span><br><span class="line">private Demo() &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 唯一接口获取实例</span><br><span class="line">public static Demo getDemo() throws CloneNotSupportedException &#123;</span><br><span class="line">Demo temp = demo.clone();</span><br><span class="line">temp.setA(temp.a.clone());</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">private void setA(A a) &#123;</span><br><span class="line">this.a = a;</span><br><span class="line">&#125;</span><br><span class="line">// 重写clone方法</span><br><span class="line">@Override</span><br><span class="line">protected Demo clone() throws CloneNotSupportedException &#123;</span><br><span class="line">return (Demo) super.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Use &#123;</span><br><span class="line">public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">Demo demo1 = Demo.getDemo();</span><br><span class="line">Demo demo2 = Demo.getDemo();</span><br><span class="line">System.out.println(&quot;demo1:&quot; + demo1);</span><br><span class="line">System.out.println(&quot;demo2:&quot; + demo2);</span><br><span class="line">System.out.println(&quot;demo1:&quot; + demo1.a);</span><br><span class="line">System.out.println(&quot;demo2:&quot; + demo2.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">demo1:demo02.Demo@15db9742</span><br><span class="line">demo2:demo02.Demo@6d06d69c</span><br><span class="line">demo1:demo02.A@7852e922</span><br><span class="line">demo2:demo02.A@4e25154f</span><br></pre></td></tr></table></figure><h4 id="原型设计模式的优缺点"><a href="#原型设计模式的优缺点" class="headerlink" title="原型设计模式的优缺点"></a>原型设计模式的优缺点</h4><p><strong>优点</strong></p><ul><li>如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li><li>可以使用深克隆保持对象的状态</li><li>原型模式提供了简化的创建结构</li></ul><p><strong>缺点</strong></p><ul><li>在实现深克隆的时候可能需要比较复杂的代码。</li><li>需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原型设计模式&quot;&gt;&lt;a href=&quot;#原型设计模式&quot; class=&quot;headerlink&quot; title=&quot;原型设计模式&quot;&gt;&lt;/a&gt;原型设计模式&lt;/h3&gt;&lt;p&gt;什么是原型设计模式呢？可以根据我们的名字来推测就是，首先要有个原型，然后根据原型不断来产生新的东西&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker---Docker容器数据卷</title>
    <link href="http://yoursite.com/2019/04/29/Docker-Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
    <id>http://yoursite.com/2019/04/29/Docker-Docker容器数据卷/</id>
    <published>2019-04-29T13:41:52.000Z</published>
    <updated>2019-05-10T08:08:33.737Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/04/29/Docker-Docker容器数据卷/01.jpg"><h3 id="Docker数据卷"><a href="#Docker数据卷" class="headerlink" title="Docker数据卷"></a>Docker数据卷</h3><p>使用Docker的时候，我们明白我们跑的都是一个个容器，比如Tomcat，Mysql，Redis等等，既然如此，必须有个东西—–》<strong>数据</strong></p><p>数据我怎么做一个持久化呢？怎么获取呢？容器奔了我数据就没了吗？</p><p>这时候就有数据卷的诞生</p><p><strong>数据卷</strong>：一个存放数据的东西，在Docker当中叫做数据卷，可以理解为磁盘，持久存放</p><p><strong>数据卷容器</strong>：那就是可以理解为存放硬盘的容器，可以理解为移动硬盘</p><p><strong>说白点呢，数据是存放在数据卷当中，但是当多个数据卷要进行交互的时候，就需要一个容器来包揽住这些数据卷，这个容器就叫做数据卷容器</strong></p><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><h4 id="使用-v指令来进行挂载数据卷"><a href="#使用-v指令来进行挂载数据卷" class="headerlink" title="使用-v指令来进行挂载数据卷"></a>使用-v指令来进行挂载数据卷</h4><p>挂载数据卷就是将本机的某个数据卷（某个文件夹）与容器内共享</p><p>docker run -v 宿主机的路径:容器内的路径 镜像名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在根目录下创建个文件夹</span><br><span class="line">$ cd /</span><br><span class="line">$ mkdir Doroot</span><br><span class="line">执行命令</span><br><span class="line">$ docker run -it -v /Doroot:/aaaa --privileged=true centos</span><br></pre></td></tr></table></figure><p><strong>注意一下一定要加 –privileged=true 否则容器内部会没有权限</strong></p><img src="/2019/04/29/Docker-Docker容器数据卷/02.jpg"><p><strong>这样子在容器内就能获取到我们宿主机上的数据了，注意一点，此时修改宿主机或者容器内部的数据卷里的文件，都会受到影响，简单来说就是宿主机和容器内布共享数据卷里面的文件</strong></p><h4 id="使用DockerFile来添加数据卷"><a href="#使用DockerFile来添加数据卷" class="headerlink" title="使用DockerFile来添加数据卷"></a>使用DockerFile来添加数据卷</h4><p>以下代码就在容器内挂载了/BBBB，没有指明对应的宿主机位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;/BBBB&quot;]</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>然后docker build建立镜像</p><img src="/2019/04/29/Docker-Docker容器数据卷/03.jpg"><p>查看一下容器内挂载的与宿主机对应的位置在哪</p><img src="/2019/04/29/Docker-Docker容器数据卷/04.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;b3b394fac32e2e263e360de210b36665d03554425d23fe23ad8ebc54aa304716&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/b3b394fac32e2e263e360de210b36665d03554425d23fe23ad8ebc54aa304716/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/BBBB&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><p>/BBBB对应的宿主机位置为</p><p>/var/lib/docker/volumes/</p><p>b3b394fac32e2e263e360de210b36665d03554425d23fe23ad8ebc54aa304716/_data</p><p>因为我们也说过宿主机和容器内布，是共享的，我们可以亲自去测试一下，这里我就不演示了(如果要测试，记得加上特权模式 –privileged =true，否则会报没权限错误)</p><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p><strong>建立一个容器挂载数据卷，其他容器通过挂载这个容器（父容器）来实现数据共享，挂载数据卷的容器就是数据卷容器</strong></p><p>容器之间传递共享 –volumes-from</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//先创建一个父容器，挂载宿主机</span><br><span class="line">$ docker run -it -v /Doroot:/aaaa --name d01  --privileged=true centos</span><br><span class="line">//退出容器</span><br><span class="line">$ ctrl + P + Q</span><br><span class="line">//创建一个子容器</span><br><span class="line">$docker run -it --name d02 --volumes-from dc01 --privileged=true centos</span><br></pre></td></tr></table></figure><p>此时d02的centos也挂载了容器卷，实现了容器卷的一个传递</p><p><strong>此时数据共享，改变任意一个容器的数据卷信息，另外的容器都会受到影响</strong></p><img src="/2019/04/29/Docker-Docker容器数据卷/05.jpg"><p>总结一下数据卷容器，总结之前先抛出几个问题</p><ol><li>d01删除后 d02还有吗？   —-有</li><li>d01删除后,新建d03继承d02，d03有吗？ —有</li><li>d03继承d01后，删除d01,d02和d03可以共享吗？ —可以</li></ol><p><strong>结论：容器之间的配置信息的传递，数据卷的生命周期一直持续到没有容器使用为止</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/04/29/Docker-Docker容器数据卷/01.jpg&quot;&gt;
&lt;h3 id=&quot;Docker数据卷&quot;&gt;&lt;a href=&quot;#Docker数据卷&quot; class=&quot;headerlink&quot; title=&quot;Docker数据卷&quot;&gt;&lt;/a&gt;Docker数据卷
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-DockerFile</title>
    <link href="http://yoursite.com/2019/04/29/Docker-DockerFile/"/>
    <id>http://yoursite.com/2019/04/29/Docker-DockerFile/</id>
    <published>2019-04-29T12:16:38.000Z</published>
    <updated>2019-05-10T11:50:25.158Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/04/29/Docker-DockerFile/01.jpg"><h4 id="Docker深入"><a href="#Docker深入" class="headerlink" title="Docker深入"></a>Docker深入</h4><p>前面讲解了Docker的基本概念以及Docker的安装，还简单跑了一个例子，相信能够对Docker有一个大致的了解</p><p>本章将对Docker进一步的探索</p><h4 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h4><p>DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p><p>DockerFile就是用来构建Docker镜像的，现在DockerHub上面有很多镜像，但是有时候我们会根据需求来自定义镜像，（比如说我们要改造Centos）常用两种方法：</p><ol><li>我们在DockerHub上面拉取一个镜像下来，然后进入容器里面进行修改，接着进行docker commit（形成新的一个镜像）</li><li>我们自己编写DockerFile文件，因为所有镜像本质都是DockerFile，编写完自己构建出一个镜像</li></ol><p><strong>DockerFile和 docker commit 的区别：</strong></p><p>DockerFile更加灵活，我可以随时根据需求来更改我的文件而docker commit，不具备重复性，什么意思呢，就是说，在DockerFile我不要一个东西，只是删除一行就好了（因为这是构建文件，我把某一块去掉就可以了），但是如果用docker commit就不行了，你安装了好些东西，要删除可能得一个个卸载，而且有时候你想要回复到之前某个点的，就非常困难了，所以：<strong>构建镜像不推荐docker commit,请使用DockerFile</strong></p><p>构建DockerFile三步骤</p><ul><li>编写DockerFile文件</li><li>docker build</li><li>docker run</li></ul><p><strong>写一个例子吧：</strong></p><p>新建一个DockerFile文件编写以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">From centos</span><br><span class="line">ENV mypath /tmp</span><br><span class="line">WORKDIR $mypath</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>执行docker build命令</p><p>我这里遇到过一个小问题，很多也遇到了，就是build的时候报错</p><p>docker build -f 文件所在的位置 -t 名字：版本号 .</p><p>如果文件在当前目录下可以省略-f</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f /dockerFile/DockerFile -t mycentos:2.2 .</span><br></pre></td></tr></table></figure><p><strong>重要的事情说三遍</strong></p><p><strong>最后面有小数点！！！</strong></p><p><strong>最后面有小数点！！！</strong></p><p><strong>最后面有小数点！！！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//不加小数点报错：</span><br><span class="line">$ &quot;docker build&quot; requires exactly 1 argument(s).</span><br><span class="line">//没启动docker报错：</span><br><span class="line">$ Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><img src="/2019/04/29/Docker-DockerFile/02.jpg"><p>可以看到当前的目录是tmp，因为我构建镜像的时候就设置了WORKDIR</p><p>简单的例子讲完了：</p><p>现在看看常用的构建文件命令：</p><ol><li>FROM 基础镜像，当前镜像是基于哪个镜像，可以想象成类与类之间的继承关系</li><li>MAINTAINER，镜像的维护者的姓名和邮箱地址</li><li>RUN，容器构建时需要运行的命令</li><li>EXPOSE，当前容器对外暴露出的端口</li><li>WORKDIR，指定创建容器后，终端默认登陆进来的工作目录</li><li>ENV，用来构建镜像过程中设置环境变量</li><li>ADD，将宿主机的目录下的文件拷贝到镜像里面并且ADD命令会自动处理URL和解压tar</li><li>COPY，类似ADD，拷贝文件和目录到镜像中。&lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</li><li>VOLUME，容器数据卷，用于保存和持久化工作</li><li>CND，指定一个容器启动时要运行的命令，DockerFile中可以有多个CMD指令，但只有最后一个生效，会被docker run 后面的参数给覆盖</li><li>ENTRYPOINT，和CMD一样是指定一个容器启动时要运行的命令，区别在于不会被覆盖，都能执行</li><li>ONBUILD，当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</li></ol><p><strong>这个可能就需要多做才能熟悉其命令了</strong></p><p>比如说我们拉取的Centos都是比较纯净的</p><p>怎么说呢，什么东西都没有装就对了</p><p>比如下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 继承自centos，在centos基础上安装vim</span><br><span class="line">From centos</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>最后写一个命令稍微复杂一点的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#继承原生Tomcat</span><br><span class="line">FROM centos</span><br><span class="line">#设置作者和邮箱</span><br><span class="line">MAINTAINER ymbcxb&lt;353560278@qq.com&gt;</span><br><span class="line">#把宿主机当前上下文的c.txt拷贝到容器/usr/local中</span><br><span class="line">COPY c.txt /usr/local/cincontainer.txt</span><br><span class="line">#把java与tomcat添加到容器中</span><br><span class="line">ADD apache-tomcat-9.0.17.tar.gz  /usr/local/</span><br><span class="line">ADD jdk-8u201-linux-x64.tar.gz /usr/local/</span><br><span class="line">#安装VIM编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#设置工作访问时候的落脚点</span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">#配置Java与Tomcat的环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_201</span><br><span class="line">ENV CLASSPATH JAVA_HOME/lib/dt.jar:JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.17</span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.17</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line">#容器运行时监听的端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line">#启动时运行tomcat用ENTRYPOINT 和 CMD都可以</span><br><span class="line">#ENTRYPOINT [&quot;/usr/local/apache-tomcat-9.0.17/bin/startup.sh&quot;]</span><br><span class="line">#CMD [&quot;/usr/local/apache-tomcat-9.0.17/bin/startup.sh&quot;,&quot;run&quot;]</span><br><span class="line">#启动tomcat并且打印日志</span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.17/bin/startup.sh &amp;&amp; tail - F /usr/local/apache-tomcat-9.0.17/bin/logs/catalina.out</span><br></pre></td></tr></table></figure><p><strong>温馨提示：记得将对应的Jar包和Tomcat的包和c.txt放到当前目录下</strong></p><img src="/2019/04/29/Docker-DockerFile/03.jpg"><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -p 9080:8080 -d mytomcat:1.0</span><br></pre></td></tr></table></figure><p>然后在浏览器输入对应的网址就可以看到Tomcat的页面，LinuxIp:9080 </p><p>执行以下命令进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it cotainerId /bin/bash</span><br></pre></td></tr></table></figure><img src="/2019/04/29/Docker-DockerFile/03.png"><p>查看到是存在cincontainer.txt</p><p>总结：</p><p>关于命令的学习，还是需要多琢磨琢磨，比如你可以手写一个Centos（安装了openssh）这样子，下次你需要用虚拟机的时候只用开启多一个容器，就够了就可以进行SSH连接来玩，玩坏了不过删容器而已，比传统的下载一个虚拟机镜像要方便多了，大大大大大地提高学习效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/04/29/Docker-DockerFile/01.jpg&quot;&gt;
&lt;h4 id=&quot;Docker深入&quot;&gt;&lt;a href=&quot;#Docker深入&quot; class=&quot;headerlink&quot; title=&quot;Docker深入&quot;&gt;&lt;/a&gt;Docker深入&lt;/h4&gt;
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
</feed>
