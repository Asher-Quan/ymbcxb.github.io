<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小Q博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-25T05:51:02.731Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ymbcxb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis-Cluster(集群)</title>
    <link href="http://yoursite.com/2019/05/20/Redis-Cluster(%E9%9B%86%E7%BE%A4)/"/>
    <id>http://yoursite.com/2019/05/20/Redis-Cluster(集群)/</id>
    <published>2019-05-20T12:03:44.000Z</published>
    <updated>2019-05-25T05:51:02.731Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/20/Redis-Cluster(集群)/01.png"><h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>为什么要引入Redis集群</p><p>单机会造成什么问题，官方说法：单机Redis支持十万的并发量，如果我需要二十万呢？三十万呢？这时候就要用到Redis集群，撇开Redis集群不说，集群，就是用来分担单机的压力，无论是访问的压力，查询的压力还是流量的压力，为什么通常都要使用集群来解决呢？比如电脑内存不够往往会想着买一条内存条，但是还不够呢？一台电脑不断加装，成本越来越贵，很不划算，当成本大于我重新买一台电脑的时候，我当然选择两台电脑就是这个意思，更何况通常集群都是上百台呢</p><h3 id="RedisCluster的安装"><a href="#RedisCluster的安装" class="headerlink" title="RedisCluster的安装"></a>RedisCluster的安装</h3><h4 id="原生安装"><a href="#原生安装" class="headerlink" title="原生安装"></a>原生安装</h4><h5 id="配置节点"><a href="#配置节点" class="headerlink" title="配置节点"></a>配置节点</h5><p>启动6个redis，配置的端口从7000-7005，以下是配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/redis/data&quot;</span><br><span class="line">logfile &quot;7000.log&quot;</span><br><span class="line">dbfilename &quot;dump-7000.rdb&quot;</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line">cluster-require-full-coverage no</span><br></pre></td></tr></table></figure><img src="/2019/05/20/Redis-Cluster(集群)/02.png"><h5 id="配置meet"><a href="#配置meet" class="headerlink" title="配置meet"></a>配置meet</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster meet 127.0.0.1 7001</span><br><span class="line">$ redis-cli -p 7000 cluster meet 127.0.0.1 7002</span><br><span class="line">$ redis-cli -p 7000 cluster meet 127.0.0.1 7003</span><br><span class="line">$ redis-cli -p 7000 cluster meet 127.0.0.1 7004</span><br><span class="line">$ redis-cli -p 7000 cluster meet 127.0.0.1 7005</span><br></pre></td></tr></table></figure><h4 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h4><p>编写一个脚本addslots.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start=$1</span><br><span class="line">end=$2</span><br><span class="line">port=$3</span><br><span class="line">for slot in `seq $&#123;start&#125; $&#123;end&#125;`</span><br><span class="line">do</span><br><span class="line">    redis-cli -p $&#123;port&#125; cluster addslots $&#123;slot&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>分配槽给节点，这里我有六个redis，但是我只分配将槽分成三份，另外三份来用做slave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sh addslots.sh 0 5461 7000</span><br><span class="line">$ sh addslots.sh 5462 10922 7001</span><br><span class="line">$ sh addslots.sh 10923 16383 7002</span><br></pre></td></tr></table></figure><img src="/2019/05/20/Redis-Cluster(集群)/03.png"><h4 id="主从分配"><a href="#主从分配" class="headerlink" title="主从分配"></a>主从分配</h4><p>上面将槽分配给了7000，7001，7002，将其对应的slave是7003，7004，7005</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#replicate后面接对应节点的id号，id号可以看我上面那张图，一一对应的，在redis-cli下通过cluster nodes可以查询</span><br><span class="line">$ redis-cli -p 7003 cluster replicate 84b0e3f7ba4d7a709d8b25fe4844b66296af71d8</span><br><span class="line">$ redis-cli -p 7004 cluster replicate 6b17f1a9bb7ee845c1d8c012c2805df76fb9b943</span><br><span class="line">$ redis-cli -p 7005 cluster replicate e32dd59b6b1205ca88050e2124c40ba37200a674</span><br></pre></td></tr></table></figure><img src="/2019/05/20/Redis-Cluster(集群)/04.png"><p>安装结束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000</span><br><span class="line">$ set k1 v1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>可以进入redis-cli后能够进行set操作了</p><h4 id="官方工具安装"><a href="#官方工具安装" class="headerlink" title="官方工具安装"></a>官方工具安装</h4><p>首先按照步骤按照一下官方工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://cache.ruby-lang.org/pub/ruby/2.6/ruby-2.6.3.tar.gz</span><br><span class="line">cd ruby-2.6.3</span><br><span class="line">./configure -prefix=/usr/local/ruby</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">wget http://rubygems.org/downloads/redis-3.3.0.gem</span><br><span class="line">gem install -l redis-3.3.0.gem</span><br><span class="line">gem list -- check redis gem</span><br></pre></td></tr></table></figure><p>然后和上面一样，跑六个节点，全部启动起来</p><p>8000-8005端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 8005</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/redis/data&quot;</span><br><span class="line">logfile &quot;8005.log&quot;</span><br><span class="line">dbfilename &quot;dump-8005.rdb&quot;</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-8005.conf</span><br><span class="line">cluster-require-full-coverage no</span><br></pre></td></tr></table></figure><p>进入redis下的src目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /redis/src</span><br><span class="line">#使用工具来创建集群,其中数量1代表一个主节点配置1个从节点</span><br><span class="line">$ ./redis-trib.rb create --replicas 1 127.0.0.1:8000 127.0.0.1:8001 127.0.0.1:8002 127.0.0.1:8003 127.0.0.1:8004 127.0.0.1:8005</span><br></pre></td></tr></table></figure><img src="/2019/05/20/Redis-Cluster(集群)/05.jpg"><p>对上面没问题可以输入yes</p><p>可以通过以下命令，查看集群是否搭建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 8000 cluster nodes</span><br><span class="line">$ redis-cli -p 8000 cluster info</span><br></pre></td></tr></table></figure><h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><ol><li><p>启动两个独立的redis，其中8006和8007是独立的</p><img src="/2019/05/20/Redis-Cluster(集群)/06.png"></li><li><p>将集群种的节点对独立的节点进行meet操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 8000 cluster meet 127.0.0.1 8006</span><br><span class="line">$ redis-cli -p 8000 cluster meet 127.0.0.1 8007</span><br></pre></td></tr></table></figure></li><li><p>主从的分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 8006 cluster replicate 8007的runId</span><br></pre></td></tr></table></figure></li><li><p>分配槽，使用redis-trib的工具</p><p>进入 src目录下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:8000</span><br></pre></td></tr></table></figure></li></ol><p>分配完成</p><img src="/2019/05/20/Redis-Cluster(集群)/08.jpg"><h3 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h3><p>./redis-trib.rb reshard – from 不要的节点的runId –to 分配的节点的runId –slots 多少个槽 1366 让哪个端口去执行<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard --from 9334fcdbc2453637e86f1b6664a8c86413eb87d4 --to d576410d1da0cd11f29035550ef0eaf81a811ea7 --slots 1366 127.0.0.1:8007</span><br></pre></td></tr></table></figure><p>按照这个方法可以把槽分配给其他节点</p><p>把所有槽都分配完成后，可以去删除节点</p><p>./redis-trib.rb del-node 分配一个Ip地址:端口 运行的runId</p><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb del-node 127.0.0.1:8000 9334fcdbc2453637e86f1b6664a8c86413eb87d4</span><br></pre></td></tr></table></figure><img src="/2019/05/20/Redis-Cluster(集群)/09.jpg"><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>首先简单讲一下ASK重定向和Moved重定向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入redis-cli</span><br><span class="line">$ redis-cli -p 8000</span><br><span class="line">$ set k1 v1</span><br><span class="line">(error) MOVED 12706 192.168.25.155:8002</span><br></pre></td></tr></table></figure><p>这个就是MOVED异常</p><p>什么意思呢？就是说，当你要设置一个key的时候，如果当前这个key的hash值计算出来的槽不在当前节点，就会报错，错误会告诉你应该去哪个节点里面进行一个set操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入集群下的redis-cli</span><br><span class="line">$ redis-cli -c -p 8000</span><br><span class="line">$ set k1 v1</span><br><span class="line">-&gt; Redirected to slot [12706] located at 192.168.25.155:8002</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>这就是Moved重定向，会自动帮我们进行一个重定向到8002端口的Redis然后进行一个set操作</p><p>接下来讲讲ASK重定向</p><p>什么是ASK重定向呢？</p><p>ask异常是在槽的迁移过程才会发生的</p><p>什么意思呢，比如访问k1这个槽的节点的时候，节点报ASK异常，说明这个k1当前在我这个节点，但k1这个槽即将迁移到新的节点当中，ask的重定向会返回一个迁移到的目标节点的信息</p><img src="/2019/05/20/Redis-Cluster(集群)/10.png"><p>Smart客户端,会识别ask异常和moved异常来进行一个对节点的切换</p><p>JavaDemo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class JedisClusterDemo &#123;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(JedisClusterDemo.class);</span><br><span class="line">    private Set&lt;HostAndPort&gt; nodeSet = new HashSet&lt;&gt;();</span><br><span class="line">    private JedisCluster jedisCluster = null;</span><br><span class="line">    private List&lt;String&gt; hostPortList = new ArrayList&lt;&gt;();</span><br><span class="line">    @Before</span><br><span class="line">    public void setup()&#123;</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8000&quot;);</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8001&quot;);</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8002&quot;);</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8003&quot;);</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8004&quot;);</span><br><span class="line">        hostPortList.add(&quot;192.168.25.155:8005&quot;);</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();</span><br><span class="line">        for(String hostPort : hostPortList)&#123;</span><br><span class="line">            String[] arr = hostPort.split(&quot;:&quot;);</span><br><span class="line">            if(arr.length != 2)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(new HostAndPort(arr[0],Integer.parseInt(arr[1])));</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            jedisCluster = new JedisCluster(nodeSet,1000,7,jedisPoolConfig);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testDemo()&#123;</span><br><span class="line">        jedisCluster.set(&quot;k1&quot;,&quot;v1&quot;);</span><br><span class="line">        System.out.println(jedisCluster.get(&quot;k1&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    @After</span><br><span class="line">    public void destroy()&#123;</span><br><span class="line">        if (jedisCluster != null)&#123;</span><br><span class="line">            jedisCluster.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/20/Redis-Cluster(集群)/01.png&quot;&gt;
&lt;h3 id=&quot;Redis集群&quot;&gt;&lt;a href=&quot;#Redis集群&quot; class=&quot;headerlink&quot; title=&quot;Redis集群&quot;&gt;&lt;/a&gt;Redis集群&lt;/h3&gt;&lt;p&gt;为
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Sentinel(哨兵)</title>
    <link href="http://yoursite.com/2019/05/19/Redis-Sentinel(%E5%93%A8%E5%85%B5)/"/>
    <id>http://yoursite.com/2019/05/19/Redis-Sentinel(哨兵)/</id>
    <published>2019-05-19T10:29:57.000Z</published>
    <updated>2019-05-20T04:01:44.130Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/19/Redis-Sentinel(哨兵)/01.png"><h3 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h3><h4 id="手动故障的转移"><a href="#手动故障的转移" class="headerlink" title="手动故障的转移"></a>手动故障的转移</h4><img src="/2019/05/19/Redis-Sentinel(哨兵)/02.jpg"><p>假设master出现故障了，两个slave都出现了问题</p><p>这时候应该怎么解决呢？</p><ol><li><p>将上面的slave做一个slaveof no one的操作，将其变为独立的master</p></li><li><p>将客户端指向新的master</p></li><li>将下面的slave指向新的master</li></ol><img src="/2019/05/19/Redis-Sentinel(哨兵)/03.png"><p>这个过程实际操作起来还是比较麻烦的，虽然说我们是可以使用脚本来进行执行，但是，编写脚本的所需要的能力还是比较大，怎么判断redis节点出现问题，怎么通知客户端去重新指向等等的问题</p><h4 id="写能力和存储能力受限"><a href="#写能力和存储能力受限" class="headerlink" title="写能力和存储能力受限"></a>写能力和存储能力受限</h4><p>在主从复制的架构上，master节点负责写，slave节点负责读，即便有多个从节点，但这些从节点存储的数据也只是主节点的数据副本，实际上也就相当于数据只存储在主节点一台机器中</p><h3 id="Redis-Sentinel-架构"><a href="#Redis-Sentinel-架构" class="headerlink" title="Redis Sentinel 架构"></a>Redis Sentinel 架构</h3><img src="/2019/05/19/Redis-Sentinel(哨兵)/04.png"><p>首先，你可以把一个sentinel想象是一个redis的进程，不同的是sentinel不负责存储数据，它是负责对redis的一个故障判断、故障转移以及通知客户端的功能。另外，由上图可以看出sentinel不是一个而是多个，这样一来可以保证我们判断故障的一个公平性（后面可以设置几个sentinel认为节点有故障才算数），同时也保证了我们的高可用（即当一个sentinel节点挂了，仍然可以保证我们这个sentinel机制是完美的）。</p><p>​        那对客户端来说就再也不会直接从redis中获取信息，也就是说在我们客户端中不会记录redis的地址（某个IP），而是记录sentinel的地址，这样我们可以直接从sentinel获取的redis地址，因为sentinel会对所有的master、slave进行监控，它是知道到底谁才是真正的master的，例如我们故障转移，这时候对于sentinel来说，master是变了的，然后通知客户端。而客户端根本不用关心到底谁才是真正的master，只关心sentinel告知的master。</p><h3 id="Redis-Sentinel故障转移的步骤"><a href="#Redis-Sentinel故障转移的步骤" class="headerlink" title="Redis Sentinel故障转移的步骤"></a>Redis Sentinel故障转移的步骤</h3><ol><li><p>多个sentinel发现并确认master有问题。</p></li><li><p>选举出一个sentinel作为领导。（因为故障转移一系列操作只需要一个sentinel就可以完成）</p></li><li><p>从多个slave中选出一个slave作为新的master</p></li><li><p>通知其余slave成为新的master的slave</p></li><li><p>通知客户端主从变化（这样客户端就不会有读取失败的问题）</p></li><li><p>等待老的master复活成为新的master的slave（sentinel依然会对老的master进行监控是否复活）</p></li></ol><p>这里简单提一下：我们的一套sentinel是可以监听多套master+slave的组合，这样可以有效节省资源，其中每套master+slave会使用一个master-name作为一个标识。</p><h3 id="Redis-Sentinel演示"><a href="#Redis-Sentinel演示" class="headerlink" title="Redis Sentinel演示"></a>Redis Sentinel演示</h3><p>首先配置两个Redis，一主二从</p><p>主：port：8000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 8000</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-8000.pid</span><br><span class="line">logfile &quot;8000.log&quot;</span><br><span class="line">dir &quot;/redis/data&quot;</span><br></pre></td></tr></table></figure><p>从节点：port:8001和8002</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">port 8001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-8001.pid</span><br><span class="line">logfile &quot;8001.log&quot;</span><br><span class="line">dir &quot;/redis/data&quot;</span><br><span class="line">slaveof 127.0.0.1 8000</span><br><span class="line">-----------------------------------</span><br><span class="line">port 8002</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-8002.pid</span><br><span class="line">logfile &quot;8002.log&quot;</span><br><span class="line">dir &quot;/redis/data&quot;</span><br><span class="line">slaveof 127.0.0.1 8000</span><br></pre></td></tr></table></figure><p>启动redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server redis-8000.conf</span><br><span class="line">$ redis-server redis-8001.conf</span><br><span class="line">$ redis-server redis-8002.conf</span><br></pre></td></tr></table></figure><p>配置sentinel</p><img src="/2019/05/19/Redis-Sentinel(哨兵)/05.jpg"><p>先从redis文件夹下拷贝sentinel.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat sentinel.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot; &gt; redis-sentinel-26379.conf</span><br></pre></td></tr></table></figure><p>进行修改配置文件redis-sentinel-26379.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#端口号</span><br><span class="line">port 26379</span><br><span class="line">#以守护进程的方式启动</span><br><span class="line">daemonize yes</span><br><span class="line">#哨兵sentinel的工作目录</span><br><span class="line">dir /redis/data</span><br><span class="line">#日志文件名</span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line"># 监控名字为mymaster 的master 主机号为127.0.0.1 端口号为8000 当有两个sentinel认为这个master有问题就会执行相应的措施</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 8000 2</span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"># 故障转移的超时时间 failover-timeout</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><p>启动sentinel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-sentinel redis-sentinel-26379.conf</span><br></pre></td></tr></table></figure><p>再去查看一下配置文件</p><img src="/2019/05/19/Redis-Sentinel(哨兵)/06.png"><p>发生配置文件发生了改变，删除掉一些默认配置，而且加上了一些配置信息，比如从节点的信息（因为我们一开始指定主节点的时候，sentinel会获取主节点的信息，从而知道了slave的信息）</p><p>在创建两个sentinel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed &quot;s/26379/26380/g&quot; redis-sentinel-26379.conf &gt; redis-sentinel-26380.conf</span><br><span class="line">$ sed &quot;s/26379/26381/g&quot; redis-sentinel-26379.conf &gt; redis-sentinel-26381.conf</span><br><span class="line">#开启redis-sentinel</span><br><span class="line">$ redis-sentinel redis-sentinel-26380.conf</span><br><span class="line">$ redis-sentinel redis-sentinel-26381.conf</span><br></pre></td></tr></table></figure><p>可以查看redis-sentinel 26381的信息或者26382的信息都是可以发现sentinel的数量已经变成了3个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 26381 info sentinel</span><br></pre></td></tr></table></figure><img src="/2019/05/19/Redis-Sentinel(哨兵)/07.png"><h3 id="使用客户端观察"><a href="#使用客户端观察" class="headerlink" title="使用客户端观察"></a>使用客户端观察</h3><p>Java代码：</p><p>这里要注意一点，如果是本机则没事，如果是用虚拟机的朋友要把上面的127.0.0.1写成具体的虚拟机地址，比如我这里就是192.168.25.155，如果用的是Docker的朋友们，可以先commit然后再在启动的时候请使用–network=host（使用宿主机的IP地址）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class JedisSentinelPoolDemo &#123;</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(JedisSentinelPoolDemo.class);</span><br><span class="line">    private String masterName = &quot;mymaster&quot;;</span><br><span class="line">    private Set&lt;String&gt; sentine = new HashSet&lt;String&gt;();</span><br><span class="line">    private JedisSentinelPool jedisSentinelPool;</span><br><span class="line">    @Before</span><br><span class="line">    public void setup()&#123;</span><br><span class="line">        sentine.add(&quot;192.168.25.155:26379&quot;);</span><br><span class="line">        sentine.add(&quot;192.168.25.155:26380&quot;);</span><br><span class="line">        sentine.add(&quot;192.168.25.155:26381&quot;);</span><br><span class="line">        jedisSentinelPool = new JedisSentinelPool(masterName,sentine);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test01()&#123;</span><br><span class="line">        int counter = 0;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            counter++;</span><br><span class="line">            try(Jedis jedis = jedisSentinelPool.getResource())&#123;</span><br><span class="line">                int index =  new Random().nextInt(100000);</span><br><span class="line">                String key = &quot;k-&quot;+index;</span><br><span class="line">                String value = &quot;v-&quot;+index;</span><br><span class="line">                jedis.set(key,value);</span><br><span class="line">                if(counter % 100 == 0)&#123;</span><br><span class="line">                    logger.info(&quot;&#123;&#125; value is &#123;&#125;&quot;,key,jedis.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(10);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                logger.error(e.getMessage(),e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们的master是8000，如果停止掉master（模仿宕机）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redid-cli -p 8000 shutdown</span><br></pre></td></tr></table></figure><p>Java客户端会报错，稍等一会，会发现，日志继续输出？？？</p><p>这就是我们的Redis的Sentinel的机制</p><p>Sentinel会去检测Redis中的master是否故障，从而自动的将故障进行一个转移</p><p>这都是我们Sentinel去做的，省下了人工去操控的一个麻烦的过程</p><h3 id="Sentinel的三个定时任务"><a href="#Sentinel的三个定时任务" class="headerlink" title="Sentinel的三个定时任务"></a>Sentinel的三个定时任务</h3><ol><li>每十秒对每个sentinel对master和slave执行info，可以发现slave节点和确认主从节点的关系</li><li>每两秒每个sentinel通过master节点的channel交换信息</li><li>每一秒每个sentinel对其他sentinel和redis执行ping（心跳检测）</li></ol><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 节点多久没响应，就对这个节点做主观下线</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br></pre></td></tr></table></figure><p>主观下线和客观下线的区别在于，主观下线仅仅是依赖于单独的一个sentinel，而客观下线相当于，超过多少个quorum 都认为这个节点是下线了，那么，这个节点从客观的角度，就是下线了，此时就叫做客观下线</p><h3 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h3><p>只需要一个sentinel节点就可以完成故障的转移</p><ul><li>每个主观下线的Sentinel节点向其他Sentinel节点发送命令，要求将它设置为领导者</li><li>收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送的命令，那么将会同意该请求，否则拒绝</li><li>如果该Sentinel节点发现自己的票数已经超过Sentinel集合的半数而且超过quorum，那么将成为领导者</li><li>如果该过程有多个Sentinel节点成为了领导者，将进行一次重新选举</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis Sentinel是Redis的高可用实现方案：</p><ul><li>故障发现</li><li>故障自动转移</li><li>配置中心</li><li>客户端通知</li></ul><p><strong>Redis Sentinel从Redis2.8版本开始才正式生产使用，之前版本生产不可用</strong></p><p><strong>Redis Sentinel的Sentinel节点个数应该为奇数</strong></p><p><strong>Redis Sentinel节点不负责读写，负责监控，和管理节点</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/19/Redis-Sentinel(哨兵)/01.png&quot;&gt;
&lt;h3 id=&quot;主从复制的问题&quot;&gt;&lt;a href=&quot;#主从复制的问题&quot; class=&quot;headerlink&quot; title=&quot;主从复制的问题&quot;&gt;&lt;/a&gt;主从复制的问题&lt;/h3&gt;&lt;h4
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-主从复制</title>
    <link href="http://yoursite.com/2019/05/18/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/18/Redis-主从复制/</id>
    <published>2019-05-18T14:52:43.000Z</published>
    <updated>2019-05-19T05:46:03.691Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/18/Redis-主从复制/01.png"><h3 id="单机版的Redis"><a href="#单机版的Redis" class="headerlink" title="单机版的Redis"></a>单机版的Redis</h3><p>单机版的Redis能够支持十万的QPS（<em>QPS</em>是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准）</p><p>假设需要一百万怎么办？那就多台Redis实现集群</p><p>单机版的Redis，万一坏了，怎么办，数据没了怎么办？那就多台Redis进行数据的一个复制</p><p>所以有了Redis的主从复制的概念</p><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>主从复制可以理解为，一主多从或者一主一丛（一个主节点可以有多个从节点，一个从节点只能有一个主节点，数据流向是单向的，只能从master到slave）</p><p>可以做数据副本，也可以提高扩展读的性能</p><p>还可以做读写分离</p><h3 id="Redis主从复制的配置"><a href="#Redis主从复制的配置" class="headerlink" title="Redis主从复制的配置"></a>Redis主从复制的配置</h3><p>实现主从复制有以下两种方式</p><ul><li>slaveof命令</li><li>配置文件</li></ul><p>上demo，首先是用slaveof</p><p>先走一遍主节点的配置文件redis-6379.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line">dir /redis/data</span><br><span class="line">#关闭RDB的save配置</span><br></pre></td></tr></table></figure><p>再走一遍从节点的配置文件redis-6380.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">logfile &quot;6380.log&quot;</span><br><span class="line">dbfilename dump-6380.rdb</span><br><span class="line">dir /redis/data</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">#关闭RDB的save配置</span><br></pre></td></tr></table></figure><p>启动两个redis</p><p>先查看6379端口的redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ info replication</span><br></pre></td></tr></table></figure><img src="/2019/05/18/Redis-主从复制/02.png"><p>然后查看6380端口的redis</p><img src="/2019/05/18/Redis-主从复制/03.jpg"><p>根据上面的两个图，可以看到6379的redis是显示master也就是主节点</p><p>而6380的redis是现实slave也就是从节点</p><p>接下来是实例操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在6379端口的redis进行set</span><br><span class="line">$ set k1 v1</span><br><span class="line"># 在6380端口的redis进行get</span><br><span class="line">$ get k1</span><br></pre></td></tr></table></figure><p>会发现6380的redis是可以get到的</p><p>如果想将6380的redis变为单独的节点，也就是从节点的</p><p>可以动态修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ slaveof no one</span><br><span class="line">#再查看信息的分片，会发现，变成master节点了</span><br><span class="line">$ info replication</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>主从复制的时候，我们并没有开启RDB和AOP，但是为什么从节点能够把主节点的数据来进行一个记录呢？</p><p>这是因为主从复制的时候会自动触发RDB的产生，实质是主节点fork出一个子进程来进行数据的一个传输（相当于bgsave）</p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><img src="/2019/05/18/Redis-主从复制/04.jpg"><ol><li>内部使用psync ? -1 这个命令第一个参数是runId，第二个参数是偏移量，而由于是第一次复制，slave不知道master的runId，也不知道自己偏移量，这时候会传一个问号和-1，告诉master节点是第一次同步</li><li>当master接受到psync ？ -1 时，就知道slave是要全量复制，就会将自己的runID和offset告知slave</li><li>slave会将master信息保存</li><li>master这时会做一个RDB的生成（bgsave）</li><li>将RDB发送给slave</li><li>将复制缓冲区记录的操作也发送给slave</li><li>slave清空自己的所有老数据</li><li>slave这时就会加载RDB文件以及复制缓冲区数据，完成同步。</li></ol><h4 id="全量复制的开销"><a href="#全量复制的开销" class="headerlink" title="全量复制的开销"></a>全量复制的开销</h4><ol><li>bgsave的开销，每次bgsave需要fork子进程，对内存和CPU的开销很大</li><li>RDB文件网络传输的时间（网络带宽）</li><li>从节点清空数据的时间</li><li>从节点加载RDB的时间</li><li>可能的AOF重写时间（如果我们的从节点开启了AOF，则加载完RDB后会对AOF进行一个重写，保证AOF是最新的）</li></ol><h3 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>读写分离在数据库层面还是用得挺多的，大多数业务都是读多写少的场景，所以，进行读写分离，能够将读的流量分摊到别的节点中</p><p>当然也会存在一些问题：</p><ol><li>复制数据延迟（数据复制的延迟，当主节点发生阻塞的时候，会导致读写不一致）</li><li>读到过期的数据（主节点删除过期key的时候还没同步到从节点的时候，从节点会有很多脏数据）</li><li>从节点故障（从节点宕机之后，如何将访问这个节点的请求进行一个转移）</li></ol><h4 id="主从配置不一致"><a href="#主从配置不一致" class="headerlink" title="主从配置不一致"></a>主从配置不一致</h4><ol><li>mamemory不一致会导致丢失数据</li><li>数据结构优化参数的不一致，导致主从内存不一致</li></ol><h4 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h4><ol><li>第一次全量复制<ul><li>不可避免（但是可以减少危害，小主节点的情况下和在低峰值的情况下做第一次全量复制）</li></ul></li><li>节点运行ID不匹配（主节点重启，运行ID发生了变化）<ul><li>不可避免</li><li>可以使用故障转移的方式，当主节点发生故障的时候，从节点去接替当作主节点</li></ul></li><li>复制积压缓冲区不足（网络中断，部分复制无法满足）<ul><li>增大复制缓冲区配置rel_backlog_size</li></ul></li></ol><h4 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h4><ol><li>单主节点复制风暴（主节点重启，或者更换主节点的情况下，会进行大批量的全量复制）<ul><li>更换节点的拓扑图（没有一个完美的拓扑图，应该结合自己的实际场合来考虑）</li></ul></li><li>单机器的复制风暴（主节点所在的机器挂掉，换一个新的机器，也会进行大批量的全量复制）<ul><li>主节点分散多台机器上面</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/18/Redis-主从复制/01.png&quot;&gt;
&lt;h3 id=&quot;单机版的Redis&quot;&gt;&lt;a href=&quot;#单机版的Redis&quot; class=&quot;headerlink&quot; title=&quot;单机版的Redis&quot;&gt;&lt;/a&gt;单机版的Redis&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-持久化</title>
    <link href="http://yoursite.com/2019/05/17/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/17/Redis-持久化/</id>
    <published>2019-05-17T15:36:07.000Z</published>
    <updated>2019-05-19T02:23:59.160Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/17/Redis-持久化/01.png"><h3 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h3><p>redis所有数据都是保存在内存当中的，对数据的更新将保存到磁盘上，称之为数据的持久化</p><p>如果没有持久化，那断电，宕机，都会导致一个数据的缺失</p><h3 id="持久化的两种方式"><a href="#持久化的两种方式" class="headerlink" title="持久化的两种方式"></a>持久化的两种方式</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>Redis的数据是存储在内存当中的，RDB是通过快照的方式，将内存中的数据存储到硬盘当中的一个文件，这个文件就是RDB文件</p><h5 id="RDB的三种触发机制"><a href="#RDB的三种触发机制" class="headerlink" title="RDB的三种触发机制"></a>RDB的三种触发机制</h5><ul><li>save(同步)：占用的内存比较小，对性能开销没那么大，但是一旦数据比较多的时候，就会导致阻塞</li><li>bgsave(异步)：fork出子进程，子进程来进行一个save操作，不会导致阻塞，但是相对内存的消耗会比较大</li><li>自动</li><li>全量复制</li><li>debug reload</li></ul><p>在演示之前，我们需要对我们redis.conf配置文件来进行一个配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 以守护进程的方式启动</span><br><span class="line">daemonize yes</span><br><span class="line"># 当运行多个redis服务时，需要指定不同的pid文件和端口</span><br><span class="line">pidfile /var/run/redis:6379.pid</span><br><span class="line"># 以端口号为6379启动</span><br><span class="line">port 6379</span><br><span class="line"># 配置日志文件的存放位置</span><br><span class="line">logfile = &quot;6379.log&quot;</span><br><span class="line"># 存储至本地数据库时（持久化到rdb文件）是否压缩数据，默认为yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">#当bgsave执行失败的时候，是否停止redis的工作</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">#是否校验格式</span><br><span class="line">rdbchecksum yes</span><br><span class="line">#rdb文件名</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line"># 工作目录（按照自己的电脑进行一个配置）</span><br><span class="line">dir /redis/data</span><br></pre></td></tr></table></figure><h6 id="save（同步机制）"><a href="#save（同步机制）" class="headerlink" title="save（同步机制）"></a>save（同步机制）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#执行set方法</span><br><span class="line">$ set k1 v1</span><br><span class="line">#手动save保存</span><br><span class="line">$ save</span><br></pre></td></tr></table></figure><p>查看data目录下，会发现有一个文件dump6379.rdb</p><p>删除文件再进行下一个实验</p><h6 id="bgsave（异步机制）"><a href="#bgsave（异步机制）" class="headerlink" title="bgsave（异步机制）"></a>bgsave（异步机制）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#执行set方法</span><br><span class="line">$ set k1 v1</span><br><span class="line">#手动bgsave保存</span><br><span class="line">$ save</span><br></pre></td></tr></table></figure><p>同样的，再data目录下，会发现有一个文件dump6379.rdb</p><p>删除文件再进行下一个实验</p><h6 id="自动（根据配置文件的配置）"><a href="#自动（根据配置文件的配置）" class="headerlink" title="自动（根据配置文件的配置）"></a>自动（根据配置文件的配置）</h6><p>我们查看一下redis.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 比如默认配置文件中的设置，就设置了三个条件</span><br><span class="line">#</span><br><span class="line"># save 900 1 900秒内至少有1个key被改变</span><br><span class="line"># save 300 10 300秒内至少有300个key被改变</span><br><span class="line"># save 60 10000 60秒内至少有10000个key被改变</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>我这里将值修改如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 10 1</span><br></pre></td></tr></table></figure><p>重启redis</p><p>redis-cli shutdown</p><p>redis-server redis.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#完成一次set</span><br><span class="line">$ set k1 v1</span><br></pre></td></tr></table></figure><p>同样的，再data目录下，会发现有一个文件dump6379.rdb</p><h6 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h6><p>全量复制的内容会在下一篇文章里描述，这里大致说一下，就是当有主从节点的情况下，从节点会复制主节点的数据，此时主节点会进行一个RDB的生成（与上述说的三种配置无关）</p><h6 id="debug-reload-和-shutdown"><a href="#debug-reload-和-shutdown" class="headerlink" title="debug reload 和 shutdown"></a>debug reload 和 shutdown</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在redis-cli模式下，以下两条命令都可以使redis发生持久化，生成RDB文件</span><br><span class="line">$ debug reload</span><br><span class="line">$ shutdown</span><br></pre></td></tr></table></figure><h5 id="RDB的问题"><a href="#RDB的问题" class="headerlink" title="RDB的问题"></a>RDB的问题</h5><h6 id="耗时，耗性能"><a href="#耗时，耗性能" class="headerlink" title="耗时，耗性能"></a>耗时，耗性能</h6><p>耗时，全部数据都要写入一个新的文件，O（N）</p><p>fork(),，数据量很大的情况下，写的时候会占用很大内存</p><p>硬盘的IO性能</p><h6 id="不可控，丢失数据"><a href="#不可控，丢失数据" class="headerlink" title="不可控，丢失数据"></a>不可控，丢失数据</h6><p>这是最最重要的问题，你耗时，我大不了久一点，你好性能，大不了就堆配置</p><p>丢数据可不行啊，这是最大的问题</p><p>为什么会丢数据呢？？？</p><p>save和bgsave都是要手动触发</p><p>而配置文件的自动生成rdb文件也是有间隔的，总会存在丢失数据的可能性</p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOP就解决了上述一个问题，AOP的原理是这样子的，我每次执行一个set k1 v1的时候就回去AOF文件中去进行一个记录，说白了就是一个日志功能，万一，我执行完set后宕机了，只需要把日志里的动作再做一遍就可以保证数据的恢复</p><p>首先AOF是先将命令写入缓冲区，然后再把缓冲区写进AOF文件</p><h5 id="AOF的三种策略"><a href="#AOF的三种策略" class="headerlink" title="AOF的三种策略"></a>AOF的三种策略</h5><h6 id="always：每次都写进"><a href="#always：每次都写进" class="headerlink" title="always：每次都写进"></a>always：每次都写进</h6><h6 id="everysec：每一秒写进一次"><a href="#everysec：每一秒写进一次" class="headerlink" title="everysec：每一秒写进一次"></a>everysec：每一秒写进一次</h6><h6 id="no：根据操作系统决定"><a href="#no：根据操作系统决定" class="headerlink" title="no：根据操作系统决定"></a>no：根据操作系统决定</h6><p><strong>一般来说，折中考虑，会选择everysec，即可保证数据的丢失不会太大，也可以保证IO的开销会没那么大</strong></p><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>什么是AOF重写，举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ set k1 1</span><br><span class="line">$ incr k1</span><br><span class="line">$ incr k1</span><br></pre></td></tr></table></figure><p>AOF会记录三条命令，但是，其实三条命令可以简化成一条命令的，会大大减少我们的AOF的文件，大大加速我们恢复的速度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ set k1 3</span><br></pre></td></tr></table></figure><h5 id="AOF重写的两种方式"><a href="#AOF重写的两种方式" class="headerlink" title="AOF重写的两种方式"></a>AOF重写的两种方式</h5><ul><li>bgrewriteaof，会fork出一个子进程来进行AOF的重写</li><li>配置文件<ul><li>auto-aof-rewrite-min-size：AOF文件需要重写的大小是多少</li><li>auto-aof-rewrite-percentage：下一次重写距离这一次重写需要在文件提升多少的百分比的时候进行</li><li>aof_current_size：统计当前AOF的大小</li><li>aof_base_size：AOF上次启动和重写的尺寸</li></ul></li></ul><img src="/2019/05/17/Redis-持久化/02.jpg"><p><strong>上demo</strong></p><p>首先还是要修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#开启append only模式之后，redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件中</span><br><span class="line">appendonly yes</span><br><span class="line">#AOF的文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">#默认使用everysec策略</span><br><span class="line">appendfsync everysec</span><br><span class="line">#是否会在append的时候，由于请求过长，而阻止</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">#默认的aof的最小文件大小，以及增长率</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">#当aof文件出错的时候，重启的时候是否忽略错误</span><br><span class="line">aof-load truncated yes</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 插入两条数据</span><br><span class="line">$ set k1 v1</span><br><span class="line">$ set k2 v2</span><br></pre></td></tr></table></figure><p>去data目录下会发现有aof的文件生成</p><p>把文件删除掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 手动生成AOF文件</span><br><span class="line">$ bgrewriteaof</span><br></pre></td></tr></table></figure><p>可以看到也是有AOF文件生成的</p><h4 id="RDB与AOF的区别"><a href="#RDB与AOF的区别" class="headerlink" title="RDB与AOF的区别"></a>RDB与AOF的区别</h4><table><thead><tr><th>命令</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table><h5 id="RDB的选择"><a href="#RDB的选择" class="headerlink" title="RDB的选择"></a>RDB的选择</h5><ul><li>在单机操作大多数情况下，建议关闭</li><li>当数据恢复的量级比较大的情况下建议开启</li><li>在集群的情况下，建议从节点开</li></ul><h5 id="AOF的最佳选择"><a href="#AOF的最佳选择" class="headerlink" title="AOF的最佳选择"></a>AOF的最佳选择</h5><ul><li>在单机大多数操作情况下，建议开启</li><li>AOF重写集中管理（防止Redis自动做重写操作而导致fork太多引起的内存不足等问题）</li><li>建议使用everysec策略</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/17/Redis-持久化/01.png&quot;&gt;
&lt;h3 id=&quot;什么是持久化&quot;&gt;&lt;a href=&quot;#什么是持久化&quot; class=&quot;headerlink&quot; title=&quot;什么是持久化&quot;&gt;&lt;/a&gt;什么是持久化&lt;/h3&gt;&lt;p&gt;redis所有数据都是保存
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂方法</title>
    <link href="http://yoursite.com/2019/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/05/14/设计模式-工厂方法/</id>
    <published>2019-05-14T09:34:58.000Z</published>
    <updated>2019-05-14T08:02:50.154Z</updated>
    
    <content type="html"><![CDATA[<p>首先在介绍工厂方法之前，先介绍一个新的概念，简单工厂</p><p><strong>简单工厂不是一种设计模式</strong></p><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><ul><li>由一个工厂对象来决定创建出哪一种产品类的示例</li><li>工厂类负责适合创建的对象比较少的场景</li><li>应用层只用传入工厂类的参数，对于如何创建，不关心创建对象的细节</li><li>工厂类的职责较重，因为所有对象创建都由工厂类，万一工厂类出了问题，会影响很大</li></ul><p>先上Demo,比如我这里是一个玩具厂，生产的玩具有蜘蛛侠和钢铁侠吧,不用简单工厂模式的设计下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义一个玩具抽象类</span><br><span class="line"> */</span><br><span class="line">abstract class AbstractToy &#123;</span><br><span class="line">    public abstract void produce();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 蜘蛛侠</span><br><span class="line"> */</span><br><span class="line">class SpiderManToy extends Toy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;我是蜘蛛侠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 钢铁侠</span><br><span class="line"> */</span><br><span class="line">class IronManToy extends Toy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;我是钢铁侠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class TestDemo&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Toy toy = new IronManToy();</span><br><span class="line">        toy.produce();</span><br><span class="line">        toy = new SpiderManToy();</span><br><span class="line">        toy.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面存在一个什么问题呢？</p><p>现在我们只有两个玩具而已，如果是三个，四个呢？不断添加一个类来继承我们的抽象类吗？然后不断自己new一个类，这就是高耦合，实现类你要自己编写，业务层你又要自己编写，太麻烦了，看下面示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 玩具工厂类</span><br><span class="line"> */</span><br><span class="line">class ToyFactory&#123;</span><br><span class="line">    public static Toy getToy(String name)&#123;</span><br><span class="line">        if(&quot;IronMan&quot;.equalsIgnoreCase(name))&#123;</span><br><span class="line">            return new IronManToy();</span><br><span class="line">        &#125;else if(&quot;SpiderMan&quot;.equalsIgnoreCase(name))&#123;</span><br><span class="line">            return new SpiderManToy();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Toy toy = ToyFactory.getToy(&quot;IronMan&quot;);</span><br><span class="line">        toy.produce();</span><br><span class="line">        toy = ToyFactory.getToy(&quot;spiderman&quot;);</span><br><span class="line">        toy.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，将实现类和业务逻辑代码去分开了，业务层只需要去传参数，就可以获取到对应的实现类，如何获取到的细节可以完全不用管理，减少了实业务层和实现层的耦合度，可以分开两个人去对这两个模块进行一个单独的管理，也不会出现问题，业务层只需要传参，工厂那边负责对参数的接收和返回具体的一个实现类以及实现类的编写</p><p>以上，业务层已经很好了，但是工厂那一块我们是用了if…else…if这种方法特别不好，写工厂的人，还是和一开始一样，既要自己new具体的实现类，又要编写工厂类，其实本质还是没有发生改变，只是从业务层的麻烦移到工厂上了而已，以上就是我们的简单工厂的做法，所以说，为什么简单工厂只能适合少部分的实例的创建，就是因为一旦管理较多类的情况下，就会导致代码很冗余</p><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><ul><li>定义一个创建对象的接口，<strong>让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行</strong></li><li>适用于创建对象需要大量重复代码的时候</li><li>应用层不依赖于产品类的实现细节</li><li>一个类通过其子类来指定创建哪个对象</li></ul><p>重点再说一次：<strong>让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义一个玩具抽象类</span><br><span class="line"> */</span><br><span class="line">abstract class Toy &#123;</span><br><span class="line">    public abstract void produce();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 蜘蛛侠</span><br><span class="line"> */</span><br><span class="line">class SpiderManToy extends Toy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;我是蜘蛛侠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 钢铁侠</span><br><span class="line"> */</span><br><span class="line">class IronManToy extends Toy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;我是钢铁侠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 玩具工厂类</span><br><span class="line"> */</span><br><span class="line">abstract class ToyFactory &#123;</span><br><span class="line">    public abstract Toy getToy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 蜘蛛侠工厂</span><br><span class="line"> */</span><br><span class="line">class SpiderManToyFactory extends ToyFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Toy getToy() &#123;</span><br><span class="line">        return new SpiderManToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 钢铁侠工厂</span><br><span class="line"> */</span><br><span class="line">class IronManToyFactory extends ToyFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Toy getToy() &#123;</span><br><span class="line">        return new IronManToy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ToyFactory toyFactory = new SpiderManToyFactory();</span><br><span class="line">        Toy toy = toyFactory.getToy();</span><br><span class="line">        toy.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里上一个类图：</p><img src="/2019/05/14/设计模式-工厂方法/01.png"><p>一共包含三个大角色，产品，工厂，调用者</p><p>其中产品里包含了具体的产品实现</p><p>工厂里包含了具体的工厂用来创建具体的产品</p><h4 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 玩具工厂类</span><br><span class="line"> */</span><br><span class="line">class ToyFactory&#123;</span><br><span class="line"></span><br><span class="line">    public static Toy getToy(Class c) &#123;</span><br><span class="line">        AbstractToy toy = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            toy = (Toy) Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return toy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class TestDemo&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Toy toy = ToyFactory.getToy(IronManToy.class);</span><br><span class="line">        toy.produce();</span><br><span class="line">        toy = ToyFactory.getToy(SpiderManToy.class);</span><br><span class="line">        toy.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我使用了反射来解决了在业务层只需要传参数而不用关心其实例创建过程的细节，而每次添加新的类的时候，也不需要修改到工厂类的代码</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里讲了三种方法，最后进行一个总结</p><p>其中，简单工厂适合实例少的场景，优点是简单，易懂，缺点是违反了开闭原则</p><p>工厂方法，有点是，适用实例多的场景，遵循开闭原则，缺点是，比较繁琐</p><p>使用简单工厂配合反射，可以解决开闭原则的问题，缺点是使用反射会使程序的效率降低</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先在介绍工厂方法之前，先介绍一个新的概念，简单工厂&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单工厂不是一种设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; class=&quot;headerlink&quot; title=&quot;简单工厂&quot;&gt;&lt;/a&gt;简单工
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker-本地镜像发布到阿里云</title>
    <link href="http://yoursite.com/2019/05/11/Docker-%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    <id>http://yoursite.com/2019/05/11/Docker-本地镜像发布到阿里云/</id>
    <published>2019-05-10T19:48:47.000Z</published>
    <updated>2019-05-10T12:59:45.344Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/11/Docker-本地镜像发布到阿里云/01.jpg"><p>前面讲到了DockerFile</p><p>DockerFile是什么来的呢？这里重温一下，DockerFile就是用来构建我们的Docker镜像文件</p><p>为什么要学DockerFile?因为拉取的镜像往往功能比较单一，我们有时候会需要根据不同的业务来对我们的虚拟机进行一些定制，这时候就有两种方法可选，一种是DockerFile，一种是执行docker commit,其中DockerFile的灵活性更加高但同时也带有一定的学习难度</p><p>本次主要讲解的是<strong>本地镜像发布到阿里云</strong></p><p>为什么要这么做呢？</p><p>这和我们的代码需要被管理是一个道理，而且，好的东西，开源，不也挺好的吗</p><h4 id="本地镜像发布到阿里云的流程"><a href="#本地镜像发布到阿里云的流程" class="headerlink" title="本地镜像发布到阿里云的流程"></a>本地镜像发布到阿里云的流程</h4><img src="/2019/05/11/Docker-本地镜像发布到阿里云/02.jpg"><p>图片看上去很复杂，这里大致解释一下，首先找到一个没有被指向的地方开始看，入口就是DockerFile了，DockerFile build之后成为一个镜像，Docker跑起来就是一个容器，还有两个，一个是阿里云，一个是私有云，说白了就是，你推上去的这个镜像，希不希望让别人能够看到的意思</p><h4 id="镜像的生成方法"><a href="#镜像的生成方法" class="headerlink" title="镜像的生成方法"></a>镜像的生成方法</h4><ol><li>DockerFile</li><li>docker commit</li></ol><h4 id="将本地镜像推送到阿里云"><a href="#将本地镜像推送到阿里云" class="headerlink" title="将本地镜像推送到阿里云"></a>将本地镜像推送到阿里云</h4><p>首先进入阿里云控制台创建一个镜像仓库用来存放镜像，代码源我这里选择的是本地仓库</p><img src="/2019/05/11/Docker-本地镜像发布到阿里云/03.jpg"><p>点击管理进入</p><img src="/2019/05/11/Docker-本地镜像发布到阿里云/04.jpg"><p>找到 3. 将镜像推送到Registry</p><img src="/2019/05/11/Docker-本地镜像发布到阿里云/05.png"><img src="/2019/05/11/Docker-本地镜像发布到阿里云/06.png"><img src="/2019/05/11/Docker-本地镜像发布到阿里云/07.png"><p>接下来就可以在自己仓库里面可以看到自己push后的镜像</p><h4 id="将阿里云的镜像拉取到本地"><a href="#将阿里云的镜像拉取到本地" class="headerlink" title="将阿里云的镜像拉取到本地"></a>将阿里云的镜像拉取到本地</h4><p>直接docker push 自己的镜像</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里涉及到的三条命令</p><ol><li>用docker登陆阿里云</li><li>用docker push到阿里云</li><li>用docker pull从阿里云拉取到本地 </li></ol><p>这里三条的命令都可以在我的仓库管理里面可以清楚查看，也不用过多的解释</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/11/Docker-本地镜像发布到阿里云/01.jpg&quot;&gt;
&lt;p&gt;前面讲到了DockerFile&lt;/p&gt;
&lt;p&gt;DockerFile是什么来的呢？这里重温一下，DockerFile就是用来构建我们的Docker镜像文件&lt;/p&gt;
&lt;p&gt;为什么要
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-原型</title>
    <link href="http://yoursite.com/2019/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/05/05/设计模式-原型/</id>
    <published>2019-05-05T08:23:10.000Z</published>
    <updated>2019-05-05T02:39:46.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型设计模式"><a href="#原型设计模式" class="headerlink" title="原型设计模式"></a>原型设计模式</h3><p>什么是原型设计模式呢？可以根据我们的名字来推测就是，首先要有个原型，然后根据原型不断来产生新的东西</p><h4 id="普通的一个例子"><a href="#普通的一个例子" class="headerlink" title="普通的一个例子"></a>普通的一个例子</h4><p>看以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Demo&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">class Use&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Demo&gt; list = new ArrayList&lt;Demo&gt;(); </span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            list.add(new Demo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码，逻辑上没什么问题，就是new了100个Demo的实例嘛</p><p>但是</p><p>我这里new了100次啊，100次啊！！！</p><p>太浪费了CPU内存了，结合我们对单例模式的了解，我们可不可以写成单例？肯定可以啊，但是单例获取的只是一个实例，假设我的业务需求真的需要100个呢？难道真的没办法只能new 100次了吗？？</p><h4 id="原型登场"><a href="#原型登场" class="headerlink" title="原型登场"></a>原型登场</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Demo implements Cloneable&#123;</span><br><span class="line">    private static Demo demo = new Demo();</span><br><span class="line">    //禁止实例化</span><br><span class="line">    private Demo()&#123;&#125;;</span><br><span class="line">    //唯一接口获取实例</span><br><span class="line">    public static Demo getDemo() throws CloneNotSupportedException&#123;</span><br><span class="line">        return demo.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    //重写clone方法</span><br><span class="line">    @Override</span><br><span class="line">    protected Demo clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return (Demo)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Use&#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        List&lt;Demo&gt; list = new ArrayList&lt;Demo&gt;(); </span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            list.add(Demo.getDemo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里，原型设计模式核心思想是用到了克隆，克隆这个方法其实就是进行了一个内存块的复制，在创建对象成本较大，如初始化占用较长时间、占用大量cpu资源等，新的对象可以通过原型对象复制产生新的对象。</strong></p><p>因为我们的原型设计模式设计到内存块的复制，这里就会产生两个问题</p><ul><li>浅复制</li><li>深复制</li></ul><p>了解对象和引用的区别的朋友都知道，如果单纯拷贝一个内存块，是完全不够的，为什么呢？因为引用！所以上述例子是实现不了引用类型的拷贝</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>看以下例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Demo implements Cloneable &#123;</span><br><span class="line">private static Demo demo = new Demo();</span><br><span class="line">public A a = new A();</span><br><span class="line"></span><br><span class="line">// 禁止实例化</span><br><span class="line">private Demo() &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 唯一接口获取实例</span><br><span class="line">public static Demo getDemo() throws CloneNotSupportedException &#123;</span><br><span class="line">return demo.clone();</span><br><span class="line">&#125;</span><br><span class="line">// 重写clone方法</span><br><span class="line">@Override</span><br><span class="line">protected Demo clone() throws CloneNotSupportedException &#123;</span><br><span class="line">return (Demo) super.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Use &#123;</span><br><span class="line">public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">Demo demo1 = Demo.getDemo();</span><br><span class="line">Demo demo2 = Demo.getDemo();</span><br><span class="line">System.out.println(&quot;demo1:&quot; + demo1);</span><br><span class="line">System.out.println(&quot;demo2:&quot; + demo2);</span><br><span class="line">System.out.println(&quot;demo1:&quot; + demo1.a);</span><br><span class="line">System.out.println(&quot;demo2:&quot; + demo2.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">demo1:demo02.Demo@15db9742</span><br><span class="line">demo2:demo02.Demo@6d06d69c</span><br><span class="line">demo1:demo02.A@7852e922</span><br><span class="line">demo2:demo02.A@7852e922</span><br></pre></td></tr></table></figure><p>出现了一个结果：Object的地址是一样的，说明这里的object是同一个对象，没有实现到拷贝，这就是所谓的浅拷贝，这里上一幅图以供理解</p><img src="/2019/05/05/设计模式-原型/01.jpg"><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class A implements Cloneable&#123;</span><br><span class="line">@Override</span><br><span class="line">protected A clone() throws CloneNotSupportedException &#123;</span><br><span class="line">return (A)super.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Demo implements Cloneable &#123;</span><br><span class="line">private static Demo demo = new Demo();</span><br><span class="line">public A a = new A();</span><br><span class="line"></span><br><span class="line">// 禁止实例化</span><br><span class="line">private Demo() &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 唯一接口获取实例</span><br><span class="line">public static Demo getDemo() throws CloneNotSupportedException &#123;</span><br><span class="line">Demo temp = demo.clone();</span><br><span class="line">temp.setA(temp.a.clone());</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">private void setA(A a) &#123;</span><br><span class="line">this.a = a;</span><br><span class="line">&#125;</span><br><span class="line">// 重写clone方法</span><br><span class="line">@Override</span><br><span class="line">protected Demo clone() throws CloneNotSupportedException &#123;</span><br><span class="line">return (Demo) super.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Use &#123;</span><br><span class="line">public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">Demo demo1 = Demo.getDemo();</span><br><span class="line">Demo demo2 = Demo.getDemo();</span><br><span class="line">System.out.println(&quot;demo1:&quot; + demo1);</span><br><span class="line">System.out.println(&quot;demo2:&quot; + demo2);</span><br><span class="line">System.out.println(&quot;demo1:&quot; + demo1.a);</span><br><span class="line">System.out.println(&quot;demo2:&quot; + demo2.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">demo1:demo02.Demo@15db9742</span><br><span class="line">demo2:demo02.Demo@6d06d69c</span><br><span class="line">demo1:demo02.A@7852e922</span><br><span class="line">demo2:demo02.A@4e25154f</span><br></pre></td></tr></table></figure><h4 id="原型设计模式的优缺点"><a href="#原型设计模式的优缺点" class="headerlink" title="原型设计模式的优缺点"></a>原型设计模式的优缺点</h4><p><strong>优点</strong></p><ul><li>如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li><li>可以使用深克隆保持对象的状态</li><li>原型模式提供了简化的创建结构</li></ul><p><strong>缺点</strong></p><ul><li>在实现深克隆的时候可能需要比较复杂的代码。</li><li>需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原型设计模式&quot;&gt;&lt;a href=&quot;#原型设计模式&quot; class=&quot;headerlink&quot; title=&quot;原型设计模式&quot;&gt;&lt;/a&gt;原型设计模式&lt;/h3&gt;&lt;p&gt;什么是原型设计模式呢？可以根据我们的名字来推测就是，首先要有个原型，然后根据原型不断来产生新的东西&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker---Docker容器数据卷</title>
    <link href="http://yoursite.com/2019/04/29/Docker-Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
    <id>http://yoursite.com/2019/04/29/Docker-Docker容器数据卷/</id>
    <published>2019-04-29T13:41:52.000Z</published>
    <updated>2019-05-10T08:08:33.737Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/04/29/Docker-Docker容器数据卷/01.jpg"><h3 id="Docker数据卷"><a href="#Docker数据卷" class="headerlink" title="Docker数据卷"></a>Docker数据卷</h3><p>使用Docker的时候，我们明白我们跑的都是一个个容器，比如Tomcat，Mysql，Redis等等，既然如此，必须有个东西—–》<strong>数据</strong></p><p>数据我怎么做一个持久化呢？怎么获取呢？容器奔了我数据就没了吗？</p><p>这时候就有数据卷的诞生</p><p><strong>数据卷</strong>：一个存放数据的东西，在Docker当中叫做数据卷，可以理解为磁盘，持久存放</p><p><strong>数据卷容器</strong>：那就是可以理解为存放硬盘的容器，可以理解为移动硬盘</p><p><strong>说白点呢，数据是存放在数据卷当中，但是当多个数据卷要进行交互的时候，就需要一个容器来包揽住这些数据卷，这个容器就叫做数据卷容器</strong></p><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><h4 id="使用-v指令来进行挂载数据卷"><a href="#使用-v指令来进行挂载数据卷" class="headerlink" title="使用-v指令来进行挂载数据卷"></a>使用-v指令来进行挂载数据卷</h4><p>挂载数据卷就是将本机的某个数据卷（某个文件夹）与容器内共享</p><p>docker run -v 宿主机的路径:容器内的路径 镜像名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在根目录下创建个文件夹</span><br><span class="line">$ cd /</span><br><span class="line">$ mkdir Doroot</span><br><span class="line">执行命令</span><br><span class="line">$ docker run -it -v /Doroot:/aaaa --privileged=true centos</span><br></pre></td></tr></table></figure><p><strong>注意一下一定要加 –privileged=true 否则容器内部会没有权限</strong></p><img src="/2019/04/29/Docker-Docker容器数据卷/02.jpg"><p><strong>这样子在容器内就能获取到我们宿主机上的数据了，注意一点，此时修改宿主机或者容器内部的数据卷里的文件，都会受到影响，简单来说就是宿主机和容器内布共享数据卷里面的文件</strong></p><h4 id="使用DockerFile来添加数据卷"><a href="#使用DockerFile来添加数据卷" class="headerlink" title="使用DockerFile来添加数据卷"></a>使用DockerFile来添加数据卷</h4><p>以下代码就在容器内挂载了/BBBB，没有指明对应的宿主机位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;/BBBB&quot;]</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>然后docker build建立镜像</p><img src="/2019/04/29/Docker-Docker容器数据卷/03.jpg"><p>查看一下容器内挂载的与宿主机对应的位置在哪</p><img src="/2019/04/29/Docker-Docker容器数据卷/04.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;b3b394fac32e2e263e360de210b36665d03554425d23fe23ad8ebc54aa304716&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/b3b394fac32e2e263e360de210b36665d03554425d23fe23ad8ebc54aa304716/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/BBBB&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><p>/BBBB对应的宿主机位置为</p><p>/var/lib/docker/volumes/</p><p>b3b394fac32e2e263e360de210b36665d03554425d23fe23ad8ebc54aa304716/_data</p><p>因为我们也说过宿主机和容器内布，是共享的，我们可以亲自去测试一下，这里我就不演示了(如果要测试，记得加上特权模式 –privileged =true，否则会报没权限错误)</p><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p><strong>建立一个容器挂载数据卷，其他容器通过挂载这个容器（父容器）来实现数据共享，挂载数据卷的容器就是数据卷容器</strong></p><p>容器之间传递共享 –volumes-from</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//先创建一个父容器，挂载宿主机</span><br><span class="line">$ docker run -it -v /Doroot:/aaaa --name d01  --privileged=true centos</span><br><span class="line">//退出容器</span><br><span class="line">$ ctrl + P + Q</span><br><span class="line">//创建一个子容器</span><br><span class="line">$docker run -it --name d02 --volumes-from dc01 --privileged=true centos</span><br></pre></td></tr></table></figure><p>此时d02的centos也挂载了容器卷，实现了容器卷的一个传递</p><p><strong>此时数据共享，改变任意一个容器的数据卷信息，另外的容器都会受到影响</strong></p><img src="/2019/04/29/Docker-Docker容器数据卷/05.jpg"><p>总结一下数据卷容器，总结之前先抛出几个问题</p><ol><li>d01删除后 d02还有吗？   —-有</li><li>d01删除后,新建d03继承d02，d03有吗？ —有</li><li>d03继承d01后，删除d01,d02和d03可以共享吗？ —可以</li></ol><p><strong>结论：容器之间的配置信息的传递，数据卷的生命周期一直持续到没有容器使用为止</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/04/29/Docker-Docker容器数据卷/01.jpg&quot;&gt;
&lt;h3 id=&quot;Docker数据卷&quot;&gt;&lt;a href=&quot;#Docker数据卷&quot; class=&quot;headerlink&quot; title=&quot;Docker数据卷&quot;&gt;&lt;/a&gt;Docker数据卷
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-DockerFile</title>
    <link href="http://yoursite.com/2019/04/29/Docker-DockerFile/"/>
    <id>http://yoursite.com/2019/04/29/Docker-DockerFile/</id>
    <published>2019-04-29T12:16:38.000Z</published>
    <updated>2019-05-10T11:50:25.158Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/04/29/Docker-DockerFile/01.jpg"><h4 id="Docker深入"><a href="#Docker深入" class="headerlink" title="Docker深入"></a>Docker深入</h4><p>前面讲解了Docker的基本概念以及Docker的安装，还简单跑了一个例子，相信能够对Docker有一个大致的了解</p><p>本章将对Docker进一步的探索</p><h4 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h4><p>DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p><p>DockerFile就是用来构建Docker镜像的，现在DockerHub上面有很多镜像，但是有时候我们会根据需求来自定义镜像，（比如说我们要改造Centos）常用两种方法：</p><ol><li>我们在DockerHub上面拉取一个镜像下来，然后进入容器里面进行修改，接着进行docker commit（形成新的一个镜像）</li><li>我们自己编写DockerFile文件，因为所有镜像本质都是DockerFile，编写完自己构建出一个镜像</li></ol><p><strong>DockerFile和 docker commit 的区别：</strong></p><p>DockerFile更加灵活，我可以随时根据需求来更改我的文件而docker commit，不具备重复性，什么意思呢，就是说，在DockerFile我不要一个东西，只是删除一行就好了（因为这是构建文件，我把某一块去掉就可以了），但是如果用docker commit就不行了，你安装了好些东西，要删除可能得一个个卸载，而且有时候你想要回复到之前某个点的，就非常困难了，所以：<strong>构建镜像不推荐docker commit,请使用DockerFile</strong></p><p>构建DockerFile三步骤</p><ul><li>编写DockerFile文件</li><li>docker build</li><li>docker run</li></ul><p><strong>写一个例子吧：</strong></p><p>新建一个DockerFile文件编写以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">From centos</span><br><span class="line">ENV mypath /tmp</span><br><span class="line">WORKDIR $mypath</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>执行docker build命令</p><p>我这里遇到过一个小问题，很多也遇到了，就是build的时候报错</p><p>docker build -f 文件所在的位置 -t 名字：版本号 .</p><p>如果文件在当前目录下可以省略-f</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f /dockerFile/DockerFile -t mycentos:2.2 .</span><br></pre></td></tr></table></figure><p><strong>重要的事情说三遍</strong></p><p><strong>最后面有小数点！！！</strong></p><p><strong>最后面有小数点！！！</strong></p><p><strong>最后面有小数点！！！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//不加小数点报错：</span><br><span class="line">$ &quot;docker build&quot; requires exactly 1 argument(s).</span><br><span class="line">//没启动docker报错：</span><br><span class="line">$ Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><img src="/2019/04/29/Docker-DockerFile/02.jpg"><p>可以看到当前的目录是tmp，因为我构建镜像的时候就设置了WORKDIR</p><p>简单的例子讲完了：</p><p>现在看看常用的构建文件命令：</p><ol><li>FROM 基础镜像，当前镜像是基于哪个镜像，可以想象成类与类之间的继承关系</li><li>MAINTAINER，镜像的维护者的姓名和邮箱地址</li><li>RUN，容器构建时需要运行的命令</li><li>EXPOSE，当前容器对外暴露出的端口</li><li>WORKDIR，指定创建容器后，终端默认登陆进来的工作目录</li><li>ENV，用来构建镜像过程中设置环境变量</li><li>ADD，将宿主机的目录下的文件拷贝到镜像里面并且ADD命令会自动处理URL和解压tar</li><li>COPY，类似ADD，拷贝文件和目录到镜像中。&lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</li><li>VOLUME，容器数据卷，用于保存和持久化工作</li><li>CND，指定一个容器启动时要运行的命令，DockerFile中可以有多个CMD指令，但只有最后一个生效，会被docker run 后面的参数给覆盖</li><li>ENTRYPOINT，和CMD一样是指定一个容器启动时要运行的命令，区别在于不会被覆盖，都能执行</li><li>ONBUILD，当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</li></ol><p><strong>这个可能就需要多做才能熟悉其命令了</strong></p><p>比如说我们拉取的Centos都是比较纯净的</p><p>怎么说呢，什么东西都没有装就对了</p><p>比如下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 继承自centos，在centos基础上安装vim</span><br><span class="line">From centos</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>最后写一个命令稍微复杂一点的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#继承原生Tomcat</span><br><span class="line">FROM centos</span><br><span class="line">#设置作者和邮箱</span><br><span class="line">MAINTAINER ymbcxb&lt;353560278@qq.com&gt;</span><br><span class="line">#把宿主机当前上下文的c.txt拷贝到容器/usr/local中</span><br><span class="line">COPY c.txt /usr/local/cincontainer.txt</span><br><span class="line">#把java与tomcat添加到容器中</span><br><span class="line">ADD apache-tomcat-9.0.17.tar.gz  /usr/local/</span><br><span class="line">ADD jdk-8u201-linux-x64.tar.gz /usr/local/</span><br><span class="line">#安装VIM编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#设置工作访问时候的落脚点</span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">#配置Java与Tomcat的环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_201</span><br><span class="line">ENV CLASSPATH JAVA_HOME/lib/dt.jar:JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.17</span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.17</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line">#容器运行时监听的端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line">#启动时运行tomcat用ENTRYPOINT 和 CMD都可以</span><br><span class="line">#ENTRYPOINT [&quot;/usr/local/apache-tomcat-9.0.17/bin/startup.sh&quot;]</span><br><span class="line">#CMD [&quot;/usr/local/apache-tomcat-9.0.17/bin/startup.sh&quot;,&quot;run&quot;]</span><br><span class="line">#启动tomcat并且打印日志</span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.17/bin/startup.sh &amp;&amp; tail - F /usr/local/apache-tomcat-9.0.17/bin/logs/catalina.out</span><br></pre></td></tr></table></figure><p><strong>温馨提示：记得将对应的Jar包和Tomcat的包和c.txt放到当前目录下</strong></p><img src="/2019/04/29/Docker-DockerFile/03.jpg"><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -p 9080:8080 -d mytomcat:1.0</span><br></pre></td></tr></table></figure><p>然后在浏览器输入对应的网址就可以看到Tomcat的页面，LinuxIp:9080 </p><p>执行以下命令进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it cotainerId /bin/bash</span><br></pre></td></tr></table></figure><img src="/2019/04/29/Docker-DockerFile/03.png"><p>查看到是存在cincontainer.txt</p><p>总结：</p><p>关于命令的学习，还是需要多琢磨琢磨，比如你可以手写一个Centos（安装了openssh）这样子，下次你需要用虚拟机的时候只用开启多一个容器，就够了就可以进行SSH连接来玩，玩坏了不过删容器而已，比传统的下载一个虚拟机镜像要方便多了，大大大大大地提高学习效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/04/29/Docker-DockerFile/01.jpg&quot;&gt;
&lt;h4 id=&quot;Docker深入&quot;&gt;&lt;a href=&quot;#Docker深入&quot; class=&quot;headerlink&quot; title=&quot;Docker深入&quot;&gt;&lt;/a&gt;Docker深入&lt;/h4&gt;
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker初探</title>
    <link href="http://yoursite.com/2019/04/23/Docker%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2019/04/23/Docker初探/</id>
    <published>2019-04-23T10:34:02.000Z</published>
    <updated>2019-05-02T07:34:04.490Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/04/23/Docker初探/01.jpg"><h3 id="Docker初识"><a href="#Docker初识" class="headerlink" title="Docker初识"></a>Docker初识</h3><p>什么是Docker呢？</p><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal)、OpenStack 集群和其他的基础应用平台。 </p><p>简单点理解呢：Docker是一个管理容器的平台</p><p>简单介绍一下容器和虚拟机：</p><ul><li>虚拟机：虚拟出一套硬件，在其之上的一个运行一个完整的操作系统</li><li>容器：容器之间互相隔离，但共享这同一份硬件系统</li></ul><p>我们平时会在电脑上安装各种软件，比如微信，QQ。那么我们Docker呢，在想的是把一个系统看成一个软件，我们安装一个软件（本质是一个系统），比如，你现在的操作系统有很多软件，假设，你要换到一台新的电脑是不是要重新安装软件呢，这就很麻烦了，我们可以直接把你的系统当作一个软件，直接一安装就和你旧的电脑一摸一样了。</p><p>Docker的好处：</p><ul><li>轻：开启速度快，因为不像Vmware那样子有一套虚拟化硬件，所以快</li><li>开发运维一致性：不会再对环境不一样起争议</li><li>弹性大：这点解释下，比如我现在一台服务器不够用的情况下，理论上是要新建一台服务器，但是新建的过程是很费时间的，因为有各种配置文件，所以，在Docker里，当不够用的时候，不过是安装多一个容器的事情，容器里面什么都做好了</li><li>安全：怎么捣鼓都是在容器里，实在不行，删了重建而已，不会影响导别的容器</li></ul><p>附上一张图，以供了解：</p><img src="/2019/04/23/Docker初探/02.png"><p>那么Docker有几个核心概念：</p><ul><li>仓库</li><li>镜像</li><li>容器</li></ul><p>简单描述如下：</p><ul><li><p>容器呢就是我们实际运行的东西</p></li><li><p>镜像呢就是用生成容器</p><p><strong>这里可以这么理解为：用面向对象的思想来说，镜像就是类，容器就是实例对象</strong></p></li><li><p>仓库呢就是用来放镜像的</p></li></ul><h3 id="首先简单跑一个Docker例子"><a href="#首先简单跑一个Docker例子" class="headerlink" title="首先简单跑一个Docker例子"></a>首先简单跑一个Docker例子</h3><p>首先开启我们的虚拟机,我这里是Centos7，不同虚拟机可能有一点点差别，总体来说差别不大：</p><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><p>这里要注意一点：</p><p><strong>Centos 需要内核版本为3.8以及以上才能运行Docker</strong></p><p>(命令不包含$符号)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查看内核版本</span><br><span class="line">$ uname -r</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//安装docker</span><br><span class="line">$ sudo yum install docker</span><br></pre></td></tr></table></figure><h4 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//启动 docker</span><br><span class="line">$ systemctl start docker</span><br><span class="line">//将 docker 服务设为开机启动</span><br><span class="line">$ systemctl enable docker</span><br><span class="line">//查看 docker版本，验证启动成功</span><br><span class="line">$ docker -v</span><br></pre></td></tr></table></figure><h4 id="拉取一个Centos镜像"><a href="#拉取一个Centos镜像" class="headerlink" title="拉取一个Centos镜像"></a>拉取一个Centos镜像</h4><p>拉取之前，先要搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search centos</span><br></pre></td></tr></table></figure><img src="/2019/04/23/Docker初探/03.png"><p>OFFICIAL ：代表官方</p><p>这里拉取的时候，默认是很慢的，因为使用的源地址是国外的，速度非常非常慢</p><p>为了提高速度，可以换取阿里或者网易的源</p><p>我这里使用的是阿里云</p><p>首先得注册一个阿里云账号，进入控制台找到</p><img src="/2019/04/23/Docker初探/04.png"><p>在这里可以看到加速器的地址，由于每个人的加速器地址，我这里就教下怎么配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//打开配置文件</span><br><span class="line">$ vi /etc/docker/daemon.json</span><br><span class="line">//配置下面这段</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://xxxxx.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来开始正式拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull centos</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查看所有镜像</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure><img src="/2019/04/23/Docker初探/05.png"><p>什么！！！只有两百M？对的，就是这么小，为什么，因为没有虚拟出一套物理硬件，单纯在硬件之上的层次，就这么小</p><p>默认的就是拉取最新版</p><p>如果想拉6的怎么办</p><p>指定一下就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull centos:centos6</span><br></pre></td></tr></table></figure><img src="/2019/04/23/Docker初探/06.png"><p>那么我怎么知道标签是多少呢？？？</p><p>去官网<a href="https://hub.docker.com/_/centos查就可以了" target="_blank" rel="noopener">https://hub.docker.com/_/centos查就可以了</a></p><p>最后一步！！！</p><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//docker run 镜像名字:标签,这里 -it代表交互</span><br><span class="line">$ docker run -it centos:latest</span><br></pre></td></tr></table></figure><p>此时就跑起来了</p><img src="/2019/04/23/Docker初探/07.png"><p>这就跑起来了一个建立在你虚拟机上的一个centos，而且秒开</p><p>你可以在这个界面里输入一些Linux指令也是可以行的，如果要退出</p><p>有两种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//第一种 退出容器，且杀死容器，说白了就容器没了</span><br><span class="line">$ exec </span><br><span class="line">//第二种，退出容器，且容器后台运行，可以重新进入</span><br><span class="line">$ ctrl+p+q</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//检查所有容器的状态</span><br><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure><p>最后列举一下Docker镜像和容器常用的基本命令</p><p><strong>镜像的操作命令：</strong></p><ul><li>删除单个镜像 docker rmi name</li><li>删除多个镜像 docker rmi name1 name2</li><li>删除全部镜像 docker rmi -f $(docker images -qa)</li><li>运行一个镜像 docker run [OPTIONS] imagename</li><li><ul><li>OPTIONS说明</li><li>–name=”容器新名字”: 为容器指定一个名称</li><li>-d: 后台运行容器，并返回容器ID，也即启动守护式容器</li><li>-i：以交互模式运行容器，通常与 -t 同时使用</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用</li><li>-P: 随机端口映射</li><li>-p: 指定端口映射，有以下四种格式<pre><code>ip:hostPort:containerPortip::containerPorthostPort:containerPortcontainerPort</code></pre></li></ul></li></ul><p><strong>容器的操作命令：</strong></p><ul><li>启动镜像 docker run images</li><li>查看哪些容器在运行 docker ps</li><li>查看所有容器 docker ps -a</li><li>停止运行中的容器 docker stop id/name</li><li>删除一个容器 docker rm id</li><li>删除全部容器 docker rm -f $(docker ps -a -q)</li><li>重新进入挂起的容器</li><li><ul><li>docker attach id（直接进入容器启动命令的终端，不会启动新的进程）</li><li>dicker exec -t 是在容器中打开新的终端，并且可以启动新的进程</li></ul></li><li>从容器内拷贝文件到宿主机上 docker cp 容器id名字:路径  宿主机路径 </li><li>提交容器副本使之成为新的镜像 docker commit</li></ul><p>本章就到此结束了，算入个门吧，复杂的东西，后面再讲</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/04/23/Docker初探/01.jpg&quot;&gt;
&lt;h3 id=&quot;Docker初识&quot;&gt;&lt;a href=&quot;#Docker初识&quot; class=&quot;headerlink&quot; title=&quot;Docker初识&quot;&gt;&lt;/a&gt;Docker初识&lt;/h3&gt;&lt;p&gt;什么是Doc
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Web登陆其实没那么简单</title>
    <link href="http://yoursite.com/2019/04/11/Web%E7%99%BB%E9%99%86%E5%85%B6%E5%AE%9E%E6%B2%A1%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/"/>
    <id>http://yoursite.com/2019/04/11/Web登陆其实没那么简单/</id>
    <published>2019-04-11T13:15:01.000Z</published>
    <updated>2019-04-29T06:05:30.019Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一个简单的HTML例子看看用户信息安全"><a href="#一个简单的HTML例子看看用户信息安全" class="headerlink" title="一个简单的HTML例子看看用户信息安全"></a>一个简单的HTML例子看看用户信息安全</h4><p>标准的HTML语法中，支持在form表单中使用input标签来创建一个HTTP提交的属性，现代的WEB登录中，常见的是下面这样的表单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action = &quot;http://localhost:8080/Application/login&quot; method = &quot;POST&quot;&gt;</span><br><span class="line">    用户名：&lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot; /&gt;</span><br><span class="line">    密码：&lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; /&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;登陆&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>form表单会在提交请求时,会获取form中input标签存在name的属性，作为HTTP请求的body中的参数传递给后台，进行登录校验。</p><img src="/2019/04/11/Web登陆其实没那么简单/01.jpg"><p>例如我的账号是user1，密码是123456，那么我在提交登录的时候会给后台发送的HTTP请求如下（Chrome或者FireFox开发者工具捕获，需开启Preserve log）：</p><img src="/2019/04/11/Web登陆其实没那么简单/02.jpg"><p>可以发现即便password字段是黑点，但是本机仍以明文的形式截获请求。</p><h4 id="HTTP协议传输直接暴露用户密码字段"><a href="#HTTP协议传输直接暴露用户密码字段" class="headerlink" title="HTTP协议传输直接暴露用户密码字段"></a>HTTP协议传输直接暴露用户密码字段</h4><p>在网络传输过程中，被嗅探到的话会直接危及用户信息安全，以Fiddler或Wireshark为例，发现捕获的HTTP报文中包含敏感信息：</p><img src="/2019/04/11/Web登陆其实没那么简单/03.jpg"><h4 id="使用加密算法能保证密码安全吗？"><a href="#使用加密算法能保证密码安全吗？" class="headerlink" title="使用加密算法能保证密码安全吗？"></a>使用加密算法能保证密码安全吗？</h4><p>WEB前端可以通过某种算法，对密码字段进行加密后，在将密码作为Http请求的内容进行提交，常见的包括对称和非对称加密。</p><blockquote><p>对称加密:采用对称密码编码技术，它的特点是文件加密和解密使用相同的密钥加密。</p></blockquote><blockquote><p>非对称加密:需要两个密钥，公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。</p></blockquote><h5 id="3-1-使用对称加密"><a href="#3-1-使用对称加密" class="headerlink" title="3.1 使用对称加密"></a>3.1 使用对称加密</h5><p>加密解密在前后台协商后，似乎是个不错的办法，比如，前台使用一个字符串位移+字符串反转的简单方法（举个例子，当然不能这么简单）。</p><p>那么这样简单的方法似乎可以混淆原密码，并且轻松由后台进行相反操作复原。但是这有两个缺点：</p><ol><li>前后端加密解密需要同时修改代码；</li><li>前端加密无非是写在JS里，但是JS有风险被直接破解从而识别加密方法。</li></ol><h5 id="3-2非对称加密HTTPS就一定是安全的吗？"><a href="#3-2非对称加密HTTPS就一定是安全的吗？" class="headerlink" title="3.2非对称加密HTTPS就一定是安全的吗？"></a>3.2非对称加密HTTPS就一定是安全的吗？</h5><p>非对称加密有着公钥私钥的存在，公钥可以随意获取，私钥是用来对公钥解密的本地存储，通过公私钥的机制似乎可以保证传输加密并且乃至现在还在使用的HTTPS就是基于这个原理。<br>但是HTTPS就一定安全吗？HTTP存在两种可能的风险：</p><ol><li>HTTPS可以保证传输过程中的信息不被别人截获，但是细细思考下，HTTPS是应用层协议，下层采用SSL保证信息安全，但是在客户端和服务端，密文同样是可以被截获的；</li><li>HTTPS报文在传输过程中，如果客户端被恶意引导安装“中间人”的WEB信任证书，那么HTTPS中的“<a href="https://www.cnblogs.com/gordon0918/p/5237717.html" target="_blank" rel="noopener">中间人攻击</a>”一样会将明文密码泄露给别人。</li></ol><h4 id="结论是，无论HTTP还是HTTPS，密码必须密文传输"><a href="#结论是，无论HTTP还是HTTPS，密码必须密文传输" class="headerlink" title="结论是，无论HTTP还是HTTPS，密码必须密文传输"></a>结论是，无论HTTP还是HTTPS，密码必须密文传输</h4><p>想想HTTPS也不能一定保障用户密码信息，那么就应该考虑在应用层之上再继续对密码进行保护，也就是编写代码来进行控制，而不依赖特定协议，比较容易想到的就是利用不可逆加密散列函数<a href="https://baike.baidu.com/item/MD5/212708?fr=aladdin" target="_blank" rel="noopener">MD5(string)</a>，用户在注册输入密码的时候，就存储MD5(password)值，并且在WEB端先进行MD5(password)，然后将密码传输至后台，与数据库中的密文进行比较（PS：MD5函数在指定位数的情况下，对相同字符串运算值相同）。优点比较明显：</p><ol><li>保证了用户数据库内部的密码信息安全；</li><li>传输过程中无论如何都不会使得用户的密文被破解出原密码；</li><li>简单高效，执行以及编码难度都不大，各种语言都提供MD5支持，开发快。</li></ol><h4 id="那太好了！这样可以省下HTTPS的钱了，真是这样吗？"><a href="#那太好了！这样可以省下HTTPS的钱了，真是这样吗？" class="headerlink" title="那太好了！这样可以省下HTTPS的钱了，真是这样吗？"></a>那太好了！这样可以省下HTTPS的钱了，真是这样吗？</h4><p>回到开头的例子：用户输入的用户名是：user1，密码是：123456，那么不管在什么协议之下，可以看到实际发送的HTTP/HTTPS报文在MD5处理后是这样的：</p><img src="/2019/04/11/Web登陆其实没那么简单/04.jpg"><p>没错，加密登录成功了。但是，当我们庆祝密码安全的时候，发现账户的钱突然不翼而飞。这是为什么呢？黑客却笑的很开心：因为他们并不一定要获取到你的密码明文，如果直接截获你的密码密文，然后发送给服务器不是一样可以登录吗？因为数据库里的不也是MD5(password)的一样的密文吗？HTTP请求被伪造，一样可以登录成功，从而攫取其他的数据或者转走余额。</p><p>这怎么办?其实并不难，有很多种解决方法？其实原理都是类似的：那就是服务器缓存生成随机的验证字段，并发送给客户端，当客户端登录时，把这个一并字段传给服务器，用于校验。</p><h5 id="方案一：验证码"><a href="#方案一：验证码" class="headerlink" title="方案一：验证码"></a>方案一：验证码</h5><p>MVC场景。控制器将把数据的Model封装到View中，这种存在Session的连接方式，允许了在Session中存取信息。那么我们可以利用一些开源的验证码生成工具，例如JAVA中的Kaptcha，在服务端存放生成一个验证码值以及一个验证码的生成图片，将图片以Base64编码，并返回给View，在View中<a href="https://blog.csdn.net/lgh1117/article/details/7740136" target="_blank" rel="noopener">解码Base64并加载图片</a>，并于用户下次登录时再进行比对。</p><h5 id="方案二：token令牌"><a href="#方案二：token令牌" class="headerlink" title="方案二：token令牌"></a>方案二：token令牌</h5><p>前后端分离场景。现在非常流行的前后端分离的开发模式大大提高了项目的开发效率。职责、分工明确，但是由于HTTP是无状态的（就是这一次请求并不知道上一次请求的内容），当用户登录时，根据用户的username作为key，生成随机令牌（例如UUID）作为value缓存在Redis中，并且将token返回给客户端，当客户端登录时，将完成校验，并且删除Redis中的那条缓存记录。</p><p>那么每次从服务器中获取认证的token，确实能保证HTTP请求是由前端传回来的了，因为token在每次登陆后都会删除并被重置，会导致黑客尝试重放账号密码数据信息来登陆的时候导致无法成功登陆。</p><p>总而言之，就是我拿到了账号以及密码的密文也登陆不了，因为，如果请求不包含后台认证的令牌token，是个非法请求。</p><h4 id="可是还别高兴的太早，当心数据被篡改"><a href="#可是还别高兴的太早，当心数据被篡改" class="headerlink" title="可是还别高兴的太早，当心数据被篡改"></a>可是还别高兴的太早，当心数据被篡改</h4><p>密码也加密了，黑客看不到明文了。加上Token了，登陆过程也没法再被截获重放了。可是想想这种情况，你在进行某宝上的网络支付，需要账号，密码，金额，token这四个字段进行操作，然后支付的时候你付了1块钱买了一袋包邮的小浣熊干脆面，某宝结算结束后，你发现你的账户余额被扣了1万元。这又是怎么回事呢？</p><p>因为即便黑客不登录，不操作，一样要搞破坏：当请求路由到黑客这边的时候，截获数据包，然后也不需要登录，反正账号密码都是对的，token也是对的，那么把数据包的字段改改，搞破坏就可以了，于是把money改成了1万，再传给服务器，作为受害者就莫名其妙踩了这个坑。可这该怎么解决呢？其实原理类似于HTTPS里的数字签名机制，首先科普下什么是数字摘要以及数字签名：</p><h5 id="什么是“数字摘要”"><a href="#什么是“数字摘要”" class="headerlink" title="什么是“数字摘要”"></a>什么是“数字摘要”</h5><p>我们在下载文件的时候经常会看到有的下载站点也提供下载文件的“数字摘要“，供下载者验证下载后的文件是否完整，或者说是否和服务器上的文件”一模一样“。其实，数字摘要就是采用单项Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文，这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的内容信息其摘要必定一致。</p><p>因此，“数字摘要“叫”数字指纹“可能会更贴切一些。“数字摘要“是HTTPS能确保数据完整性和防篡改的根本原因。</p><h5 id="数字签名–水到渠成的技术"><a href="#数字签名–水到渠成的技术" class="headerlink" title="数字签名–水到渠成的技术"></a>数字签名–水到渠成的技术</h5><p>假如发送方想把一份报文发送给接收方，在发送报文前，发送方用一个哈希函数从报文文本中生成报文摘要,然后用自己的私人密钥对这个摘要进行加密，这个加密后的摘要将作为报文的”签名“和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公用密钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认报文是从发送方发送且没有被遗漏和修改过！这就是结合“非对称密钥加解密”和“数字摘要“技术所能做的事情，这也就是人们所说的“数字签名”技术。在这个过程中，对传送数据生成摘要并使用私钥进行加密地过程就是生成”数字签名“的过程，经过加密的数字摘要，就是”数字签名“。</p><p>因此，我们可以在WEB端对之前案例中提到的username+MD5(password)+token通过签名，得到一个字段checkCode，并将checkCode发送给服务器，服务器根据用户发送的checkCode以及自身对原始数据签名进行运算比对，从而确认数据是否中途被篡改，以保持数据的完整性。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>看似非常简单的WEB登录，其实里面也存在着非常多的安全隐患。这些安全完善的过程是在一个实际WEB项目中遇到的，上面的分析演化是在应对项目安全的检查中所提出的解决方案，多少会有很多不足的地方，希望一起交流探讨，共同进步！</p><h4 id="补充1：JS加密函数存在被破解"><a href="#补充1：JS加密函数存在被破解" class="headerlink" title="补充1：JS加密函数存在被破解"></a>补充1：JS加密函数存在被破解</h4><p>问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果黑客通过阅读前端js源码,发现加密算法,是否意味他可以构造可以</span><br><span class="line">被服务端解密的checkCode 来欺骗服务端呢 ?</span><br></pre></td></tr></table></figure><p>回答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">摘要或加密JS算法不直接以静态文件的形式存在浏览器中，而是让WEB端去请求Server，服务器可以根据随机令牌token值决定返回一个相应随机的加密策略，以JS代码响应的方式返回，在异步请求响应中，加载JS摘要算法，这样客户端就可以动态加载数字摘要策略，保证无法仿造。</span><br></pre></td></tr></table></figure><h4 id="补充2：MD5存在隐患的问题"><a href="#补充2：MD5存在隐患的问题" class="headerlink" title="补充2：MD5存在隐患的问题"></a>补充2：MD5存在隐患的问题</h4><p>问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用MD5、SHA256 处理密码的过时了。。。现在 PBKDF、bcrypt 都在过时中。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">本文重点侧重于方法思路的介绍，并不一定是要使用MD5函数，可以使用其他的方式。</span><br><span class="line">MD5存在隐患，之前确实没有考虑太多，不过非常感谢园友指出，确实是这样的，主要思想是：</span><br><span class="line">对于MD5的破解，实际上都属于【碰撞】。比如原文A通过MD5可以生成摘要M，我们并不需要把M还原成A，只需要找到原文B，生成同样的摘要M即可。</span><br><span class="line">设MD5的哈希函数是MD5()，那么：</span><br><span class="line">MD5(A) = M</span><br><span class="line">MD5(B) = M</span><br><span class="line">任意一个B即为破解结果。</span><br><span class="line">B有可能等于A，也可能不等于A。</span><br><span class="line">大概意思也就是，截获了MD5加密后的密文，一样可以，找到一个不是原密码，但是加密后可以登陆成功的“伪原文”。</span><br></pre></td></tr></table></figure><p>CSDN有一篇关于MD5风险的博客写的非常好，推荐一下：<a href="https://blog.csdn.net/wufaliang003/article/details/79794982" target="_blank" rel="noopener">MD5算法如何被破解</a></p><p>从中可以看到一点，MD5函数确实能被反向“破解”，但是这个“破解”只是找到一个经过MD5运算后得到相同结果的原文，并非是用户的明文密码。但是这样会被破解登录的可能，确实是需要采用更完善的算法进行加密，再次感谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一个简单的HTML例子看看用户信息安全&quot;&gt;&lt;a href=&quot;#一个简单的HTML例子看看用户信息安全&quot; class=&quot;headerlink&quot; title=&quot;一个简单的HTML例子看看用户信息安全&quot;&gt;&lt;/a&gt;一个简单的HTML例子看看用户信息安全&lt;/h4&gt;&lt;p&gt;标准
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Web登陆" scheme="http://yoursite.com/tags/Web%E7%99%BB%E9%99%86/"/>
    
  </entry>
  
  <entry>
    <title>一条SQL语句的执行过程</title>
    <link href="http://yoursite.com/2019/04/09/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/04/09/一条SQL语句的执行过程/</id>
    <published>2019-04-09T08:33:37.000Z</published>
    <updated>2019-04-29T06:05:03.802Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mysql基本架构示意图"><a href="#Mysql基本架构示意图" class="headerlink" title="Mysql基本架构示意图"></a>Mysql基本架构示意图</h3><img src="/2019/04/09/一条SQL语句的执行过程/01.png"><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核<br>心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引<br>擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、<br>MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL<br>5.5.5 版本开始成为了默认存储引擎。</p><p>也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是<br>InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table<br>语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取<br>方式不同，支持的功能也不同</p><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>连接器是连接我们客户端和服务器首先经过的第一个功能模块，当我们连接我们的Mysql的时候，首先就会执行一条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h[ip地址] -P[端口号] -u[用户名] -p[密码]</span><br></pre></td></tr></table></figure><p>这条语句做的事情就是让本机连接上远端或者本地的Mysql服务器，从而进行管理Mysql</p><p>此时连接器就是用来验证我们的用户名和密码是否正确的，正确则可以得到操作的权限，其实就是和我们网站的第一个入口—&gt;登陆是一个意思，进行用户验证</p><p><strong>如果连接了之后,没有别的操作，则当前连接就正处于一个空闲状态</strong></p><p>当连接上数据库的时候，会保持一个连接，这个连接是长连接，直到连接关闭，否则一直保持连接，中途所有的客户端请求，都由该连接进行工作。短连接只能保证客户端在某个时间段的请求由该连接进行工作，下次查询将会使用一个新的连接</p><p>使用长连接也会由问题：</p><p><strong>因为长连接保持连接，所以长时间下来，当连接数很多的时候，所占用的内存就会很多</strong></p><p>解决办法如下：</p><p>1.定期断开长连接</p><p>2.Mysql5.7版本之后，每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，速度会比较快</p><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>我们首先可以查看mysql关于缓存的配置</p><img src="/2019/04/09/一条SQL语句的执行过程/02.png"><ol><li>query_cache_type: 查询缓存类型,是否打开缓存</li></ol><p>可选项</p><p>  1、0(OFF)：关闭 Query Cache 功能，任何情况下都不会使用 Query Cache；<br>  2、1(ON)：开启 Query Cache 功能，但是当SELECT语句中使用SQL_NO_CACHE提示后，将不使用Query Cache；<br>  3、2(DEMAND)：开启Query Cache 功能，但是只有当SELECT语句中使用了SQL_CACHE 提示后，才使用Query Cache。</p><p>备注1:</p><p>如果query_cache_type为on而又不想利用查询缓存中的数据，可以用下面的SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_NO_CACHE * FROM my_table WHERE condition;</span><br></pre></td></tr></table></figure><p>如果值为2，要使用缓存的话，需要使用SQL_CACHE开关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_CACHE * FROM my_table WHERE condition;</span><br></pre></td></tr></table></figure><p>但是大多情况下，建议不要使用查询缓存，因为查询缓存的失效非常频繁，任意一个表的更新操作，这个表上的所有查询缓存都会被清空了，所以查询缓存的命中率非常低，除非表中基本上只会涉及到查操作而很少更新操作的时候可以考虑使用查询缓存的方式</p><p><strong>Mysql8.0没有查询缓存的功能，已被彻底抛弃</strong></p><h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>往上说的，如果开启了缓存机制的，就在缓存里查，否则就要走分析器了，所谓分析器，就是判断你输入的这条语句到底是什么意思，是要做查操作呢还是更新操作呢，还是语法有错误呢，都是由分析器去做的事情</p><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>经过了分析器，Mysql就知道你要做的是查还是更新还是什么，此时，到优化器，顾名思义，就是如何优化你查的方式</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 join t2 using(ID) where t1.c = 10 and t2.d =20</span><br></pre></td></tr></table></figure><p>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2<br>里面 d 的值是否等于 20。</p><p>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1<br>里面 c 的值是否等于 10。</p><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决<br>定选择使用哪一个方案。</p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>通过分析器，知道要做什么了，通过优化器知道选择什么的方式做了，执行器就是根据上面的两个结论去做，调用InnoDB引擎去取表中的数据</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这就是Mysql的逻辑架构，对一个Sql语句完整执行流程的各个阶段有一个初步的认识</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mysql基本架构示意图&quot;&gt;&lt;a href=&quot;#Mysql基本架构示意图&quot; class=&quot;headerlink&quot; title=&quot;Mysql基本架构示意图&quot;&gt;&lt;/a&gt;Mysql基本架构示意图&lt;/h3&gt;&lt;img src=&quot;/2019/04/09/一条SQL语句的执行过
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Centos搭建git私服</title>
    <link href="http://yoursite.com/2019/03/26/Centos%E6%90%AD%E5%BB%BAgit%E7%A7%81%E6%9C%8D/"/>
    <id>http://yoursite.com/2019/03/26/Centos搭建git私服/</id>
    <published>2019-03-26T12:14:48.000Z</published>
    <updated>2019-04-29T06:04:59.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Centos搭建GIT私服"><a href="#Centos搭建GIT私服" class="headerlink" title="Centos搭建GIT私服"></a>Centos搭建GIT私服</h3><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>Centos默认自带Git</p><p>可以通过以下命令进行查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>默认是1.8</p><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd git</span><br><span class="line">adduser git -g git</span><br><span class="line">password git</span><br></pre></td></tr></table></figure><p>先创建一个用户组</p><p>再在这个用户组里面创建一个用户</p><p>再给用户设置密码</p><h4 id="创建authorized-keys文件"><a href="#创建authorized-keys文件" class="headerlink" title="创建authorized_keys文件"></a>创建authorized_keys文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /home/git</span><br><span class="line">mkdir .ssh</span><br><span class="line">chmod 700 .ssh</span><br><span class="line">touch .ssh/authorized_keys</span><br><span class="line">chmod 600 .ssh/authorized_keys</span><br><span class="line">cd /home</span><br><span class="line">chown -R git:git git</span><br></pre></td></tr></table></figure><p><strong>要注意的是文件权限和所属用户。</strong></p><p><strong>(后续的git clone如果需要密码，很有可能是git用户没有访问authorized_keys文件的权限)</strong></p><h4 id="客户端创建密钥并上传"><a href="#客户端创建密钥并上传" class="headerlink" title="客户端创建密钥并上传"></a>客户端创建密钥并上传</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email&quot;</span><br></pre></td></tr></table></figure><p>该命令会产生两个文件: id_rsa对应私钥，id_rsa.pub对应公钥。</p><p>将id_rsa.pub中的内容写到服务器的authorized_keys文件中。</p><p>如果有多个客户端，那么在authorized_keys文件中，一行保存一个客户端的公钥。</p><h4 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h4><p><strong>为了方便管理，所有的git仓库都置于同一目录下，假设为/home/gitrepo，</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home</span><br><span class="line">mkdir gitrepo</span><br><span class="line">chown git:git gitrepo</span><br></pre></td></tr></table></figure><p>接下来创建git仓库：test.git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd gitrepo</span><br><span class="line">git init --bare test.git</span><br></pre></td></tr></table></figure><p>把仓库所属用户改为git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R git:git test.git</span><br></pre></td></tr></table></figure><p><strong>注意每次新建的仓库，都要修改仓库的所属用户</strong></p><h4 id="git私服搭建完毕"><a href="#git私服搭建完毕" class="headerlink" title="git私服搭建完毕"></a>git私服搭建完毕</h4><p><strong>push 和 clone示例</strong></p><p>打开git bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone git@ip:/home/gitrepo/test.git</span><br><span class="line"></span><br><span class="line">git remote add origin git@ip:/home/gitrepo/test.git</span><br><span class="line">git push -u origin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Centos搭建GIT私服&quot;&gt;&lt;a href=&quot;#Centos搭建GIT私服&quot; class=&quot;headerlink&quot; title=&quot;Centos搭建GIT私服&quot;&gt;&lt;/a&gt;Centos搭建GIT私服&lt;/h3&gt;&lt;h4 id=&quot;安装git&quot;&gt;&lt;a href=&quot;#安装gi
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git-进阶</title>
    <link href="http://yoursite.com/2019/01/31/Git-%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2019/01/31/Git-进阶/</id>
    <published>2019-01-31T13:58:03.000Z</published>
    <updated>2019-04-29T06:06:13.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git进阶"><a href="#Git进阶" class="headerlink" title="Git进阶"></a>Git进阶</h2><h3 id="本地分支管理"><a href="#本地分支管理" class="headerlink" title="本地分支管理"></a>本地分支管理</h3><p>一个项目如果是你一个人开发，那就没什么，反正就一份项目，你想做哪个模块就做哪个模块<br>但是这样子开发效率慢啊</p><p>要是两个人开发，开发效率提高一倍，那么怎么合并起来呢？？？</p><p>如果说两个人做的地方，刚好互不影响，那很简单，学过数学的人都知道，直接合并起来嘛</p><p>问题来了！！！</p><p>如果两个人做的地方有重复怎么办？？？一行一行对比，然后一行行改?还是说一个人做完再让另外一个人做？那这和一个人做有什么区别</p><p>这就太麻烦了</p><p>所以引入了分支管理！这是个好东西</p><img src="/2019/01/31/Git-进阶/01.PNG"><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>根据上图我们可以知道，我们首先是有一个主干的(称为master分支)</p><p>我们每次提交，会多一个新的节点</p><img src="/2019/01/31/Git-进阶/02.png"><p>提交越多，master分支也会边长</p><p>创建分支的代码：(新的分支名字为dev)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br></pre></td></tr></table></figure><img src="/2019/01/31/Git-进阶/03.png"><p>我们可以看到一个*标记在master，这代表着我们操控着master分支<br>假设我们要切换分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>(我们也有一个更加方便的代码，创建分支同时切换到该分支上)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><p>接下来，我们执行一次提交</p><img src="/2019/01/31/Git-进阶/04.png"><p>然后我又返回到master里再提交一次</p><img src="/2019/01/31/Git-进阶/05.png"><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>首先切换到master分支<br>将dev分支合并到master分支下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><img src="/2019/01/31/Git-进阶/06.png"><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><img src="/2019/01/31/Git-进阶/07.png"><h3 id="GitHub上实现分支管理"><a href="#GitHub上实现分支管理" class="headerlink" title="GitHub上实现分支管理"></a>GitHub上实现分支管理</h3><p>上面说这么多，其实为了熟悉一下命令，还有通过一些图来表明，每个操作，到底发生了什么</p><p>接下来才是实际开发中会用到的，结合GitHub上讲解</p><p>首先我拉取一下我Github，我仓库里只有一个A.txt,里面有句Hello</p><p>我新建两个文件夹用来模拟两台电脑</p><img src="/2019/01/31/Git-进阶/08.png"><p><strong> 接着做如下操作 </strong></p><img src="/2019/01/31/Git-进阶/09.png"><img src="/2019/01/31/Git-进阶/10.png"><p>然后把文件都添加到本地仓库中</p><p>接着在Git2里推送到github上的分支下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">git push -u origin dev</span><br></pre></td></tr></table></figure></p><p>这样子在Github上就有分支了</p><p>接着Git去上传自己的到github的master下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>在创建一个文件夹Git3</p><p>分别把两个分支拉下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone 路径</span><br><span class="line">进入仓库</span><br><span class="line">git checkout dev </span><br><span class="line">git clone -b dev(分支名) 路径</span><br><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git进阶&quot;&gt;&lt;a href=&quot;#Git进阶&quot; class=&quot;headerlink&quot; title=&quot;Git进阶&quot;&gt;&lt;/a&gt;Git进阶&lt;/h2&gt;&lt;h3 id=&quot;本地分支管理&quot;&gt;&lt;a href=&quot;#本地分支管理&quot; class=&quot;headerlink&quot; title=&quot;本
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git入门</title>
    <link href="http://yoursite.com/2019/01/13/Git%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/01/13/Git入门/</id>
    <published>2019-01-12T16:13:30.000Z</published>
    <updated>2019-04-29T06:06:11.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制器："><a href="#版本控制器：" class="headerlink" title="版本控制器："></a>版本控制器：</h2><p>首先了解Git之前要明白另外一样东西，那就是版本控制系统</p><p>什么叫版本控制系统呢？</p><p><strong>版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。</strong></p><p>程序员写代码，学会一种版本控制器是必不可少的技能</p><p>写代码，少不了的就是不断的修改源代码，但是代码是一种很神奇的东西，你会发现，原本只有一个BUG的改着改着<br>突然发现BUG数量不仅仅没有减少而且还增加，此时的心里感受，哈哈，应该要吐血，那么怎么办？我原来的代码也被我改掉了<br>说白了就是已经没有的备份，那就凉了~</p><p>好的，小白曾经是这么干的，比如说，出现BUG吗，那我要修改，修改之前，先拷贝一份现在的源文件，然后再去改，这样子就稳了</p><p>当然小白一开始做得还是很开心的，因为很简单啊，写的代码也不多，而且往往只是一个文件，随着小白的进步当中，代码往往牵涉<br>到多个文件的修改，这样子也是可以ctrl+c和ctrl+v的，但是一是一个文件夹里密密麻麻的项目，二是，看着一堆副本一副本二，简直就是头疼啊！！！</p><p>好啦，现在开始讲我们的版本控制器了</p><p>简单来说呢，版本控制器就是可以更加方便地对我们的代码进行管理</p><p>进入正题：</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git:"></a>Git:</h2><p>Git：分布式版本控制系统</p><p>那么有分布式那么就会有集中式，没错！</p><p>SVN就是集中式版本控制系统，本章不做介绍</p><p>Git很火的呢，怎么说，GitHub就是基于Git的基础上的</p><p>至于分布式版本系统控制系统和集中式版本控制系统，等我把Git和SVN讲解完再进行一个比较</p><h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>Git的安装可以参考官网<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>直接下载后安装后就可以了，很简单</p><p>安装后在开始菜单中找到Git Bash<br>鼠标右键也会有</p><h2 id="Git的入门"><a href="#Git的入门" class="headerlink" title="Git的入门"></a>Git的入门</h2><p>我首先创建了一个文件夹，专门进行讲解<br>文件夹名字为Git，首先创建一个文件，名字为a.txt，内容为AAA</p><p>接下来进行提交</p><p>在文件夹里面右键 git Bash</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先我们要初始化一个仓库，这个仓库是放在我们本机的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>默认为隐藏的，要设置查看隐藏文件就可以看得到多了一个文件夹</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>将文件添加到仓库里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add a.txt</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>将文件提交到仓库里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;version 1.0&quot;</span><br></pre></td></tr></table></figure><p>-m后面是本次提交的一个说明，就是提交的是什么东西(原则上可以省略，但是建议不要)</p><h3 id="git-add-和-git-commit的区别"><a href="#git-add-和-git-commit的区别" class="headerlink" title="git add 和 git commit的区别"></a>git add 和 git commit的区别</h3><p>首先git add添加自己指定的文件<br>git commit不可以，一次性将所有提交，不可指定文件</p><p><strong>git add是先将文件添加到暂存区，git commit将暂存区里的文件一次性提交到仓库里！！！</strong></p><p>基本上简单的一个Git流程的上传部分就介绍完了</p><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p>既然前面我们讲完了如何将文件上传到自己的仓库，那么我们现在要用到的情况下，怎么从仓库下载下来呢？？？</p><p>现在为了模仿以下真实环境</p><p>我进行多了两次提交</p><p>第一次提交之前，在a.txt增加了一行BBB</p><p>第二次提交之前，在a.txt增加了一行CCC</p><p>接下来我们就要去查看记录了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><img src="/2019/01/13/Git入门/1.png"><p>当前TXT是这样子的<br><img src="/2019/01/13/Git入门/2.png"></p><p>现在要恢复啦！！！<br><strong>见证奇迹的时刻——-</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>再打开文本，发现已经恢复了，用git log去查看的时候发现也确实少了一条记录<br>HEAD代表的是当前版本<br>HEAD^代表的是当前版本的上一个版本<br>HEAD^^代表的是上上版本</p><p>HEAD~N 代表的是当前邦本的上N个版本</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>GitHub是提供Git仓库托管服务的,所以首先要有一个GitHub账号</p><p>自行注册GitHub的账号，这个问题，不在这里描述了</p><p>其次注册完账号还有做一些事情</p><p>先创建一个SSH KEY</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>在C盘本地账号下有一个文件夹.ssh</p><p>里面有两个文件，分别是id_rsa.pub 和 id_rsa<br>分别对应着公钥和私钥</p><p>登陆GitHub，打开Settings里有一个选项，SSH and GPG keys<br>添加自己机子的公钥</p><p>因为Git支持SSH协议，所以添加了SSH KEY之后可以防止别人冒充来对我们的仓库进行恶意修改</p><h3 id="添加文件到GitHub"><a href="#添加文件到GitHub" class="headerlink" title="添加文件到GitHub"></a>添加文件到GitHub</h3><p>首先在GitHub里面创建一个Repository</p><p>比如说我创建了一个gitTest</p><p>然后回到git Bash<br>添加远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:用户名/仓库名字.git</span><br></pre></td></tr></table></figure></p><p>那么对应删除远程仓库的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></p><p>现在我们添加成功之后，接下来就是要上传到远程仓库里面去了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>接着去刷新我们的仓库，发现文件已经提交上去了</p><h3 id="GitHub上下载文件"><a href="#GitHub上下载文件" class="headerlink" title="GitHub上下载文件"></a>GitHub上下载文件</h3><p>这个也很简单对应着一条命令就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:用户名/仓库名字.git</span><br></pre></td></tr></table></figure><p>好了，本章对Git的介绍就讲到这里，这里只是入门，后面会有一些更加多的内容介绍，敬请关注~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;版本控制器：&quot;&gt;&lt;a href=&quot;#版本控制器：&quot; class=&quot;headerlink&quot; title=&quot;版本控制器：&quot;&gt;&lt;/a&gt;版本控制器：&lt;/h2&gt;&lt;p&gt;首先了解Git之前要明白另外一样东西，那就是版本控制系统&lt;/p&gt;
&lt;p&gt;什么叫版本控制系统呢？&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Python爬取网易云音乐</title>
    <link href="http://yoursite.com/2019/01/12/Python%E7%88%AC%E5%8F%96%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    <id>http://yoursite.com/2019/01/12/Python爬取网易云音乐/</id>
    <published>2019-01-12T10:20:26.000Z</published>
    <updated>2019-04-29T06:05:41.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python爬取网易云音乐"><a href="#Python爬取网易云音乐" class="headerlink" title="Python爬取网易云音乐"></a><em>Python爬取网易云音乐</em></h2><p>首先放网址：</p><p><a href="https://music.163.com/" target="_blank" rel="noopener">https://music.163.com/</a></p><p>通过Network我们可以找到我们的音乐url存放的位置</p><img src="/2019/01/12/Python爬取网易云音乐/1.png"><p>那么我们就简单啦，知道Ajax的请求页面，我们当然就可以直接爬取了，但是：</p><img src="/2019/01/12/Python爬取网易云音乐/2.png"><p>这个FormData好像不简单，那我怎么请求呢？</p><p>第一直觉，就感觉是被加密了，不愧是网易云，有一套呢</p><img src="/2019/01/12/Python爬取网易云音乐/3.png"><p>那么肯定就是和JS脱离不了关系了，找到JS，然后保存到本地进行分析一下</p><img src="/2019/01/12/Python爬取网易云音乐/4.png"><p>把代码保存到本地，进行一些操作</p><img src="/2019/01/12/Python爬取网易云音乐/5.png"><p>加密用到了四个参数，那么我们可以打印一下这四个参数</p><p>那么问题来了，这JS文件在我的本地，我怎么让网站进行加载呢？</p><p>对的，这里要运用到一个工具，Fiddler4</p><p>这是个什么东西呢</p><p>它能够记录并检查所有你的电脑和互联网之间的Http通讯，设置断点，查看所有的进出Fiddler的数据（cookie,html,css,js）</p><p>大概就是，在客户端和服务器之间创建一个代理服务器来对之间进行交互通讯信息进行监控</p><p>下载安装完成之后还要对Fiddler4进行配置：</p><p>Tools—》Options</p><img src="/2019/01/12/Python爬取网易云音乐/6.png"><img src="/2019/01/12/Python爬取网易云音乐/7.png"><p>更详细的介绍，这里就不多说了</p><p>那么大概界面是这样的</p><img src="/2019/01/12/Python爬取网易云音乐/8.png"><p>接着我们打开网易云官网</p><img src="/2019/01/12/Python爬取网易云音乐/9.png"><p>把core.js拖拉都右边，钩上相应的选项，在最下面找到要替换的JS，最后点击一下save</p><p>就能发现上面的路径变了，上图是我已经替换好的了</p><p>接下来：在网易云上搜索一首歌，打开控制台</p><p>你会发现，居然这样子了：</p><img src="/2019/01/12/Python爬取网易云音乐/10.png"><p>打印成功了！</p><p>再看XHR里面</p><img src="/2019/01/12/Python爬取网易云音乐/11.png"><p>我们的重点是url这个，所以我们只用关注第一个打印的，显然ids就是歌曲的序号</p><p>多试几组可以看出来一个问题就是：</p><p>后三个参数是不用管的</p><p>那么歌曲的序号又要怎么获取呢？最终找到的结果是在</p><img src="/2019/01/12/Python爬取网易云音乐/12.png"><p>然而这个页面也是加密的，很强，没事</p><p>我们再看看后台打印的东西</p><img src="/2019/01/12/Python爬取网易云音乐/13.png"><p>span class = “s-fc7”又是什么东西呢？</p><p>经过测试，发现这是固定的值</p><p>整个Json不同的地方在于s，传入歌名就可以了</p><p>呼</p><p>offset是偏移量，与翻页数有关系</p><p>好了，接下来又得去看我们的JS代码，去分析加密过程了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function a(a) &#123;</span><br><span class="line">        var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;</span><br><span class="line">        for (d = 0; a &gt; d; d += 1)</span><br><span class="line">            e = Math.random() * b.length,</span><br><span class="line">            e = Math.floor(e),</span><br><span class="line">            c += b.charAt(e);</span><br><span class="line">        return c</span><br><span class="line">    &#125;</span><br><span class="line">    function b(a, b) &#123;</span><br><span class="line">        var c = CryptoJS.enc.Utf8.parse(b)</span><br><span class="line">          , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)</span><br><span class="line">          , e = CryptoJS.enc.Utf8.parse(a)</span><br><span class="line">          , f = CryptoJS.AES.encrypt(e, c, &#123;</span><br><span class="line">            iv: d,</span><br><span class="line">            mode: CryptoJS.mode.CBC</span><br><span class="line">        &#125;);</span><br><span class="line">        return f.toString()</span><br><span class="line">    &#125;</span><br><span class="line">    function c(a, b, c) &#123;</span><br><span class="line">        var d, e;</span><br><span class="line">        return setMaxDigits(131),</span><br><span class="line">        d = new RSAKeyPair(b,&quot;&quot;,c),</span><br><span class="line">        e = encryptedString(d, a)</span><br><span class="line">    &#125;</span><br><span class="line">    function d(d, e, f, g) &#123;</span><br><span class="line">        var h = &#123;&#125;</span><br><span class="line">          , i = a(16);</span><br><span class="line">        return h.encText = b(d, g),</span><br><span class="line">        h.encText = b(h.encText, i),</span><br><span class="line">        h.encSecKey = c(i, e, f),</span><br><span class="line">        h</span><br><span class="line">    &#125;</span><br><span class="line">    function e(a, b, d, e) &#123;</span><br><span class="line">        var f = &#123;&#125;;</span><br><span class="line">        return f.encText = c(a + e, b, d),</span><br><span class="line">        f</span><br><span class="line">    &#125;</span><br><span class="line">    window.asrsea = d</span><br></pre></td></tr></table></figure><p>首先看函数d</p><p>函数d首先有个i，这个i是一个随机的十六位字符串，</p><p>然后进行了两次加密，第一次是第一个参数和第四个参数进行加密，把结果返回出来后与i字符串进行第二次加密，这个encText就是我们的params</p><p>而通过我们的刚才打印结果来看，后三个参数是固定的，然而i是随机的，也就是我们可以固定一个参数（一个最不可能的坑你，就是每次随机刚好就是随机到我的字符串），也就是说h.encSecKey=c(i,e,f)也是固定的，那也没什么好看的了</p><p>最主要的还是我们的params参数的第一次加密，因为第二次加密是在第一次加密的结果和一个固定的字符串，所以也没有讨论的必要了</p><p>首先看看我们的加密算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#AES加密算法</span><br><span class="line">def AES_encrypt(text, key, iv):</span><br><span class="line">    pad = 16 - len(text) % 16</span><br><span class="line">    if type(text)==type(b&apos;&apos;):</span><br><span class="line">        text = str(text, encoding=&apos;utf-8&apos;)</span><br><span class="line">    text = text + pad * chr(pad)</span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    encrypt_text = encryptor.encrypt(text)</span><br><span class="line">    encrypt_text = base64.b64encode(encrypt_text)</span><br><span class="line">    return encrypt_text</span><br></pre></td></tr></table></figure><p>这里，要安装一下Crypto模块，不然会报错，模块找不到</p><p>接下来就是源代码了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import requests</span><br><span class="line">import base64</span><br><span class="line">import os</span><br><span class="line">import codecs</span><br><span class="line">import json</span><br><span class="line">from pypinyin import  lazy_pinyin</span><br><span class="line">from urllib.request import urlretrieve</span><br><span class="line"># 后三个参数和i的值（随机的十六位字符串）</span><br><span class="line">b = &apos;010001&apos;</span><br><span class="line">c = &apos;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&apos;</span><br><span class="line">d = &apos;0CoJUm6Qyw8W8jud&apos;</span><br><span class="line">#随机的十六位字符串</span><br><span class="line">def createSecretKey(size):</span><br><span class="line">return (&apos;&apos;.join(map(lambda xx: (hex(ord(xx))[2:]), str(os.urandom(size)))))[0:16]</span><br><span class="line">#AES加密算法</span><br><span class="line">def AES_encrypt(text, key, iv):</span><br><span class="line">    pad = 16 - len(text) % 16</span><br><span class="line">    if type(text)==type(b&apos;&apos;):</span><br><span class="line">        text = str(text, encoding=&apos;utf-8&apos;)</span><br><span class="line">    text = text + str(pad * chr(pad))</span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    encrypt_text = encryptor.encrypt(text)</span><br><span class="line">    encrypt_text = base64.b64encode(encrypt_text)</span><br><span class="line">    return encrypt_text</span><br><span class="line">#得到第一个加密参数</span><br><span class="line">def Getparams(a,SecretKey):</span><br><span class="line">    #0102030405060708是偏移量，固定值</span><br><span class="line">    iv = &apos;0102030405060708&apos;</span><br><span class="line">    h_encText = AES_encrypt(a,d,iv)</span><br><span class="line">    h_encText = AES_encrypt(h_encText,SecretKey,iv)</span><br><span class="line">    return h_encText</span><br><span class="line">#得到第二个加密参数</span><br><span class="line">def GetSecKey(text, pubKey, modulus):</span><br><span class="line">    text = text[::-1]</span><br><span class="line">    rs = int(codecs.encode(text.encode(&apos;utf-8&apos;), &apos;hex_codec&apos;), 16) ** int(pubKey, 16) % int(modulus, 16)</span><br><span class="line">    return format(rs, &apos;x&apos;).zfill(256)</span><br><span class="line">#得到表单的两个参数</span><br><span class="line">def GetFormData(a):</span><br><span class="line">    SecretKey = createSecretKey(16)</span><br><span class="line">    params = Getparams(a,SecretKey)</span><br><span class="line">    enSecKey = GetSecKey(SecretKey,b,c)</span><br><span class="line">    data = &#123;</span><br><span class="line">&quot;params&quot;:str(params,encoding=&apos;utf-8&apos;),</span><br><span class="line">&quot;encSecKey&quot;:enSecKey</span><br><span class="line">&#125;</span><br><span class="line">    return data</span><br><span class="line">def getOnePatam():</span><br><span class="line">    # 查询id的url</span><br><span class="line">    url = &apos;https://music.163.com/weapi/cloudsearch/get/web?csrf_token=&apos;</span><br><span class="line">    #伪装头部</span><br><span class="line">    head = &#123;</span><br><span class="line">        &apos;Host&apos;: &apos;music.163.com&apos;,</span><br><span class="line">        &apos;Origin&apos;:&apos;https://music.163.com&apos;,</span><br><span class="line">        &apos;Referer&apos;:&apos;https://music.163.com/search/&apos;,</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;输入你想要下载的歌手&quot;)</span><br><span class="line">    song_name = input()</span><br><span class="line">    #第一个参数</span><br><span class="line">    song_name = &apos;&apos;.join(lazy_pinyin(song_name))</span><br><span class="line">    key = &apos;&#123;hlpretag:&quot;&quot;,hlposttag:&quot;&lt;/span&gt;&quot;,s:&quot;&apos;+song_name+&apos;&quot;,type:&quot;1&quot;,csrf_token:&quot;&quot;,limit:&quot;30&quot;,total:&quot;true&quot;,offset:&quot;0&quot;&#125;&apos;</span><br><span class="line">    FormData = GetFormData(key)</span><br><span class="line">    html = requests.post(url,headers=head,data=FormData)</span><br><span class="line">    result = json.loads(html.text)</span><br><span class="line">    return result[&apos;result&apos;][&apos;songs&apos;]</span><br><span class="line">#下载器：</span><br><span class="line">def download(name,id):</span><br><span class="line">    # 获取歌曲的url的路径</span><br><span class="line">    song_url = &quot;https://music.163.com/weapi/song/enhance/player/url?csrf_token=&quot;</span><br><span class="line">    # 伪装头部</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &apos;Host&apos;: &apos;music.163.com&apos;,</span><br><span class="line">        &apos;Origin&apos;: &apos;https://music.163.com&apos;,</span><br><span class="line">        &apos;Referer&apos;: &apos;https://music.163.com/&apos;,</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    # 把上个页面查询到的id放到第二个页面的第一个参数上</span><br><span class="line">    a =str(&#123;&apos;ids&apos;: &quot;[&quot;+str(id)+&quot;]&quot;, &apos;br&apos;: 320000, &apos;csrf_token&apos;: &quot;&quot;&#125;)</span><br><span class="line">    FormData = GetFormData(a)</span><br><span class="line">    response = requests.post(song_url,data = FormData,headers=headers)</span><br><span class="line">    json_dict = json.loads(response.content)</span><br><span class="line">    song_url=json_dict[&apos;data&apos;][0][&apos;url&apos;]</span><br><span class="line">    print(song_url)</span><br><span class="line">    folder = os.path.exists(&apos;songs&apos;)</span><br><span class="line">    if not folder:</span><br><span class="line">        os.makedirs(&apos;songs&apos;)</span><br><span class="line">    path = os.path.join(&apos;songs&apos;,name+&quot;.mp3&quot;)</span><br><span class="line">    urlretrieve(song_url,filename=path)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    song_list = getOnePatam()</span><br><span class="line">    for i in song_list:</span><br><span class="line">        name = i[&apos;name&apos;]</span><br><span class="line">        id = i[&apos;id&apos;]</span><br><span class="line">        download(name,id)</span><br></pre></td></tr></table></figure><p>以下是效果图</p><img src="/2019/01/12/Python爬取网易云音乐/14.png"><p>这次程序重点的是对加密的网页，学会如何去处理</p><p>有一点要强调一下，因为如果是中文，会导致加密的时候字符串长度不匹配的问题，所以只能用拼音，所以这里加了一个中文转拼音的库，pypinyin的lazy_pinyin()的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python爬取网易云音乐&quot;&gt;&lt;a href=&quot;#Python爬取网易云音乐&quot; class=&quot;headerlink&quot; title=&quot;Python爬取网易云音乐&quot;&gt;&lt;/a&gt;&lt;em&gt;Python爬取网易云音乐&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;首先放网址：&lt;/p&gt;
&lt;p&gt;&lt;a 
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Solr集群版的搭建</title>
    <link href="http://yoursite.com/2019/01/10/Solr%E9%9B%86%E7%BE%A4%E7%89%88%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/01/10/Solr集群版的搭建/</id>
    <published>2019-01-10T10:35:59.000Z</published>
    <updated>2019-04-29T06:05:16.131Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Solr集群版的搭建"><a href="#Solr集群版的搭建" class="headerlink" title="Solr集群版的搭建"></a>Solr集群版的搭建</h3><p>搭建Solr集群</p><p>首选需要配置zookeeper集群</p><p>先搭建四个tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat01</span><br><span class="line">cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat02</span><br><span class="line">cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat03</span><br><span class="line">cp -r apache-tomcat-7.0.47 /home/quan/app/solr-cloud/tomcat04</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim tomcat01/conf/server.xml</span><br><span class="line">vim tomcat02/conf/server.xml</span><br><span class="line">vim tomcat03/conf/server.xml</span><br><span class="line">vim tomcat04/conf/server.xml</span><br></pre></td></tr></table></figure><p>给不同的Tomcat修改端口，tomcat01为81，tomcat02为82,以此类推，主要修改以下三个地方</p><p>把单机版的Solr放到Tomcat下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp -r solr /home/app/solr-cloud/tomcat01/webapps/</span><br><span class="line">cp -r solr /home/app/solr-cloud/tomcat02/webapps/</span><br><span class="line">cp -r solr /home/app/solr-cloud/tomcat03/webapps/</span><br><span class="line">cp -r solr /home/app/solr-cloud/tomcat04/webapps/</span><br></pre></td></tr></table></figure><p>再复制四个solrhome到solr-cloud目录下</p><p>再修改每个solrhome下的solr.xml</p><p>注意写自己的端口号和IP地址</p><p>修改每个tomcat的solr的web.xml</p><p>修改catalina文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim tomcat01/bin/catalina.sh</span><br><span class="line">vim tomcat02/bin/catalina.sh</span><br><span class="line">vim tomcat03/bin/catalina.sh</span><br><span class="line">vim tomcat04/bin/catalina.sh</span><br></pre></td></tr></table></figure><p>tomcat运行catalinda.sh脚本命令</p><p>配置JAVA_OPTS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=&quot;-DzkHost=192.168.25.130:2181,192.168.25.130:2182,192.168.25.130:2183&quot;</span><br></pre></td></tr></table></figure><p>在solr文件下的example目录下的script目下的cloud-scripts目录下有个zkcli.sh</p><p>上传配置文件至zookeeper的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkcli.sh -zkhost 192.168.25.130:2181,192.168.25.130:2182,192.168.25.130:2183 -cmd upconfig -confdir /home/quan/app/solr-cloud/solrhome01/collection1/conf/ -confname myconf</span><br></pre></td></tr></table></figure><p>进入solr-cloud的zookeeper01中的bin目录下进行连接zookeeper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkCli.sh -server 192.168.25.130:2182</span><br></pre></td></tr></table></figure><p>检查一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkCli.sh -server 192.168.25.130:2182</span><br></pre></td></tr></table></figure><p>myconf就是我们上传的</p><p>内容里面有我们上传的solr文件</p><p>整个搭建就完成了</p><p>开启四个Tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/quan/app/solr-cloud/tomcat01/bin/startup.sh</span><br><span class="line">/home/quan/app/solr-cloud/tomcat02/bin/startup.sh</span><br><span class="line">/home/quan/app/solr-cloud/tomcat03/bin/startup.sh</span><br><span class="line">/home/quan/app/solr-cloud/tomcat04/bin/startup.sh</span><br></pre></td></tr></table></figure><p>SolrCloud创建Collection的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.25.130:8180/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;relicationFactor=2</span><br></pre></td></tr></table></figure><p>SolrCloud删除Collection的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.25.130:8180/solr/admin/collections?action=DELETE&amp;name=collection1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Solr集群版的搭建&quot;&gt;&lt;a href=&quot;#Solr集群版的搭建&quot; class=&quot;headerlink&quot; title=&quot;Solr集群版的搭建&quot;&gt;&lt;/a&gt;Solr集群版的搭建&lt;/h3&gt;&lt;p&gt;搭建Solr集群&lt;/p&gt;
&lt;p&gt;首选需要配置zookeeper集群&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Solr" scheme="http://yoursite.com/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例</title>
    <link href="http://yoursite.com/2019/01/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/01/07/设计模式-单例/</id>
    <published>2019-01-06T23:52:39.000Z</published>
    <updated>2019-04-29T06:05:12.010Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p><p>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><p>说白了就是：就是使用设计模式，代码会更好。</p><p>单例模式：就是单个实例</p><p>那么单例模式有什么好处呢？</p><p>很简单，首先，都是单个实例了，那么就可以怎样</p><p>一、实例控制</p><p>单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。</p><p>二、灵活性</p><p>因为类控制了实例化过程，所以类可以灵活更改实例化过程。</p><p>但是还是有缺点的：</p><p>一、开销</p><p>虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。</p><p>二、可能的开发混淆</p><p>使用单例对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用new关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。</p><p>三、对象生存期</p><p>不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于.NET Framework的语言），只有单例类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如 C++），其他类可以删除对象实例，但这样会导致单例类中出现悬浮引用。。</p><p><strong>单例模式根据实例化对象时机的不同分为两种</strong></p><p><strong>饿汉式</strong></p><p>上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Single&#123;</span><br><span class="line">/*私有化，防止外部创建实例*/</span><br><span class="line">private Single&#123;&#125;</span><br><span class="line">/*设置静态属性私有，防止外部通过类名访问*/</span><br><span class="line">private static Single single = new Single();</span><br><span class="line">/*设置静态方法*/</span><br><span class="line">public static Single getInstance()&#123;</span><br><span class="line">return single;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很简单的</p><p>上面有个问题，当类加载的时候，就会实例化Single（），假如我加载完类，一段时间没用，而实例却已经早就创建了，着就会造成一个浪费。</p><p>通过这个问题，我们可以想，当我们需要实例的时候我们才去实例化，而不是通过类加载，那么我们可以这样子做</p><p><strong>懒汉式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Single&#123;</span><br><span class="line">/*私有化，防止外部创建实例*/</span><br><span class="line">private Single&#123;&#125;</span><br><span class="line">/*设置静态属性私有,先设空，需要的时候再实例化*/</span><br><span class="line">private static Single single=null;</span><br><span class="line">/*设置静态方法*/</span><br><span class="line">public static Single getInstance()&#123;</span><br><span class="line">if(single==null)&#123;</span><br><span class="line">single = new Single()</span><br><span class="line">&#125;</span><br><span class="line">return single</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子，就没什么问题了</p><p>但是现在再思考一个问题，万一是多线程的时候呢？这样就有问题的了</p><p>这样子我们就需要加一个锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Single&#123;</span><br><span class="line">/*私有化，防止外部创建实例*/</span><br><span class="line">private Single&#123;&#125;</span><br><span class="line">/*设置静态属性私有,先设空，需要的时候再实例化*/</span><br><span class="line">private static Single single=null;</span><br><span class="line">/*设置静态方法*/</span><br><span class="line">public static Single getInstance()&#123;</span><br><span class="line">/*两重判空是为了提高效率*/</span><br><span class="line">if(single==null)&#123;</span><br><span class="line">/*上锁*/</span><br><span class="line">synchronized(Single.Class)&#123;</span><br><span class="line">if (single==null) &#123;</span><br><span class="line">single = new Single()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return single;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子整个单例模式就做得比较好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。&lt;/p&gt;
&lt;p&gt;使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java线程</title>
    <link href="http://yoursite.com/2018/12/29/Java%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/29/Java线程/</id>
    <published>2018-12-28T19:56:18.000Z</published>
    <updated>2019-04-29T06:06:02.449Z</updated>
    
    <content type="html"><![CDATA[<p>什么是线程？</p><p>线程是一个程序里的不同执行路径</p><p>一般的程序是从一个入口出发，沿着唯一的路径走到终点，而线程则使唯一的路径变成多条路径</p><p>以下是单线程操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">aa.run();</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello JAVA&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为aa.run没有执行完毕，下面的while循环就不会执行，所以就是一直输出“hello world“<br>再看看多线程操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">aa.start();</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello JAVA&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread中的start方法就是创建一个线程，并且自动调用run方法，直接调用run方法是不会创建一个线程的。<br>执行一个线程，其实就是执行一个线程里面的run方法，一个Thread对象不能调用两次start方法，否则会抛出异常。<br>把aa.run改成aa.start结果就是两个循环交替执行，这就是多线程。<br>单线程就是一条路径，从头到尾执行。<br>多线程就是有多条路径，每次都可以走不同的路径。</strong></p><img src="/2018/12/29/Java线程/1.png"><p><strong>执行aa.start并不代表aa对象的线程就立刻执行，而是得到了能够被CPU执行的资格，也就是就绪的状态。<br>创建线程的第二种方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread2 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">Thread th=new Thread(aa);</span><br><span class="line">th.start();</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello JAVA&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread常用方法：</p><p>setName（String）设置名字</p><p>currentThread（）返回正在执行线程的对象</p><p>getName（）返回线程的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 </span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">        A aa=new A();</span><br><span class="line">        aa.start();</span><br><span class="line">        System.out.println(&quot;hello JAVA&quot;);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;);</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">aa.setName(&quot;123&quot;);</span><br><span class="line">aa.start();</span><br><span class="line">System.out.println(&quot;hello JAVA&quot;);</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread的sleep方法<br>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<br>要捕获异常！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">try&#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">aa.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread的join方法：如a.join（）；暂停当前正在执行的线程，直到a的线程运行终止之后当前线程才有机会得到执行，注意：不是暂停a对象的线程，而是当前运行的线程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">aa.start();</span><br><span class="line">try&#123;</span><br><span class="line">aa.join();</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>**<br>Thread的优先级：</p><p>getPriority:获取优先级</p><p>setPriority:设置优先级</p><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。</p><p>线程调度器用数字表现，范围从一到十，一个线程默认是5。</p><p>通常优先级高的比优先级低的要先执行，但并不是一定的！因为实际开发中并不单纯依赖优先级来决定优先级的运行顺序**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class A implements Runnable&#123;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;10;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;A&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B implements Runnable&#123;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;10;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;B&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread3 &#123;</span><br><span class="line">    public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">        Thread t1=new Thread(new A());</span><br><span class="line">        Thread t2=new Thread(new B());</span><br><span class="line">        t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优先级越高！越容易被CPU先调用！</strong></p><h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a><strong>线程的同步</strong></h2><p>卖票系统！</p><p>假如有三个地方，A,B,C同时卖票</p><p>假如代码写成这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(票数大于0)</span><br><span class="line">&#123;</span><br><span class="line">买票</span><br><span class="line">票数-1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当A发现票大于0的时候，本应该执行下一步，假如此时CPU切换的B线程的时候，发现票数大于0（因为在A线程里面，票数没有减一），当在B中发现票数大于0之后，假如CPU又切换到C线程里面，发现票数还是大于0（同理）假如票只有一张，那么此时就相当于一张票被卖了三次。<br>这将产生错误！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">private int tickets=100;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">if(tickets&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;);</span><br><span class="line">tickets--;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread4 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A a=new A();</span><br><span class="line">Thread t1=new Thread(a);</span><br><span class="line">t1.start();</span><br><span class="line">A b=new A();</span><br><span class="line">Thread t2=new Thread(b);</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果：</p><img src="/2018/12/29/Java线程/2.png"><p>每张票都被卖出去两次！！！这是不合理的</p><p>导致这个的原因是a对象和b对象都有一个属于自己的tickets 100</p><p>那么接下来看以下程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">static int tickets=100;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">if(tickets&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;);</span><br><span class="line">tickets--;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread4 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A a=new A();</span><br><span class="line">Thread t1=new Thread(a);</span><br><span class="line">t1.start();</span><br><span class="line">A b=new A();</span><br><span class="line">Thread t2=new Thread(b);</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把票数改成静态的<br>结果是这样的：</p><img src="/2018/12/29/Java线程/3.png"><p>那么来分析一下这个结果是为什么，当Thread-0发现票数是100的时候执行卖出操作，然后立刻切换的线程1然后发现还是100但是没有执行卖出操作又转换为线程0，此时减一然后就变成99、98、97、96、95、这个时候立刻切换成线程1执行卖出操作，打印出来。</p><h4 id="简单来说：CPU会在线程之间来回切换！"><a href="#简单来说：CPU会在线程之间来回切换！" class="headerlink" title="简单来说：CPU会在线程之间来回切换！"></a>简单来说：CPU会在线程之间来回切换！</h4><h3 id="好的，重点来了！"><a href="#好的，重点来了！" class="headerlink" title="好的，重点来了！"></a>好的，重点来了！</h3><h2 id="Synchronized—同步"><a href="#Synchronized—同步" class="headerlink" title="Synchronized—同步"></a>Synchronized—同步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">static int tickets=100;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">synchronized(this)</span><br><span class="line">&#123;</span><br><span class="line">if(tickets&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;);</span><br><span class="line">tickets--;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread4 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A a=new A();</span><br><span class="line">Thread t1=new Thread(a);</span><br><span class="line">Thread t2=new Thread(a);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="/2018/12/29/Java线程/4.png"></p><p><strong>synchronized 关键字，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。它包括两种用法：synchronized 方法和 synchronized 块。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是线程？&lt;/p&gt;
&lt;p&gt;线程是一个程序里的不同执行路径&lt;/p&gt;
&lt;p&gt;一般的程序是从一个入口出发，沿着唯一的路径走到终点，而线程则使唯一的路径变成多条路径&lt;/p&gt;
&lt;p&gt;以下是单线程操作&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>PHP手动搭建环境</title>
    <link href="http://yoursite.com/2018/12/29/PHP%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/12/29/PHP手动搭建环境/</id>
    <published>2018-12-28T19:23:13.000Z</published>
    <updated>2019-04-29T06:06:33.457Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/29/PHP手动搭建环境/1.jpg"><h4 id="php环境手动搭建"><a href="#php环境手动搭建" class="headerlink" title="php环境手动搭建"></a>php环境手动搭建</h4><p>php下载路径<br><a href="https://windows.php.net/download" target="_blank" rel="noopener">https://windows.php.net/download</a><br>（注意一点的是要下线程安全的Thread Safe）</p><p>Apache下载路径<br><a href="http://httpd.apache.org/docs/current/platform/windows.html" target="_blank" rel="noopener">http://httpd.apache.org/docs/current/platform/windows.html</a></p><p>Mysql下载路径<br><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p><p>Apache的安装</p><p><strong>这里注意，请先把你的Apache的目录放置好再进行安装，否则安装后再移动位置，会出问题</strong><br>进入Apache目录下的conf目录修改httpd.conf<br>大概在38行附近修改成如下：<br>路径使用自己Apache的安装位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Define SRVROOT &quot;E:\Apache24&quot; </span><br><span class="line">ServerRoot &quot;$&#123;SRVROOT&#125;&quot;</span><br></pre></td></tr></table></figure></p><p>用管理员模式开启CMD<br>进入Apache的bin目录下 命令行httpd -k install进行安装<br>可以使用httpd -t进行测试，是否安装成功</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果失败，导致原因有可能是：</p><ol><li>端口被占用<br> 解决办法：<br> netstat -aon | findstr :80<br> 查看端口是否正在被监听，如果被监听了，有两种方法<pre><code>1. 修改Apache的端口，打开Apache的conf目录下修改httpd.conf,查找Listen关键字 找到 Listen 80 修改到你想设置的端口即可2. 停止正在监听的服务，打开资源管理器，找到对应的PID，停止运行</code></pre></li></ol><p>这里默认上面三个已经下载好而且已经安装好了</p><p>正题：<br>Apache和PHP整合<br>在Apache的conf目录下的httpd.conf文件中加入下面三行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#加载PHP模块</span><br><span class="line">LoadModule php7_module &quot;E:/php7/php7apache2_4.dll&quot;</span><br><span class="line"></span><br><span class="line">#当执行后缀为php的文件，就去找这个模块执行</span><br><span class="line">AddType Application/x-httpd-php .php</span><br><span class="line"></span><br><span class="line">#载入php配置文件</span><br><span class="line">PHPIniDir &quot;E:/php7&quot;</span><br></pre></td></tr></table></figure><p>路径选择你们的位置</p><p>在php目录下拷贝php.ini-development改名为php.ini<br>在文件里面进行如下修改(目录为个人的目录)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension_dir = &quot;E:/php7/ext&quot;</span><br></pre></td></tr></table></figure></p><p>在apache里面有个htdocs目录<br>在里面写入一个php文件<br>比如:<br>test.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">phpinfo();</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure></p><p>在浏览器输入localhost/test.php</p><p>如果能够正确显示则配置完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/12/29/PHP手动搭建环境/1.jpg&quot;&gt;
&lt;h4 id=&quot;php环境手动搭建&quot;&gt;&lt;a href=&quot;#php环境手动搭建&quot; class=&quot;headerlink&quot; title=&quot;php环境手动搭建&quot;&gt;&lt;/a&gt;php环境手动搭建&lt;/h4&gt;&lt;p&gt;ph
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
</feed>
