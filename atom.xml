<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小Q博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-31T07:31:52.963Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小全</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git-进阶</title>
    <link href="http://yoursite.com/2019/01/31/Git-%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2019/01/31/Git-进阶/</id>
    <published>2019-01-31T05:58:03.000Z</published>
    <updated>2019-01-31T07:31:52.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git进阶"><a href="#Git进阶" class="headerlink" title="Git进阶"></a>Git进阶</h2><h3 id="本地分支管理"><a href="#本地分支管理" class="headerlink" title="本地分支管理"></a>本地分支管理</h3><p>一个项目如果是你一个人开发，那就没什么，反正就一份项目，你想做哪个模块就做哪个模块<br>但是这样子开发效率慢啊</p><p>要是两个人开发，开发效率提高一倍，那么怎么合并起来呢？？？</p><p>如果说两个人做的地方，刚好互不影响，那很简单，学过数学的人都知道，直接合并起来嘛</p><p>问题来了！！！</p><p>如果两个人做的地方有重复怎么办？？？一行一行对比，然后一行行改?还是说一个人做完再让另外一个人做？那这和一个人做有什么区别</p><p>这就太麻烦了</p><p>所以引入了分支管理！这是个好东西</p><img src="/2019/01/31/Git-进阶/01.PNG"><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>根据上图我们可以知道，我们首先是有一个主干的(称为master分支)</p><p>我们每次提交，会多一个新的节点</p><img src="/2019/01/31/Git-进阶/02.png"><p>提交越多，master分支也会边长</p><p>创建分支的代码：(新的分支名字为dev)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br></pre></td></tr></table></figure><img src="/2019/01/31/Git-进阶/03.png"><p>我们可以看到一个*标记在master，这代表着我们操控着master分支<br>假设我们要切换分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>(我们也有一个更加方便的代码，创建分支同时切换到该分支上)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><p>接下来，我们执行一次提交</p><img src="/2019/01/31/Git-进阶/04.png"><p>然后我又返回到master里再提交一次</p><img src="/2019/01/31/Git-进阶/05.png"><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>首先切换到master分支<br>将dev分支合并到master分支下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><img src="/2019/01/31/Git-进阶/06.png"><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><img src="/2019/01/31/Git-进阶/07.png"><h3 id="GitHub上实现分支管理"><a href="#GitHub上实现分支管理" class="headerlink" title="GitHub上实现分支管理"></a>GitHub上实现分支管理</h3><p>上面说这么多，其实为了熟悉一下命令，还有通过一些图来表明，每个操作，到底发生了什么</p><p>接下来才是实际开发中会用到的，结合GitHub上讲解</p><p>首先我拉取一下我Github，我仓库里只有一个A.txt,里面有句Hello</p><p>我新建两个文件夹用来模拟两台电脑</p><img src="/2019/01/31/Git-进阶/08.png"><p><strong> 接着做如下操作 </strong></p><img src="/2019/01/31/Git-进阶/09.png"><img src="/2019/01/31/Git-进阶/10.png"><p>然后把文件都添加到本地仓库中</p><p>接着在Git2里推送到github上的分支下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">git push -u origin dev</span><br></pre></td></tr></table></figure></p><p>这样子在Github上就有分支了</p><p>接着Git去上传自己的到github的master下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>在创建一个文件夹Git3</p><p>分别把两个分支拉下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone 路径</span><br><span class="line">进入仓库</span><br><span class="line">git checkout dev </span><br><span class="line">git clone -b dev(分支名) 路径</span><br><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git进阶&quot;&gt;&lt;a href=&quot;#Git进阶&quot; class=&quot;headerlink&quot; title=&quot;Git进阶&quot;&gt;&lt;/a&gt;Git进阶&lt;/h2&gt;&lt;h3 id=&quot;本地分支管理&quot;&gt;&lt;a href=&quot;#本地分支管理&quot; class=&quot;headerlink&quot; title=&quot;本
      
    
    </summary>
    
      <category term="版本控制器" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git入门</title>
    <link href="http://yoursite.com/2019/01/12/Git%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/01/12/Git入门/</id>
    <published>2019-01-12T08:13:30.000Z</published>
    <updated>2019-02-24T01:55:57.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制器："><a href="#版本控制器：" class="headerlink" title="版本控制器："></a>版本控制器：</h2><p>首先了解Git之前要明白另外一样东西，那就是版本控制系统</p><p>什么叫版本控制系统呢？</p><p><strong>版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。</strong></p><p>程序员写代码，学会一种版本控制器是必不可少的技能</p><p>写代码，少不了的就是不断的修改源代码，但是代码是一种很神奇的东西，你会发现，原本只有一个BUG的改着改着<br>突然发现BUG数量不仅仅没有减少而且还增加，此时的心里感受，哈哈，应该要吐血，那么怎么办？我原来的代码也被我改掉了<br>说白了就是已经没有的备份，那就凉了~</p><p>好的，小白曾经是这么干的，比如说，出现BUG吗，那我要修改，修改之前，先拷贝一份现在的源文件，然后再去改，这样子就稳了</p><p>当然小白一开始做得还是很开心的，因为很简单啊，写的代码也不多，而且往往只是一个文件，随着小白的进步当中，代码往往牵涉<br>到多个文件的修改，这样子也是可以ctrl+c和ctrl+v的，但是一是一个文件夹里密密麻麻的项目，二是，看着一堆副本一副本二，简直就是头疼啊！！！</p><p>好啦，现在开始讲我们的版本控制器了</p><p>简单来说呢，版本控制器就是可以更加方便地对我们的代码进行管理</p><p>进入正题：</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git:"></a>Git:</h2><p>Git：分布式版本控制系统</p><p>那么有分布式那么就会有集中式，没错！</p><p>SVN就是集中式版本控制系统，本章不做介绍</p><p>Git很火的呢，怎么说，GitHub就是基于Git的基础上的</p><p>至于分布式版本系统控制系统和集中式版本控制系统，等我把Git和SVN讲解完再进行一个比较</p><h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>Git的安装可以参考官网<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>直接下载后安装后就可以了，很简单</p><p>安装后在开始菜单中找到Git Bash<br>鼠标右键也会有</p><h2 id="Git的入门"><a href="#Git的入门" class="headerlink" title="Git的入门"></a>Git的入门</h2><p>我首先创建了一个文件夹，专门进行讲解<br>文件夹名字为Git，首先创建一个文件，名字为a.txt，内容为AAA</p><p>接下来进行提交</p><p>在文件夹里面右键 git Bash</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先我们要初始化一个仓库，这个仓库是放在我们本机的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>默认为隐藏的，要设置查看隐藏文件就可以看得到多了一个文件夹</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>将文件添加到仓库里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add a.txt</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>将文件提交到仓库里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;version 1.0&quot;</span><br></pre></td></tr></table></figure><p>-m后面是本次提交的一个说明，就是提交的是什么东西(原则上可以省略，但是建议不要)</p><h3 id="git-add-和-git-commit的区别"><a href="#git-add-和-git-commit的区别" class="headerlink" title="git add 和 git commit的区别"></a>git add 和 git commit的区别</h3><p>首先git add添加自己指定的文件<br>git commit不可以，一次性将所有提交，不可指定文件</p><p><strong>git add是先将文件添加到暂存区，git commit将暂存区里的文件一次性提交到仓库里！！！</strong></p><p>基本上简单的一个Git流程的上传部分就介绍完了</p><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p>既然前面我们讲完了如何将文件上传到自己的仓库，那么我们现在要用到的情况下，怎么从仓库下载下来呢？？？</p><p>现在为了模仿以下真实环境</p><p>我进行多了两次提交</p><p>第一次提交之前，在a.txt增加了一行BBB</p><p>第二次提交之前，在a.txt增加了一行CCC</p><p>接下来我们就要去查看记录了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><img src="/2019/01/12/Git入门/1.png"><p>当前TXT是这样子的<br><img src="/2019/01/12/Git入门/2.png"></p><p>现在要恢复啦！！！<br><strong>见证奇迹的时刻——-</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>再打开文本，发现已经恢复了，用git log去查看的时候发现也确实少了一条记录<br>HEAD代表的是当前版本<br>HEAD^代表的是当前版本的上一个版本<br>HEAD^^代表的是上上版本</p><p>HEAD~N 代表的是当前邦本的上N个版本</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>GitHub是提供Git仓库托管服务的,所以首先要有一个GitHub账号</p><p>自行注册GitHub的账号，这个问题，不在这里描述了</p><p>其次注册完账号还有做一些事情</p><p>先创建一个SSH KEY</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>在C盘本地账号下有一个文件夹.ssh</p><p>里面有两个文件，分别是id_rsa.pub 和 id_rsa<br>分别对应着公钥和私钥</p><p>登陆GitHub，打开Settings里有一个选项，SSH and GPG keys<br>添加自己机子的公钥</p><p>因为Git支持SSH协议，所以添加了SSH KEY之后可以防止别人冒充来对我们的仓库进行恶意修改</p><h3 id="添加文件到GitHub"><a href="#添加文件到GitHub" class="headerlink" title="添加文件到GitHub"></a>添加文件到GitHub</h3><p>首先在GitHub里面创建一个Repository</p><p>比如说我创建了一个gitTest</p><p>然后回到git Bash<br>添加远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:用户名/仓库名字.git</span><br></pre></td></tr></table></figure></p><p>那么对应删除远程仓库的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></p><p>现在我们添加成功之后，接下来就是要上传到远程仓库里面去了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>接着去刷新我们的仓库，发现文件已经提交上去了</p><h3 id="GitHub上下载文件"><a href="#GitHub上下载文件" class="headerlink" title="GitHub上下载文件"></a>GitHub上下载文件</h3><p>这个也很简单对应着一条命令就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:用户名/仓库名字.git</span><br></pre></td></tr></table></figure><p>好了，本章对Git的介绍就讲到这里，这里只是入门，后面会有一些更加多的内容介绍，敬请关注~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;版本控制器：&quot;&gt;&lt;a href=&quot;#版本控制器：&quot; class=&quot;headerlink&quot; title=&quot;版本控制器：&quot;&gt;&lt;/a&gt;版本控制器：&lt;/h2&gt;&lt;p&gt;首先了解Git之前要明白另外一样东西，那就是版本控制系统&lt;/p&gt;
&lt;p&gt;什么叫版本控制系统呢？&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="版本控制器" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Python爬取网易云音乐</title>
    <link href="http://yoursite.com/2019/01/12/Python%E7%88%AC%E5%8F%96%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    <id>http://yoursite.com/2019/01/12/Python爬取网易云音乐/</id>
    <published>2019-01-12T02:20:26.000Z</published>
    <updated>2019-01-12T02:34:15.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python爬取网易云音乐"><a href="#Python爬取网易云音乐" class="headerlink" title="Python爬取网易云音乐"></a><em>Python爬取网易云音乐</em></h2><p>首先放网址：</p><p><a href="https://music.163.com/" target="_blank" rel="noopener">https://music.163.com/</a></p><p>通过Network我们可以找到我们的音乐url存放的位置</p><img src="/2019/01/12/Python爬取网易云音乐/1.png"><p>那么我们就简单啦，知道Ajax的请求页面，我们当然就可以直接爬取了，但是：</p><img src="/2019/01/12/Python爬取网易云音乐/2.png"><p>这个FormData好像不简单，那我怎么请求呢？</p><p>第一直觉，就感觉是被加密了，不愧是网易云，有一套呢</p><img src="/2019/01/12/Python爬取网易云音乐/3.png"><p>那么肯定就是和JS脱离不了关系了，找到JS，然后保存到本地进行分析一下</p><img src="/2019/01/12/Python爬取网易云音乐/4.png"><p>把代码保存到本地，进行一些操作</p><img src="/2019/01/12/Python爬取网易云音乐/5.png"><p>加密用到了四个参数，那么我们可以打印一下这四个参数</p><p>那么问题来了，这JS文件在我的本地，我怎么让网站进行加载呢？</p><p>对的，这里要运用到一个工具，Fiddler4</p><p>这是个什么东西呢</p><p>它能够记录并检查所有你的电脑和互联网之间的Http通讯，设置断点，查看所有的进出Fiddler的数据（cookie,html,css,js）</p><p>大概就是，在客户端和服务器之间创建一个代理服务器来对之间进行交互通讯信息进行监控</p><p>下载安装完成之后还要对Fiddler4进行配置：</p><p>Tools—》Options</p><img src="/2019/01/12/Python爬取网易云音乐/6.png"><img src="/2019/01/12/Python爬取网易云音乐/7.png"><p>更详细的介绍，这里就不多说了</p><p>那么大概界面是这样的</p><img src="/2019/01/12/Python爬取网易云音乐/8.png"><p>接着我们打开网易云官网</p><img src="/2019/01/12/Python爬取网易云音乐/9.png"><p>把core.js拖拉都右边，钩上相应的选项，在最下面找到要替换的JS，最后点击一下save</p><p>就能发现上面的路径变了，上图是我已经替换好的了</p><p>接下来：在网易云上搜索一首歌，打开控制台</p><p>你会发现，居然这样子了：</p><img src="/2019/01/12/Python爬取网易云音乐/10.png"><p>打印成功了！</p><p>再看XHR里面</p><img src="/2019/01/12/Python爬取网易云音乐/11.png"><p>我们的重点是url这个，所以我们只用关注第一个打印的，显然ids就是歌曲的序号</p><p>多试几组可以看出来一个问题就是：</p><p>后三个参数是不用管的</p><p>那么歌曲的序号又要怎么获取呢？最终找到的结果是在</p><img src="/2019/01/12/Python爬取网易云音乐/12.png"><p>然而这个页面也是加密的，很强，没事</p><p>我们再看看后台打印的东西</p><img src="/2019/01/12/Python爬取网易云音乐/13.png"><p>span class = “s-fc7”又是什么东西呢？</p><p>经过测试，发现这是固定的值</p><p>整个Json不同的地方在于s，传入歌名就可以了</p><p>呼</p><p>offset是偏移量，与翻页数有关系</p><p>好了，接下来又得去看我们的JS代码，去分析加密过程了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function a(a) &#123;</span><br><span class="line">        var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;</span><br><span class="line">        for (d = 0; a &gt; d; d += 1)</span><br><span class="line">            e = Math.random() * b.length,</span><br><span class="line">            e = Math.floor(e),</span><br><span class="line">            c += b.charAt(e);</span><br><span class="line">        return c</span><br><span class="line">    &#125;</span><br><span class="line">    function b(a, b) &#123;</span><br><span class="line">        var c = CryptoJS.enc.Utf8.parse(b)</span><br><span class="line">          , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)</span><br><span class="line">          , e = CryptoJS.enc.Utf8.parse(a)</span><br><span class="line">          , f = CryptoJS.AES.encrypt(e, c, &#123;</span><br><span class="line">            iv: d,</span><br><span class="line">            mode: CryptoJS.mode.CBC</span><br><span class="line">        &#125;);</span><br><span class="line">        return f.toString()</span><br><span class="line">    &#125;</span><br><span class="line">    function c(a, b, c) &#123;</span><br><span class="line">        var d, e;</span><br><span class="line">        return setMaxDigits(131),</span><br><span class="line">        d = new RSAKeyPair(b,&quot;&quot;,c),</span><br><span class="line">        e = encryptedString(d, a)</span><br><span class="line">    &#125;</span><br><span class="line">    function d(d, e, f, g) &#123;</span><br><span class="line">        var h = &#123;&#125;</span><br><span class="line">          , i = a(16);</span><br><span class="line">        return h.encText = b(d, g),</span><br><span class="line">        h.encText = b(h.encText, i),</span><br><span class="line">        h.encSecKey = c(i, e, f),</span><br><span class="line">        h</span><br><span class="line">    &#125;</span><br><span class="line">    function e(a, b, d, e) &#123;</span><br><span class="line">        var f = &#123;&#125;;</span><br><span class="line">        return f.encText = c(a + e, b, d),</span><br><span class="line">        f</span><br><span class="line">    &#125;</span><br><span class="line">    window.asrsea = d</span><br></pre></td></tr></table></figure><p>首先看函数d</p><p>函数d首先有个i，这个i是一个随机的十六位字符串，</p><p>然后进行了两次加密，第一次是第一个参数和第四个参数进行加密，把结果返回出来后与i字符串进行第二次加密，这个encText就是我们的params</p><p>而通过我们的刚才打印结果来看，后三个参数是固定的，然而i是随机的，也就是我们可以固定一个参数（一个最不可能的坑你，就是每次随机刚好就是随机到我的字符串），也就是说h.encSecKey=c(i,e,f)也是固定的，那也没什么好看的了</p><p>最主要的还是我们的params参数的第一次加密，因为第二次加密是在第一次加密的结果和一个固定的字符串，所以也没有讨论的必要了</p><p>首先看看我们的加密算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#AES加密算法</span><br><span class="line">def AES_encrypt(text, key, iv):</span><br><span class="line">    pad = 16 - len(text) % 16</span><br><span class="line">    if type(text)==type(b&apos;&apos;):</span><br><span class="line">        text = str(text, encoding=&apos;utf-8&apos;)</span><br><span class="line">    text = text + pad * chr(pad)</span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    encrypt_text = encryptor.encrypt(text)</span><br><span class="line">    encrypt_text = base64.b64encode(encrypt_text)</span><br><span class="line">    return encrypt_text</span><br></pre></td></tr></table></figure><p>这里，要安装一下Crypto模块，不然会报错，模块找不到</p><p>接下来就是源代码了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import requests</span><br><span class="line">import base64</span><br><span class="line">import os</span><br><span class="line">import codecs</span><br><span class="line">import json</span><br><span class="line">from pypinyin import  lazy_pinyin</span><br><span class="line">from urllib.request import urlretrieve</span><br><span class="line"># 后三个参数和i的值（随机的十六位字符串）</span><br><span class="line">b = &apos;010001&apos;</span><br><span class="line">c = &apos;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&apos;</span><br><span class="line">d = &apos;0CoJUm6Qyw8W8jud&apos;</span><br><span class="line">#随机的十六位字符串</span><br><span class="line">def createSecretKey(size):</span><br><span class="line">return (&apos;&apos;.join(map(lambda xx: (hex(ord(xx))[2:]), str(os.urandom(size)))))[0:16]</span><br><span class="line">#AES加密算法</span><br><span class="line">def AES_encrypt(text, key, iv):</span><br><span class="line">    pad = 16 - len(text) % 16</span><br><span class="line">    if type(text)==type(b&apos;&apos;):</span><br><span class="line">        text = str(text, encoding=&apos;utf-8&apos;)</span><br><span class="line">    text = text + str(pad * chr(pad))</span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    encrypt_text = encryptor.encrypt(text)</span><br><span class="line">    encrypt_text = base64.b64encode(encrypt_text)</span><br><span class="line">    return encrypt_text</span><br><span class="line">#得到第一个加密参数</span><br><span class="line">def Getparams(a,SecretKey):</span><br><span class="line">    #0102030405060708是偏移量，固定值</span><br><span class="line">    iv = &apos;0102030405060708&apos;</span><br><span class="line">    h_encText = AES_encrypt(a,d,iv)</span><br><span class="line">    h_encText = AES_encrypt(h_encText,SecretKey,iv)</span><br><span class="line">    return h_encText</span><br><span class="line">#得到第二个加密参数</span><br><span class="line">def GetSecKey(text, pubKey, modulus):</span><br><span class="line">    text = text[::-1]</span><br><span class="line">    rs = int(codecs.encode(text.encode(&apos;utf-8&apos;), &apos;hex_codec&apos;), 16) ** int(pubKey, 16) % int(modulus, 16)</span><br><span class="line">    return format(rs, &apos;x&apos;).zfill(256)</span><br><span class="line">#得到表单的两个参数</span><br><span class="line">def GetFormData(a):</span><br><span class="line">    SecretKey = createSecretKey(16)</span><br><span class="line">    params = Getparams(a,SecretKey)</span><br><span class="line">    enSecKey = GetSecKey(SecretKey,b,c)</span><br><span class="line">    data = &#123;</span><br><span class="line">&quot;params&quot;:str(params,encoding=&apos;utf-8&apos;),</span><br><span class="line">&quot;encSecKey&quot;:enSecKey</span><br><span class="line">&#125;</span><br><span class="line">    return data</span><br><span class="line">def getOnePatam():</span><br><span class="line">    # 查询id的url</span><br><span class="line">    url = &apos;https://music.163.com/weapi/cloudsearch/get/web?csrf_token=&apos;</span><br><span class="line">    #伪装头部</span><br><span class="line">    head = &#123;</span><br><span class="line">        &apos;Host&apos;: &apos;music.163.com&apos;,</span><br><span class="line">        &apos;Origin&apos;:&apos;https://music.163.com&apos;,</span><br><span class="line">        &apos;Referer&apos;:&apos;https://music.163.com/search/&apos;,</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;输入你想要下载的歌手&quot;)</span><br><span class="line">    song_name = input()</span><br><span class="line">    #第一个参数</span><br><span class="line">    song_name = &apos;&apos;.join(lazy_pinyin(song_name))</span><br><span class="line">    key = &apos;&#123;hlpretag:&quot;&quot;,hlposttag:&quot;&lt;/span&gt;&quot;,s:&quot;&apos;+song_name+&apos;&quot;,type:&quot;1&quot;,csrf_token:&quot;&quot;,limit:&quot;30&quot;,total:&quot;true&quot;,offset:&quot;0&quot;&#125;&apos;</span><br><span class="line">    FormData = GetFormData(key)</span><br><span class="line">    html = requests.post(url,headers=head,data=FormData)</span><br><span class="line">    result = json.loads(html.text)</span><br><span class="line">    return result[&apos;result&apos;][&apos;songs&apos;]</span><br><span class="line">#下载器：</span><br><span class="line">def download(name,id):</span><br><span class="line">    # 获取歌曲的url的路径</span><br><span class="line">    song_url = &quot;https://music.163.com/weapi/song/enhance/player/url?csrf_token=&quot;</span><br><span class="line">    # 伪装头部</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &apos;Host&apos;: &apos;music.163.com&apos;,</span><br><span class="line">        &apos;Origin&apos;: &apos;https://music.163.com&apos;,</span><br><span class="line">        &apos;Referer&apos;: &apos;https://music.163.com/&apos;,</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    # 把上个页面查询到的id放到第二个页面的第一个参数上</span><br><span class="line">    a =str(&#123;&apos;ids&apos;: &quot;[&quot;+str(id)+&quot;]&quot;, &apos;br&apos;: 320000, &apos;csrf_token&apos;: &quot;&quot;&#125;)</span><br><span class="line">    FormData = GetFormData(a)</span><br><span class="line">    response = requests.post(song_url,data = FormData,headers=headers)</span><br><span class="line">    json_dict = json.loads(response.content)</span><br><span class="line">    song_url=json_dict[&apos;data&apos;][0][&apos;url&apos;]</span><br><span class="line">    print(song_url)</span><br><span class="line">    folder = os.path.exists(&apos;songs&apos;)</span><br><span class="line">    if not folder:</span><br><span class="line">        os.makedirs(&apos;songs&apos;)</span><br><span class="line">    path = os.path.join(&apos;songs&apos;,name+&quot;.mp3&quot;)</span><br><span class="line">    urlretrieve(song_url,filename=path)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    song_list = getOnePatam()</span><br><span class="line">    for i in song_list:</span><br><span class="line">        name = i[&apos;name&apos;]</span><br><span class="line">        id = i[&apos;id&apos;]</span><br><span class="line">        download(name,id)</span><br></pre></td></tr></table></figure><p>以下是效果图</p><img src="/2019/01/12/Python爬取网易云音乐/14.png"><p>这次程序重点的是对加密的网页，学会如何去处理</p><p>有一点要强调一下，因为如果是中文，会导致加密的时候字符串长度不匹配的问题，所以只能用拼音，所以这里加了一个中文转拼音的库，pypinyin的lazy_pinyin()的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python爬取网易云音乐&quot;&gt;&lt;a href=&quot;#Python爬取网易云音乐&quot; class=&quot;headerlink&quot; title=&quot;Python爬取网易云音乐&quot;&gt;&lt;/a&gt;&lt;em&gt;Python爬取网易云音乐&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;首先放网址：&lt;/p&gt;
&lt;p&gt;&lt;a 
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="网易云音乐" scheme="http://yoursite.com/tags/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例</title>
    <link href="http://yoursite.com/2019/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/01/06/设计模式-单例/</id>
    <published>2019-01-06T15:52:39.000Z</published>
    <updated>2019-01-07T08:03:05.874Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p><p>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><p>说白了就是：就是使用设计模式，代码会更好。</p><p>单例模式：就是单个实例</p><p>那么单例模式有什么好处呢？</p><p>很简单，首先，都是单个实例了，那么就可以怎样</p><p>一、实例控制</p><p>单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。</p><p>二、灵活性</p><p>因为类控制了实例化过程，所以类可以灵活更改实例化过程。</p><p>但是还是有缺点的：</p><p>一、开销</p><p>虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。</p><p>二、可能的开发混淆</p><p>使用单例对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用new关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。</p><p>三、对象生存期</p><p>不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于.NET Framework的语言），只有单例类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如 C++），其他类可以删除对象实例，但这样会导致单例类中出现悬浮引用。。</p><p><strong>单例模式根据实例化对象时机的不同分为两种</strong></p><p><strong>饿汉式</strong></p><p>上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Single&#123;</span><br><span class="line">/*私有化，防止外部创建实例*/</span><br><span class="line">private Single&#123;&#125;</span><br><span class="line">/*设置静态属性私有，防止外部通过类名访问*/</span><br><span class="line">private static Single single = new Single();</span><br><span class="line">/*设置静态方法*/</span><br><span class="line">public static Single getInstance()&#123;</span><br><span class="line">return single;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很简单的</p><p>上面有个问题，当类加载的时候，就会实例化Single（），假如我加载完类，一段时间没用，而实例却已经早就创建了，着就会造成一个浪费。</p><p>通过这个问题，我们可以想，当我们需要实例的时候我们才去实例化，而不是通过类加载，那么我们可以这样子做</p><p><strong>懒汉式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Single&#123;</span><br><span class="line">/*私有化，防止外部创建实例*/</span><br><span class="line">private Single&#123;&#125;</span><br><span class="line">/*设置静态属性私有,先设空，需要的时候再实例化*/</span><br><span class="line">private static Single single=null;</span><br><span class="line">/*设置静态方法*/</span><br><span class="line">public static Single getInstance()&#123;</span><br><span class="line">if(single==null)&#123;</span><br><span class="line">single = new Single()</span><br><span class="line">&#125;</span><br><span class="line">return single</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子，就没什么问题了</p><p>但是现在再思考一个问题，万一是多线程的时候呢？这样就有问题的了</p><p>这样子我们就需要加一个锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Single&#123;</span><br><span class="line">/*私有化，防止外部创建实例*/</span><br><span class="line">private Single&#123;&#125;</span><br><span class="line">/*设置静态属性私有,先设空，需要的时候再实例化*/</span><br><span class="line">private static Single single=null;</span><br><span class="line">/*设置静态方法*/</span><br><span class="line">public static Single getInstance()&#123;</span><br><span class="line">/*两重判空是为了提高效率*/</span><br><span class="line">if(single==null)&#123;</span><br><span class="line">/*上锁*/</span><br><span class="line">synchronized(Single.Class)&#123;</span><br><span class="line">if (single==null) &#123;</span><br><span class="line">single = new Single()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return single;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子整个单例模式就做得比较好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。&lt;/p&gt;
&lt;p&gt;使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java/"/>
    
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java线程</title>
    <link href="http://yoursite.com/2018/12/28/Java%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/28/Java线程/</id>
    <published>2018-12-28T11:56:18.000Z</published>
    <updated>2018-12-28T12:08:15.305Z</updated>
    
    <content type="html"><![CDATA[<p>什么是线程？</p><p>线程是一个程序里的不同执行路径</p><p>一般的程序是从一个入口出发，沿着唯一的路径走到终点，而线程则使唯一的路径变成多条路径</p><p>以下是单线程操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">aa.run();</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello JAVA&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为aa.run没有执行完毕，下面的while循环就不会执行，所以就是一直输出“hello world“<br>再看看多线程操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">aa.start();</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello JAVA&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread中的start方法就是创建一个线程，并且自动调用run方法，直接调用run方法是不会创建一个线程的。<br>执行一个线程，其实就是执行一个线程里面的run方法，一个Thread对象不能调用两次start方法，否则会抛出异常。<br>把aa.run改成aa.start结果就是两个循环交替执行，这就是多线程。<br>单线程就是一条路径，从头到尾执行。<br>多线程就是有多条路径，每次都可以走不同的路径。</strong></p><img src="/2018/12/28/Java线程/1.png"><p><strong>执行aa.start并不代表aa对象的线程就立刻执行，而是得到了能够被CPU执行的资格，也就是就绪的状态。<br>创建线程的第二种方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread2 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">Thread th=new Thread(aa);</span><br><span class="line">th.start();</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello JAVA&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread常用方法：</p><p>setName（String）设置名字</p><p>currentThread（）返回正在执行线程的对象</p><p>getName（）返回线程的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 </span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">        A aa=new A();</span><br><span class="line">        aa.start();</span><br><span class="line">        System.out.println(&quot;hello JAVA&quot;);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;);</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">aa.setName(&quot;123&quot;);</span><br><span class="line">aa.start();</span><br><span class="line">System.out.println(&quot;hello JAVA&quot;);</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread的sleep方法<br>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<br>要捕获异常！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">try&#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">aa.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread的join方法：如a.join（）；暂停当前正在执行的线程，直到a的线程运行终止之后当前线程才有机会得到执行，注意：不是暂停a对象的线程，而是当前运行的线程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread1 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A aa=new A();</span><br><span class="line">aa.start();</span><br><span class="line">try&#123;</span><br><span class="line">aa.join();</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>**<br>Thread的优先级：</p><p>getPriority:获取优先级</p><p>setPriority:设置优先级</p><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。</p><p>线程调度器用数字表现，范围从一到十，一个线程默认是5。</p><p>通常优先级高的比优先级低的要先执行，但并不是一定的！因为实际开发中并不单纯依赖优先级来决定优先级的运行顺序**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class A implements Runnable&#123;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;10;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;A&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B implements Runnable&#123;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;10;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;B&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread3 &#123;</span><br><span class="line">    public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">        Thread t1=new Thread(new A());</span><br><span class="line">        Thread t2=new Thread(new B());</span><br><span class="line">        t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优先级越高！越容易被CPU先调用！</strong></p><h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a><strong>线程的同步</strong></h2><p>卖票系统！</p><p>假如有三个地方，A,B,C同时卖票</p><p>假如代码写成这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(票数大于0)</span><br><span class="line">&#123;</span><br><span class="line">买票</span><br><span class="line">票数-1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当A发现票大于0的时候，本应该执行下一步，假如此时CPU切换的B线程的时候，发现票数大于0（因为在A线程里面，票数没有减一），当在B中发现票数大于0之后，假如CPU又切换到C线程里面，发现票数还是大于0（同理）假如票只有一张，那么此时就相当于一张票被卖了三次。<br>这将产生错误！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">private int tickets=100;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">if(tickets&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;);</span><br><span class="line">tickets--;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread4 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A a=new A();</span><br><span class="line">Thread t1=new Thread(a);</span><br><span class="line">t1.start();</span><br><span class="line">A b=new A();</span><br><span class="line">Thread t2=new Thread(b);</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果：</p><img src="/2018/12/28/Java线程/2.png"><p>每张票都被卖出去两次！！！这是不合理的</p><p>导致这个的原因是a对象和b对象都有一个属于自己的tickets 100</p><p>那么接下来看以下程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">static int tickets=100;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">if(tickets&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;);</span><br><span class="line">tickets--;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread4 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A a=new A();</span><br><span class="line">Thread t1=new Thread(a);</span><br><span class="line">t1.start();</span><br><span class="line">A b=new A();</span><br><span class="line">Thread t2=new Thread(b);</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把票数改成静态的<br>结果是这样的：</p><img src="/2018/12/28/Java线程/3.png"><p>那么来分析一下这个结果是为什么，当Thread-0发现票数是100的时候执行卖出操作，然后立刻切换的线程1然后发现还是100但是没有执行卖出操作又转换为线程0，此时减一然后就变成99、98、97、96、95、这个时候立刻切换成线程1执行卖出操作，打印出来。</p><h4 id="简单来说：CPU会在线程之间来回切换！"><a href="#简单来说：CPU会在线程之间来回切换！" class="headerlink" title="简单来说：CPU会在线程之间来回切换！"></a>简单来说：CPU会在线程之间来回切换！</h4><h3 id="好的，重点来了！"><a href="#好的，重点来了！" class="headerlink" title="好的，重点来了！"></a>好的，重点来了！</h3><h2 id="Synchronized—同步"><a href="#Synchronized—同步" class="headerlink" title="Synchronized—同步"></a>Synchronized—同步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">static int tickets=100;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">synchronized(this)</span><br><span class="line">&#123;</span><br><span class="line">if(tickets&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;正在卖出第&quot;+tickets+&quot;张票&quot;);</span><br><span class="line">tickets--;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Thread4 &#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">A a=new A();</span><br><span class="line">Thread t1=new Thread(a);</span><br><span class="line">Thread t2=new Thread(a);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="/2018/12/28/Java线程/4.png"></p><p><strong>synchronized 关键字，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。它包括两种用法：synchronized 方法和 synchronized 块。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是线程？&lt;/p&gt;
&lt;p&gt;线程是一个程序里的不同执行路径&lt;/p&gt;
&lt;p&gt;一般的程序是从一个入口出发，沿着唯一的路径走到终点，而线程则使唯一的路径变成多条路径&lt;/p&gt;
&lt;p&gt;以下是单线程操作&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>PHP手动搭建环境</title>
    <link href="http://yoursite.com/2018/12/28/PHP%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/12/28/PHP手动搭建环境/</id>
    <published>2018-12-28T11:23:13.000Z</published>
    <updated>2019-01-02T02:24:05.203Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/28/PHP手动搭建环境/1.jpg"><h4 id="php环境手动搭建"><a href="#php环境手动搭建" class="headerlink" title="php环境手动搭建"></a>php环境手动搭建</h4><p>php下载路径<br><a href="https://windows.php.net/download" target="_blank" rel="noopener">https://windows.php.net/download</a><br>（注意一点的是要下线程安全的Thread Safe）</p><p>Apache下载路径<br><a href="http://httpd.apache.org/docs/current/platform/windows.html" target="_blank" rel="noopener">http://httpd.apache.org/docs/current/platform/windows.html</a></p><p>Mysql下载路径<br><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p><p>Apache的安装</p><p><strong>这里注意，请先把你的Apache的目录放置好再进行安装，否则安装后再移动位置，会出问题</strong><br>进入Apache目录下的conf目录修改httpd.conf<br>大概在38行附近修改成如下：<br>路径使用自己Apache的安装位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Define SRVROOT &quot;E:\Apache24&quot; </span><br><span class="line">ServerRoot &quot;$&#123;SRVROOT&#125;&quot;</span><br></pre></td></tr></table></figure></p><p>用管理员模式开启CMD<br>进入Apache的bin目录下 命令行httpd -k install进行安装<br>可以使用httpd -t进行测试，是否安装成功</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果失败，导致原因有可能是：</p><ol><li>端口被占用<br> 解决办法：<br> netstat -aon | findstr :80<br> 查看端口是否正在被监听，如果被监听了，有两种方法<pre><code>1. 修改Apache的端口，打开Apache的conf目录下修改httpd.conf,查找Listen关键字 找到 Listen 80 修改到你想设置的端口即可2. 停止正在监听的服务，打开资源管理器，找到对应的PID，停止运行</code></pre></li></ol><p>这里默认上面三个已经下载好而且已经安装好了</p><p>正题：<br>Apache和PHP整合<br>在Apache的conf目录下的httpd.conf文件中加入下面三行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#加载PHP模块</span><br><span class="line">LoadModule php7_module &quot;E:/php7/php7apache2_4.dll&quot;</span><br><span class="line"></span><br><span class="line">#当执行后缀为php的文件，就去找这个模块执行</span><br><span class="line">AddType Application/x-httpd-php .php</span><br><span class="line"></span><br><span class="line">#载入php配置文件</span><br><span class="line">PHPIniDir &quot;E:/php7&quot;</span><br></pre></td></tr></table></figure><p>路径选择你们的位置</p><p>在php目录下拷贝php.ini-development改名为php.ini<br>在文件里面进行如下修改(目录为个人的目录)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension_dir = &quot;E:/php7/ext&quot;</span><br></pre></td></tr></table></figure></p><p>在apache里面有个htdocs目录<br>在里面写入一个php文件<br>比如:<br>test.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">phpinfo();</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure></p><p>在浏览器输入localhost/test.php</p><p>如果能够正确显示则配置完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/12/28/PHP手动搭建环境/1.jpg&quot;&gt;
&lt;h4 id=&quot;php环境手动搭建&quot;&gt;&lt;a href=&quot;#php环境手动搭建&quot; class=&quot;headerlink&quot; title=&quot;php环境手动搭建&quot;&gt;&lt;/a&gt;php环境手动搭建&lt;/h4&gt;&lt;p&gt;ph
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="环境搭建" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Solr单机版的搭建</title>
    <link href="http://yoursite.com/2018/12/27/Solr%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/12/27/Solr单机版的搭建/</id>
    <published>2018-12-26T16:35:59.000Z</published>
    <updated>2018-12-27T14:29:39.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a><strong>Solr</strong></h2><img src="/2018/12/27/Solr单机版的搭建/1.jpg"><p>Solr是一个开源搜索平台，用于构建搜索应用程序。 它建立在Lucene(全文搜索引擎)之上。 Solr是企业级的，快速的和高度可扩展的。 使用Solr构建的应用程序非常复杂，可提供高性能。</p><p><strong>solr</strong>的一些突出的特点：</p><ul><li>Restful APIs − 要与Solr通信，并非一定需要有Java编程技能。相反，您可以使用restful服务与它通信。可使用文件格式(如xml，json和.CSV)在Solr中作为输入文档，并以相同的文件格式获取结果。</li><li>全文搜索 - Solr提供了全文搜索所需的所有功能，例如令牌，短语，拼写检查，通配符和自动完成。</li><li>企业准备 - 根据企业/组织的需要，Solr可以部署在任何类型的系统(大或小)，如独立，分布式，云等。<br>灵活和可扩展 - 通过扩展Java类并相应配置，可以轻松地定制Solr的组件。</li><li>NoSQL数据库 - Solr也可以用作大数据量级的NOSQL数据库，可以沿着集群分布搜索任务。</li><li>管理界面 - Solr提供了一个易于使用，用户友好，功能强大的用户界面，使用它可以执行所有可能的任务，如管理日志，添加，删除，更新和搜索文档。</li><li>高度可扩展 - 在使用Solr与Hadoop时，我们可以通过添加副本来扩展其容量。</li><li>以文本为中心并按相关性排序 - Solr主要用于搜索文本文档，结果根据与用户查询的相关性按顺序传送</li></ul><h2 id="Solr单机版的搭建："><a href="#Solr单机版的搭建：" class="headerlink" title="Solr单机版的搭建："></a>Solr单机版的搭建：</h2><p>解压solr和tomcat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxf solr-4.10.3.tgz.tgz</span><br><span class="line">tar -zxf apache-tomcat-7.0.47.tar.gz</span><br></pre></td></tr></table></figure></p><p>把solr的war包放到tomcat的webapp目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp solr-4.10.3/dist/solr-4.10.3.war /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr.war</span><br></pre></td></tr></table></figure></p><p>cp solr-4.10.3/example/lib/ext/* /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/lib/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">配置一下solrhome</span><br></pre></td></tr></table></figure></p><p>vim /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/web.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">修改solr的web.xml</span><br></pre></td></tr></table></figure></p><p>vim /home/quan/taotao/apache-tomcat-7.0.47/webapps/solr/WEB-INF/web.xml<br><code>`</code><br><img src="/2018/12/27/Solr单机版的搭建/3.png"></p><p>再重新启动一次Tomcat<br><img src="/2018/12/27/Solr单机版的搭建/4.png"></p><p>在浏览器里访问一下 localhost:8080/solr<br>会出现以下界面<br><img src="/2018/12/27/Solr单机版的搭建/5.png"></p><p>整个Solr服务就启动完成了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Solr&quot;&gt;&lt;a href=&quot;#Solr&quot; class=&quot;headerlink&quot; title=&quot;Solr&quot;&gt;&lt;/a&gt;&lt;strong&gt;Solr&lt;/strong&gt;&lt;/h2&gt;&lt;img src=&quot;/2018/12/27/Solr单机版的搭建/1.jpg&quot;&gt;
&lt;p&gt;Solr
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="搜索引擎" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="Solr" scheme="http://yoursite.com/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>线程和进程</title>
    <link href="http://yoursite.com/2018/12/20/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/20/线程和进程/</id>
    <published>2018-12-20T04:59:30.000Z</published>
    <updated>2018-12-24T17:09:42.858Z</updated>
    
    <content type="html"><![CDATA[<p>计算机所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例</p><p>单核CPU也就是单个核心的CPU，每次只能执行一个进程，由于CPU在各进程之间快速切换，所以每个进程所执行的时间是不确定的。</p><p>举个例子：</p><p><img src="\\images\pasted-1.png\" alt="upload successful"><br>假设你在看着食谱做美食，那么你就相当于CPU，食谱就是程序，而做美食的材料就是输入数据，进程就是，你在阅读食谱取食材以及制作美食的这一系列动作，假设你在做美食时候突然来了个电话，你可能会先熄火，然后脑海里知道自己现在做到哪个位置（保存当前状态），然后去接电话，处理完了后，你可能才回来厨房想想刚才做到哪里了，然后继续之前继续做</p><p>一个进程就是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被多个进程共享，CPU使用了某种调度算法决定何时停止一个进程的工作，并且转向另一个进程提供服务。</p><p>进程的创建：有四种主要的事件<br>1、系统初始化<br>    前台进程<br>    守护进程<br>2、正在运行的程序执行了创建进程的系统调用<br>3、用户请求创建一个新进程<br>4、一个批处理作业的初始化</p><p>进程的终止<br>1、正常退出<br>2、出错退出<br>3、严重错误<br>4、被其他进程给杀死</p><p>只可以有一个父进程，但可以有零个或者多个子进程</p><p>进程有三种状态：<br>运行态，就绪态，阻塞态</p><p>​</p><p>为了实现进程模型，操作系统维护着一张表格（一个结构数组）即进程表，每个进程占用一个进程表的一个项，这张表包含了许多信息，比如程序计数器，堆栈指针，内存分配状况，等等从而保证了该进程被断掉后重新启动的时候，能够保存之前的信息。</p><p>线程<br>为什么需要线程？</p><p>首先，有了线程，我们可以不必考虑终端、定时器、和上下文的切换只需考虑并行进程。其次，线程比进程更加轻量级，速度会比用进程效率要提高很多。</p><p>每个单核处理器在某个时刻也是只能够执行一个线程的，这和进程是一样的，线程是CPU处理的基本单位，我们前面讨论的进程，是进程单线程模型。</p><p>同样的，线程也是有阻塞态、运行态、就绪态。</p><p>为了实现可移植的线程程序，IEEE在IEEE标准中定义了线程的标准，它定义的线程包叫做pthread</p><p>实现线程包有两种方法，第一种把整个线程包放在用户空间</p><p>从内核的角度上管理的就是单线程进程的模型，这样子尽管系统不支持线程，也可以进行实现</p><p>用C语言实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define NUMBER 10</span><br><span class="line">void *hello(void *id)&#123;</span><br><span class="line">    printf(&quot;Thread-----%d\n&quot;,id);</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t threads[NUMBER];</span><br><span class="line">    int status;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;NUMBER;i++)&#123;</span><br><span class="line">        printf(&quot;Main---Creating thread%d\n&quot;,i);</span><br><span class="line">        status = pthread_create(&amp;threads[i],NULL,hello,(void*)i);</span><br><span class="line">        if(status!=0)&#123;</span><br><span class="line">            printf(&quot;ErrorCode----&gt;%d\n&quot;,status);</span><br><span class="line">            exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在用户空间管理线程的时候会创建一个运行时的系统，由这个系统进行管理，每个进程都需要其专用的线程表，用来跟踪该进程中的线程。这些表和进程表相似，不过它仅仅记录的是各个线程的属性，如每个线程的程序计数器，堆栈指针，寄存器和状态。因为切换线程的时候不需要陷入到内核空间，不需要有上下文的切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。</p><p>用户线程还有一个优点，允许每个进程有自己定制的调度算法，这样子就有一个很好的可扩展性</p><p>如果某个线程阻塞了，就会导致整个进程的阻塞</p><p>在内核中实现线程</p><p>此时不再需要运行时的系统了，另外，每个进程中也没有线程表，内核中有用来记录系统中所有线程的线程表了，当某个线程希望创建一个新的线程的时候，就会进行一个系统的调用，这个系统调用通过对线程表的更新完成线程创建的工作。</p><p>内核的线程表里保存了每个线程的信息，这些信息和在用户空间中的线程是一样的，但是现在保存在内核中</p><p>由于在内核中创建线程的代价比较大，所以某些系统会采取一种方式：回收线程，当某个线程被撤销的时候，就标记为不可运行的，但是其内核数据的结构没有收到影响。再次创建一个新的线程的时候，就把这个线程给重新启动就可以了，这样子可以减少多次系统调用来开辟新的线程</p><p>混合实现</p><p>使用内核级的线程，然后将用户级的线程与某些或者全部内核线程多路复用，采取这种方式：开发人员就可以决定有多少个内核级的线程和多少个用户级线程即使多路复用，这个模型可以带来最大的灵活度</p><p>进程之间的通信<br>比如说一个购票系统：</p><p>进程A和进程B，此时：进程A去买票（一共十张）：首先读出票数，把票数减一，然后把减一后的数据放回去</p><p>假设在第二个步骤的时候发生CPU 的切换，进程B去读票数，那么去读的时候此时票数还是10，然后进行减一后，放回去，再切回线程A，放回去，这里就有个问题：同一张票给了两个进程去卖了！这明显是不科学的。</p><p>为了有效避免进程的竞争问题这里需要做的就是互斥，那么什么是互斥呢？就是A在访问的时候，禁止B访问，这样子就能够进行一个有效的防止竞争了。</p><p>这里面设计很多种方法：</p><p>屏蔽中断：每个进程在刚刚进入临界区后立刻屏蔽所有中断，并在就有离开之前再打开终端，屏蔽中断后，时钟中断也会被屏蔽，CPU只有发生时钟中断或者其他中断才会进行切换，这样子，在屏蔽中断之后，CPU将不会进行切换</p><p>锁变量：共享一个变量（锁），初始值为0，当一个进程进入临界区的时候，就测试这把锁，如果该锁为0则进程把锁设置为1，然后进入，如果进入的时候锁的值为1，则等待，当出去临界区的时候再把锁的值改为0</p><p>严格轮换法：</p><p>严格轮换法同样也是针对一个临界区设置一个变量,假设为Turn。以两个进程为例子:</p><p>当Turn为0时,Process 0才能能进入临界区,否则等待。等Process 0离开临界区后,将Turn设置为1.</p><p>当Turn为1时,Process 1才能进入临界区,否则等待。等Process 1离开临界区后,将Turn设置为0.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例&lt;/p&gt;
&lt;p&gt;单核CPU也就是单个核心的CPU，每次只能执行一个进程，由于CPU在各进程之间快速切换，所以每个进程所执行的时间是不确定的。&lt;/p&gt;
&lt;p&gt;举个例子
      
    
    </summary>
    
    
  </entry>
  
</feed>
