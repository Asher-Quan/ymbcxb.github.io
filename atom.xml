<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ymbcxb|个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-11T12:34:35.063Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ymbcxb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM总结</title>
    <link href="http://yoursite.com/2019/12/19/JVM%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/19/JVM总结/</id>
    <published>2019-12-19T09:28:43.000Z</published>
    <updated>2020-01-11T12:34:35.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谈谈你对Java的理解"><a href="#谈谈你对Java的理解" class="headerlink" title="谈谈你对Java的理解"></a>谈谈你对Java的理解</h3><p>Java有两个显著的特性：</p><ul><li>平台无关性，也就是一次编译，多处运行</li><li>通过垃圾回收机制管理内存的分配和回收</li></ul><p>还有一些别的特性，语言特性：泛型，反射</p><p>类库丰富：网络编程，集合，并发</p><h3 id="Java如何实现平台无关"><a href="#Java如何实现平台无关" class="headerlink" title="Java如何实现平台无关"></a>Java如何实现平台无关</h3><p>Java分为编译期和解释期</p><p>首先将Java文件编译成.class文件，这个class文件则可以在多个平台下解释运行</p><p>现在JDK的有一个名叫JIT（Just in time）的编译器,这个编译器在运行期间会判断是否存在热点代码，如果有热点代码则使用JIT进行编译处理，而不是解释处理</p><p>JVM的三种启动方式：</p><ul><li>-Xint：只进行解释执行，不执行编译，屏蔽JIT</li><li>-Xcomp：关闭解释器，只进行编译处理</li><li>AOT：在运行前直接编译成机器码，避免JIT预热</li></ul><h3 id="JVM如何加载-class文件"><a href="#JVM如何加载-class文件" class="headerlink" title="JVM如何加载.class文件"></a>JVM如何加载.class文件</h3><img src="/2019/12/19/JVM总结/01.png"><p>JVM大致分为四部分：</p><ul><li>ClassLoader：依据特定格式加载class文件到内存，满足格式则可以加载</li><li>运行时数据区：Java虚拟机在运行程序的时候的数据区域</li><li>Execution Engine：对命令进行解析，提交给操作系统执行</li><li>Native Interface ： 融合不同开发语言的原生库为Java使用</li></ul><h3 id="Java的反射"><a href="#Java的反射" class="headerlink" title="Java的反射"></a>Java的反射</h3><p>Java的反射机制是在运行状态中，对于任意一个类，都能够知道类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性，这种动态获取信息以及调用对象的方法的功能称为Java语言的反射机制。</p><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>ClassLoader的主要工作是在Class装载的时候，从系统外部获得Class的二进制数据流，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接，初始化等操作。</p><p>ClassLoader的种类：</p><ul><li>BoostrapClassLoader：C++编写，加载核心库java.*</li><li>ExtClassLoader：Java编写，加载扩展库 javax.*</li><li>AppClassLoader：Java编写，加载程序的所在目录</li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><img src="/2019/12/19/JVM总结/02.png"><p>为什么要使用双亲委派机制去加载类，因为这样子做可以避免多份同样字节码的加载，比如我们手写一个String类，也是不会被加载的，String这个类会被BoostrapClassLoader加载</p><h3 id="loadClass和forName的区别"><a href="#loadClass和forName的区别" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h3><p>首先类的装载过程如下：</p><ol><li><strong>加载</strong>：将字节码加载到内存</li><li><strong>校验</strong>：分析是否存在不满足Java规范</li><li><strong>准备</strong>：将类的变量即静态变量分配内存并设置类变量的初始值（举个例子 public static int i = 3; 在这个过程之后赋值成0，使用初始值）</li><li><strong>解析</strong>：将虚拟机常量池的符号引用替换为直接引用（举个例子,int b = a; 这个可以理解为符号引用，直接引用是什么意思呢，将这种符号转换成对应的内存地址）</li><li><strong>初始化</strong>：执行类构造器方法(<strong>区分开构造器方法</strong>)，(举个例子，上面在准备的阶段，将i的值赋值为0，此时才赋值为3)</li></ol><p>其中 2，3，4的三个步骤也叫做链接</p><p><strong>Class.forName得到的class是已经初始化完成的</strong></p><p><strong>Classloader.loadClass得到的class是还没有链接</strong></p><h3 id="元空间和永久代的区别"><a href="#元空间和永久代的区别" class="headerlink" title="元空间和永久代的区别"></a>元空间和永久代的区别</h3><p>JDK8开始把类的元信息存放空间叫做元空间，JDK8以前，这个存储空间叫做永久代</p><p>元空间和永久代都是属于方法区的实现，实现方法不同，方法区是Java虚拟机的一种规范</p><p><strong>元空间使用的是本地内存，而永久代使用的是JVM内存</strong></p><p>使用永久代的缺点：</p><ul><li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难易确定，给永久代的大小指定带来了困难</li><li>永久代会为GC带来不必要的复杂性</li><li>方便HotSpot与其他JVM的集成</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;谈谈你对Java的理解&quot;&gt;&lt;a href=&quot;#谈谈你对Java的理解&quot; class=&quot;headerlink&quot; title=&quot;谈谈你对Java的理解&quot;&gt;&lt;/a&gt;谈谈你对Java的理解&lt;/h3&gt;&lt;p&gt;Java有两个显著的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平台无关性，也
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-装饰者模式</title>
    <link href="http://yoursite.com/2019/11/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/11/26/设计模式-装饰者模式/</id>
    <published>2019-11-26T11:23:38.000Z</published>
    <updated>2019-11-26T17:07:06.133Z</updated>
    
    <content type="html"><![CDATA[<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>在不改变原有对象的基础之上，将功能附加到对象，提供了比继承更具有弹性</p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蛋糕</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cake</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通的蛋糕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装饰者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Product product)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.product = product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//颜色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Color</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"上颜色"</span>);</span><br><span class="line">        product.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Color(<span class="keyword">new</span> Cake()).produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我需要添加新的装饰类的时候，比如说，水果的装饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"添加水果"</span>);</span><br><span class="line">        product.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Fruit(<span class="keyword">new</span> Color(<span class="keyword">new</span> Cake())).produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UML类图：</p><img src="/2019/11/26/设计模式-装饰者模式/01.png"><p>装饰者模式使用的场景：</p><ul><li>扩展一个类的功能或给一个类添加附加职责</li><li>动态的给一个对象添加功能，这些功能可以再动态的撤销</li></ul><p>优点：</p><ul><li>比继承灵活，不改变原有对象的情况下给一个对象扩展功能</li><li>通过使用不同装饰类以及装饰类的 排列组合可以实现不同的效果</li><li>符合开闭原则</li></ul><p>缺点：</p><ul><li>会出现更多的类，增加程序的复杂性</li><li>动态装饰与多层装饰会更加复杂</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式&quot; class=&quot;headerlink&quot; title=&quot;装饰者模式&quot;&gt;&lt;/a&gt;装饰者模式&lt;/h3&gt;&lt;p&gt;在不改变原有对象的基础之上，将功能附加到对象，提供了比继承更具有弹性&lt;/p&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-外观模式</title>
    <link href="http://yoursite.com/2019/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/11/19/设计模式-外观模式/</id>
    <published>2019-11-18T16:42:14.000Z</published>
    <updated>2019-11-26T03:21:00.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式又叫做门面模式，提供了 一个统一的接口，用来访问子系统中的一群接口</p><p>外观模式定义了一个高层接口，让子系统更容易使用</p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//物流系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logistics</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发出快递"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支付系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产产品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        Pay pay = <span class="keyword">new</span> Pay();</span><br><span class="line">        Logistics logistics = <span class="keyword">new</span> Logistics();</span><br><span class="line"></span><br><span class="line">        product.produce();</span><br><span class="line">        pay.pay();</span><br><span class="line">        logistics.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样子使用，特别不好，我每次购买一个商品，调用者做了很多个步骤，然而这些步骤进行封装的，其次，如果购买商品的逻辑进行一个增加，需要在每一个调用的时候都重改代码，比较麻烦</p><p>其实门面模式，就是把子系统进行一个封装，放在一个更大的系统里面，比如，我这里新建一个Mall</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//商城类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mall</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="keyword">private</span> Pay pay = <span class="keyword">new</span> Pay();</span><br><span class="line">    <span class="keyword">private</span> Logistics logistics = <span class="keyword">new</span> Logistics();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        product.produce();</span><br><span class="line">        pay.pay();</span><br><span class="line">        logistics.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mall mall = <span class="keyword">new</span> Mall();</span><br><span class="line">        mall.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者不再关心细节的问题，而关心我需要做的那件事</p><p>UML类图</p><img src="/2019/11/19/设计模式-外观模式/01.png"><p>外观模式的优点：</p><ul><li>简化了调用过程</li><li>减少系统依赖</li><li>符合迪米特法则</li></ul><p>缺点：</p><ul><li>增加子系统，容易引入风险</li><li>不符合开闭原则</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;外观模式&quot;&gt;&lt;a href=&quot;#外观模式&quot; class=&quot;headerlink&quot; title=&quot;外观模式&quot;&gt;&lt;/a&gt;外观模式&lt;/h3&gt;&lt;p&gt;外观模式又叫做门面模式，提供了 一个统一的接口，用来访问子系统中的一群接口&lt;/p&gt;
&lt;p&gt;外观模式定义了一个高层接口，让子系
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Netty(一）</title>
    <link href="http://yoursite.com/2019/09/11/Netty(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/09/11/Netty(一)/</id>
    <published>2019-09-10T20:09:14.000Z</published>
    <updated>2019-09-17T08:56:34.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Netty初识"><a href="#Netty初识" class="headerlink" title="Netty初识"></a>Netty初识</h3><p>简单来说：Netty就是一个框架，为了使我们开发网络编程的时候可以更加简单</p><p>接下来介绍传统和Netty的对比，首先上场的是我们传统的网络编程</p><h3 id="BIO-Blocking-IO"><a href="#BIO-Blocking-IO" class="headerlink" title="BIO  (Blocking IO)"></a>BIO  (Blocking IO)</h3><p>BIO是一种同步阻塞的编程方式，由服务端开启线程来管理socket连接，优点就是简单</p><p>在JDK1.4之前通常都是这样子使用</p><p>缺点是支持的并发量不大，浪费线程资源</p><p>图示：</p><img src="/2019/09/11/Netty(一)/01.jpg"><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            String content = scanner.nextLine();</span><br><span class="line">            socket.getOutputStream().write(content.getBytes());</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"exit"</span>.equals(content))&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        socket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//阻塞</span></span><br><span class="line">            Socket accept = socket.accept();</span><br><span class="line">            <span class="keyword">new</span> HandlerThread(accept).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket accept;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(Socket accept)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.accept = accept;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="comment">//阻塞</span></span><br><span class="line">                    accept.getInputStream().read(bytes);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NIO-New-IO"><a href="#NIO-New-IO" class="headerlink" title="NIO (New IO)"></a>NIO (New IO)</h3><p>NIO是同步非阻塞的IO，JDK1.4后开始支持</p><p>这里大概说一下思路：解决非阻塞的问题，主要在两个，将两个阻塞的问题解决就可以了</p><p>NIO的核心是，将连接注册到多路复用器，然后轮询多路复用器是否有可用的连接，有则派线程来执行</p><p>所以线程准确来说是处理一个可用的（活跃的）Socket，大大提升效率</p><p>缺点：</p><p>当并发请求数量增大的时候，后端负载增大，虽然是非阻塞，但是是同步的，每个请求的等待时间就很长了</p><p>图示：</p><img src="/2019/09/11/Netty(一)/02.jpg"><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//开启多路复用器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 注册，并标记当前服务通道状态</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * register(Selector, int)</span></span><br><span class="line"><span class="comment"> * int - 状态编码</span></span><br><span class="line"><span class="comment"> *  OP_ACCEPT ： 连接成功的标记位。</span></span><br><span class="line"><span class="comment"> *  OP_READ ： 可以读取数据的标记</span></span><br><span class="line"><span class="comment"> *  OP_WRITE ： 可以写入数据的标记</span></span><br><span class="line"><span class="comment"> *  OP_CONNECT ： 连接建立后的标记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        SelectionKey selectionKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 阻塞方法，当至少一个通道被选中，此方法返回。</span></span><br><span class="line">            <span class="comment">// 通道是否可选择，由注册到多路复用器中的通道标记决定</span></span><br><span class="line">            <span class="keyword">int</span> count = selector.select();</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    <span class="comment">//判断通道是否合法</span></span><br><span class="line">                    <span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                            ServerSocketChannel socketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">                            SocketChannel accept = socketChannel.accept();</span><br><span class="line">                            accept.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            accept.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//判断通道是否可读</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            byteBuffer.clear();</span><br><span class="line">                            SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                            <span class="keyword">int</span> readLength = socketChannel.read(byteBuffer);</span><br><span class="line">                            <span class="keyword">if</span>(readLength == -<span class="number">1</span>)&#123;</span><br><span class="line">                                key.channel().close();</span><br><span class="line">                                key.channel();</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            byteBuffer.flip();</span><br><span class="line">                            String content = Charset.forName(<span class="string">"utf-8"</span>).decode(byteBuffer).toString();</span><br><span class="line">                            System.out.println(content);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AIO（Asynchronous-IO）"><a href="#AIO（Asynchronous-IO）" class="headerlink" title="AIO（Asynchronous IO）"></a>AIO（Asynchronous IO）</h3><p>异步非阻塞的IO，JDK1.7后开始支持</p><p>与NIO不同，read和write的操作都是异步的，当完成后，会主动调用回调函数，</p><p>服务器实现模式为一个有效请求一个线程，客户端的 I/O 请求都是由 OS先完成了再通知服务器应用去启动线程进行处理</p><p>图示：</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel channel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AioServer().Aio();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Aio</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        channel = AsynchronousServerSocketChannel.open();</span><br><span class="line">        channel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        channel.accept(<span class="keyword">this</span>,<span class="keyword">new</span> AioServerHandler());</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsynchronousServerSocketChannel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioServerHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">AioServer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, AioServer attachment)</span> </span>&#123;</span><br><span class="line">        attachment.getChannel().accept(attachment,<span class="keyword">this</span>);</span><br><span class="line">        doRead(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(AsynchronousSocketChannel channel)</span> </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        channel.read(byteBuffer, byteBuffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                attachment.flip();</span><br><span class="line">                System.out.println(Charset.forName(<span class="string">"utf-8"</span>).decode(byteBuffer).toString());</span><br><span class="line">                doRead(channel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, AioServer attachment)</span> </span>&#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就使用Netty来开发BIO和NIO</p><h3 id="BIO（Netty版本）"><a href="#BIO（Netty版本）" class="headerlink" title="BIO（Netty版本）"></a>BIO（Netty版本）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> OioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(group).channel(OioServerSocketChannel.class).localAddress(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ByteBuf in = (ByteBuf)msg;</span><br><span class="line">                                    System.out.println(<span class="string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">                                    ctx.write(in);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture f = bootstrap.bind().sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NIO-Netty版本"><a href="#NIO-Netty版本" class="headerlink" title="NIO (Netty版本)"></a>NIO (Netty版本)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//修改处1 NioEventLoopGroup</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//修改处2 NioServerSocketChannel</span></span><br><span class="line">            bootstrap.group(group).channel(NioServerSocketChannel.class).localAddress(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ByteBuf in = (ByteBuf)msg;</span><br><span class="line">                                    System.out.println(<span class="string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">                                    ctx.write(in);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture f = bootstrap.bind().sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现一个问题：就是从BIO和NIO的之间切换很简单的，这就是Netty封装后的效果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Netty初识&quot;&gt;&lt;a href=&quot;#Netty初识&quot; class=&quot;headerlink&quot; title=&quot;Netty初识&quot;&gt;&lt;/a&gt;Netty初识&lt;/h3&gt;&lt;p&gt;简单来说：Netty就是一个框架，为了使我们开发网络编程的时候可以更加简单&lt;/p&gt;
&lt;p&gt;接下来介绍
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized详解</title>
    <link href="http://yoursite.com/2019/09/03/Synchronized%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/03/Synchronized详解/</id>
    <published>2019-09-03T14:28:44.000Z</published>
    <updated>2019-09-06T13:18:18.719Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Synchronized详解"><a href="#Synchronized详解" class="headerlink" title="Synchronized详解"></a>Synchronized详解</h3><p>先看一个程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T03 t = <span class="keyword">new</span> T03();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;t.consume()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现的结果，是不符合预期的</p><img src="/2019/09/03/Synchronized详解/01.png"><p>这就是多线程下产生的问题，解决的方案也很简单，加锁，这里讲解Synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将方法改成这样子就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) count--;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁的目的：使得临界资源被线程同步互斥访问，就是某一个时刻只允许一个线程访问资源</p><p>重要的是下面：</p><h3 id="深入字节码"><a href="#深入字节码" class="headerlink" title="深入字节码"></a>深入字节码</h3><p>javap -c T03.class</p><img src="/2019/09/03/Synchronized详解/02.png"><p>可以查看一下字节码指令，我之前收录了一下</p><p><a href="https://blog.csdn.net/qq_36457148/article/details/100521282" target="_blank" rel="noopener">https://blog.csdn.net/qq_36457148/article/details/100521282</a></p><table><thead><tr><th>monitorenter</th><th></th><th>进入并获得对象监视器。</th></tr></thead><tbody><tr><td><strong>monitorexit</strong></td><td></td><td><strong>释放并退出对象监视器。</strong></td></tr></tbody></table><p><strong>如果你使用的是同步方法，就是将synchronized修饰在方法上的，对应的是invokevirtual</strong></p><p>所以说Synchronized是通过Monitor来实现锁的</p><h3 id="JVM对象加锁原理"><a href="#JVM对象加锁原理" class="headerlink" title="JVM对象加锁原理"></a>JVM对象加锁原理</h3><p>首先引入的是</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><img src="/2019/09/03/Synchronized详解/03.jpg"><p>其中对象头是比较重要的：这里再贴张图描述一下对象头</p><img src="/2019/09/03/Synchronized详解/04.jpg"><p>关于对象头我们可以通过代码验证一下</p><p>引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassLayout.parseInstance(<span class="keyword">new</span> Object()).toPrintable()<span class="comment">//查看对象的布局</span></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION       VALUE</span><br><span class="line">   <span class="comment">//00011010中最后的10代表锁的标记位</span></span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)   <span class="number">1</span>a <span class="number">05</span> <span class="number">7f</span> <span class="number">1</span>a (<span class="number">00011010</span> <span class="number">00000101</span> <span class="number">01111111</span> <span class="number">00011010</span>) (<span class="number">444531994</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)   <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)   <span class="number">05</span> c1 <span class="number">00</span> f8 (<span class="number">00000101</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168315</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br></pre></td></tr></table></figure><p>以下是HotSpot虚拟机的描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br></pre></td></tr></table></figure><p>这里要注意一下，Java默认是使用大端模式，所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放</p><p>就是最后1个字节，其实打印出来应该是放在第一个字节</p><h4 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h4><p>锁的状态有四种</p><ul><li>无锁</li><li>偏向锁，只有一个线程的情况下</li><li>轻量级锁，多线程下竞争不激烈的情况下</li><li>重量级锁，多线程竞争的情况下</li></ul><p>随着场景的不同，锁的状态是会发生变化的</p><p>根据上述对象头的最后三位就能确定现在是有锁还是无锁</p><p>如果是有锁是什么状态的锁，都是更具对象投来进行判断的</p><p>我上一张图来描述一下锁转换的过程</p><img src="/2019/09/03/Synchronized详解/05.jpg"><p>如何验证图中所说的，我们可以结合上述打印对象头来确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T04 t = <span class="keyword">new</span> T04();</span><br><span class="line">        <span class="comment">//无锁</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(t).toPrintable());</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(t::test01).start();</span><br><span class="line">        <span class="comment">//轻量锁</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(t).toPrintable());</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(t::test01).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重量级锁</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(t).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面缺失了个偏向锁，也不太清楚原因</p><h3 id="为什么要设计锁的升级过程"><a href="#为什么要设计锁的升级过程" class="headerlink" title="为什么要设计锁的升级过程"></a>为什么要设计锁的升级过程</h3><p>synchronized轻量级锁没有使用互斥量，如果学过操作系统，应该能够理解互斥量的概念，使用互斥量是比较重的一个操作，有一个上下文切换，系统的内核态和用户态的切换，比较重</p><h3 id="CAS指令"><a href="#CAS指令" class="headerlink" title="CAS指令"></a>CAS指令</h3><p>在Synchronized里面设计了很多CAS（Compare-and-Swap）</p><p>这里稍微介绍一下，CAS的作用是用来保证原子性，保证该操作不会被打断</p><blockquote><p>在使用上，通常会记录下某块内存中的<em>旧值</em>，通过对<em>旧值</em>进行一系列的操作后得到<em>新值</em>，然后通过CAS操作将<em>新值</em>与<em>旧值</em>进行交换。如果这块内存的值在这期间内没被修改过，则<em>旧值</em>会与内存中的数据相同，这时CAS操作将会成功执行使内存中的数据变为<em>新值</em>。如果内存中的值在这期间内被修改过，则一般来说<em>旧值</em>会与内存中的数据不同，这时CAS操作将会失败，<em>新值</em>将不会被写入内存</p></blockquote><p>这里用自己的话说一下，A的值为1，在主内存当中，将A的值设置为2的时候，设置一个副本记录A修改前的值（这里叫A~），如果A~与主内存的值，就将A的值去进行覆盖，否则则不覆盖</p><p>CAS指令很简单，但是会有以下三个问题</p><ol><li><p>循环时间长开销很大</p><p>如果CAS指令判断失败，会继续尝试，增加CPU的负担</p></li><li><p>只能保证一个共享变量的原子操作</p></li><li><p>ABA问题</p><p>举个例子，A的值是1，修改成2再修改成1，用CAS判断是误以为没有其余线程修改过内存的值，其实是已经被修改过了</p></li></ol><p>ABA导致的问题，引入维基百科的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   top</span><br><span class="line">    |</span><br><span class="line">    V   </span><br><span class="line">  0x0014</span><br><span class="line">| Node A | --&gt; |  Node X | --&gt; ……</span><br></pre></td></tr></table></figure><p>有一个堆(先入后出)中有top和节点A，节点A目前位于堆顶top指针指向A。现在有一个进程P1想要pop一个节点，因此按照如下无锁操作进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pop()</span><br><span class="line">&#123;</span><br><span class="line">  do&#123;</span><br><span class="line">    ptr = top;            // ptr = top = NodeA</span><br><span class="line">    next_prt = top-&gt;next; // next_ptr = NodeX</span><br><span class="line">  &#125; while(CAS(top, ptr, next_ptr) != true);</span><br><span class="line">  return ptr;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而进程P2在执行CAS操作之前打断了P1，并对堆进行了一系列的pop和push操作，使堆变为如下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   top</span><br><span class="line">    |</span><br><span class="line">    V  </span><br><span class="line">  0x0014</span><br><span class="line">| Node C | --&gt; | Node B | --&gt; |  Node X | --&gt; ……</span><br></pre></td></tr></table></figure><p>进程P2首先pop出NodeA，之后又Push了两个NodeB和C，由于内存管理机制中广泛使用的内存重用机制，导致NodeC的地址与之前的NodeA一致。</p><p>这时P1又开始继续运行，在执行CAS操作时，由于top依旧指向的是NodeA的地址(实际上已经变为NodeC)，因此将top的值修改为了NodeX，这时堆结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                                  top</span><br><span class="line">                                   |</span><br><span class="line">  0x0014                           V</span><br><span class="line">| Node C | --&gt; | Node B | --&gt; |  Node X | --&gt; ……</span><br></pre></td></tr></table></figure><p>经过CAS操作后，top指针错误的指向了NodeX而不是NodeB。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Synchronized详解&quot;&gt;&lt;a href=&quot;#Synchronized详解&quot; class=&quot;headerlink&quot; title=&quot;Synchronized详解&quot;&gt;&lt;/a&gt;Synchronized详解&lt;/h3&gt;&lt;p&gt;先看一个程序：&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Volatile详解</title>
    <link href="http://yoursite.com/2019/08/28/Volatile%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/08/28/Volatile详解/</id>
    <published>2019-08-27T20:04:13.000Z</published>
    <updated>2019-09-03T06:33:52.534Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍Volatile之前，我们要来先看一段程序(抛砖引玉),最好自己跑一遍程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        myThread.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123; &#125;</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果是不会输出end</p><p>很奇怪吧，不符合逻辑，接下来我们就引入我们的第一个知识点：</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><img src="/2019/08/28/Volatile详解/01.jpg"><p>简单描述，就是每个线程会有一个私有的本地内存，存放主内存的副本，这样子可以加快线程读的速度</p><p>那么线程之间如何进行通信呢？引出我们第二个知识点</p><h3 id="Java线程之间的通信"><a href="#Java线程之间的通信" class="headerlink" title="Java线程之间的通信"></a>Java线程之间的通信</h3><img src="/2019/08/28/Volatile详解/02.jpg"><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作以及八种规则来完成</p><img src="/2019/08/28/Volatile详解/03.png"><p>这里面其实会有个隐含的问题，假设线程A修改一个值后存进内存，B线程同时去读主内存会发生什么呢？</p><p>1.A修改执行assign操作</p><p>2.B读执行read操作和load操作</p><p>3.A存进内存执行store操作和write操作</p><p><strong>数据不一致</strong></p><p>解决这个问题我们很自然能够想到的就是：锁</p><p>由于锁是相对比较重量级，能不能不用锁呢？这里就到第三个知识点了：</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>Volatile有一个特性：<strong>可见性</strong></p><p>什么是可见性，简单来说当一个线程修改了一个值，这个值对别的线程都是可以看见的，去读的时候都能读到这个新的值</p><p>为什么能够保证可见性</p><p>第四个知识点：</p><h3 id="Happens-before原则"><a href="#Happens-before原则" class="headerlink" title="Happens-before原则"></a>Happens-before原则</h3><blockquote><p>Two actions can be ordered by a <em>happens-before</em> relationship. If one action <em>happens-before</em> another, then the first is visible to and ordered before the second.</p><p>If we have two actions <em>x</em> and <em>y</em>, we write <em>hb(x, y)</em> to indicate that <em>x happens-before y</em> —Java8官方文档</p></blockquote><p>Java8关于happens-before文档：<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5</a></p><p>如果一个事件的发生在另一个事件之前，其结果必须反应出来，记住这句话就好了</p><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//事件1</span></span><br><span class="line"><span class="keyword">int</span> b = a + <span class="number">1</span>;<span class="comment">//事件2</span></span><br></pre></td></tr></table></figure><p>事件1发生在事件2之前，所以其结果是什么？a=1,b=2，,不管如何优化,这个结果一定要反映出来，所以一定要先执行1后执行2才可以有这个结果</p><p>举个反例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//事件1</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;<span class="comment">//事件2</span></span><br></pre></td></tr></table></figure><p>事件1发生在事件2之前，所以其结果是什么？a=1,b=2,这个结果一定要反映出来,此时就有两种可能，基于优化的考虑，我可能先执行1后执行2，或者反过来，其结果都是不会发生改变的</p><p>在官方文档里面有描述happens before遵循的规则</p><p>其中一条是：</p><blockquote><p>A write to a <code>volatile</code> field (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.4" target="_blank" rel="noopener">§8.3.1.4</a>) <em>happens-before</em> every subsequent read of that field</p></blockquote><p>对于一个volatile字段进行写操作会 happens-before 任意操作</p><p>讲到这里我们再去扒一扒底层，字节码？不，是汇编</p><p>我这里将程序修改成如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java -server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*T01.setData</span></span><br><span class="line"><span class="comment">//只查看setData的汇编</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        myThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        setData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        myThread.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000002c9dbc9</span>: lock add dword ptr [rsp],<span class="number">0</span>h  ;*putfield flag</span><br><span class="line">                                               ; - example.t09.T01::setData@<span class="number">4</span> (line <span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>这句话的意思呢，是指使得本CPU的Cache写入了内存，该写入动作也会引起别的CPU失效其Cache，所以通过这样一个操作，可让前面volatile变量的修改对其他CPU立即可见</p><p>简单来说：</p><ol><li>锁内存</li><li>写内存</li><li>让其余的缓存该值失效</li></ol><p><strong>讲到这里就是为了讲解volatile有可见性</strong></p><p>返回到我们的第一个程序为什么会死循环，也是因为一个线程的修改不能使得另一个线程立刻知道，所以才会导致死循环</p><p>但是严谨来说其实是因为JIT编译的优化，大概是觉得一直循环读值，所以就优化成直接从缓存取值，所以才会导致这种问题</p><p>大家可以试试 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.compiler=NONE &lt;<span class="class"><span class="keyword">class</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样子其实也不会有问题的，但是少了JIT优化，还是不太好的</p><p>只需要加上volatile修饰就可以解决问题了</p><p>但是volatile不单纯是解决可见性问题</p><p>第五个知识点：</p><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>指令重排就是为了提升程序执行的效率，会按照一定的规则将指令的顺序进行重排，但是不能影响语义</p><p>比如说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a+b;</span><br></pre></td></tr></table></figure><p>前两条指令是可以重排的，无论谁先都可以，第三条指令必须在这两条指令的后面，因为第三条指令会依赖前两条指令，所以第三条指令是不会被重排的</p><p>来看一段程序，参考《Java并发编程实战》</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (ready)&#123;Thread.yield(); &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似结果输出是42，但是实则不然，答案应该有两个，42或者0</p><p>为什么会输出0，这就是因为指令重排，number = 42 和 ready = false 没有依赖关系，所以这两条指令有可能会互换位置（编译器基于性能的考虑），假设互换位置后，则输出的结果就应该是0了</p><p>其实还有另一种可能就是死循环了，上面也提到了，这是可见性问题</p><p>volatile的第二个作用就是可以防止指令重排</p><p>内存屏障：使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行</p><blockquote><p>内存屏障可以被分为以下几种类型：</p><ol><li><strong>LoadLoad屏障：</strong>对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreStore屏障：</strong>对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li><strong>LoadStore屏障：</strong>对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreLoad屏障：</strong>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li></ol></blockquote><p>很多文章都有说到内存屏障但是都没有出处，我也找了很久终于找到了：</p><p><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a></p><p>在一个变量被volatile修饰后，JVM会为我们做两件事：</p><p>1.在每个volatile写操作前插入<strong>StoreStore</strong>屏障，在写操作后插入<strong>StoreLoad</strong>屏障</p><p>2.在每个volatile读操作前插入<strong>LoadLoad</strong>屏障，在读操作后插入<strong>LoadStore</strong>屏障</p><p>贴一张图来说明一下</p><img src="/2019/08/28/Volatile详解/04.png"><p>最后一个特性是：</p><h3 id="double和long的非原子性处理"><a href="#double和long的非原子性处理" class="headerlink" title="double和long的非原子性处理"></a>double和long的非原子性处理</h3><blockquote><p>某些 Java内存模型实现可能发现将对 64 位 long 或 double 值的写操作分成两次相邻的 32位值写操作更方便。为了效率起见，这种行为是实现可以自行决定的。JavaTM 虚拟机可以自由地决定是原子性的对待 long 和 double 值的写操作还是一分为二的对待。<br>鉴于本内存模型的目的，我们将对非 volatile long 或 double 值的单次写操作视作两次分开的写操作：每次 32 位。这可能会导致一种情况，某个线程会看到某次写操作中 64 位的前 32 位，以及另外一次写操作的后 32 位。读写 volatile 的 long 和double 总是原子的。读写引用也总是原子的，而不管引用的实现采用的是 32 位还<br>是 64 位。<br>我们鼓励 VM 的实现者尽可能避免将 64 位值的写操作分开。鼓励编码人员将共享<br>的 64 位值声明为 volaitle 的或将其程序正确同步以避免可能的并发问题</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在介绍Volatile之前，我们要来先看一段程序(抛砖引玉),最好自己跑一遍程序&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM---字节码指令</title>
    <link href="http://yoursite.com/2019/08/22/JVM---%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/08/22/JVM---字节码指令操作/</id>
    <published>2019-08-22T12:25:33.000Z</published>
    <updated>2019-08-25T01:10:46.135Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iconst_m1   将int型的m1推送至栈顶</span><br><span class="line">iload_m 将指定的第m个int型本地变量推送至栈顶</span><br><span class="line">以上使用i来代表int</span><br><span class="line">d:double,f:float</span><br><span class="line">a:Reference,l:long</span><br><span class="line">ps:当int 取值-1~5 采用iconst 指令，取值-128~127 采用bipush 指令，取值-32768~32767 采用sipush 指令，取值-2147483648~2147483647 采用ldc 指令</span><br></pre></td></tr></table></figure><img src="/2019/08/22/JVM---字节码指令操作/01.jpg"><p>上一个Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">int</span> c = i + j;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用javap来分解一下</span><br><span class="line">javap -verbose Demo.class &gt; Demo.txt</span><br></pre></td></tr></table></figure><p>打开Demo.txt,截取一部分</p><p>JVM执行字节码指令的时候基于栈结构的</p><p>我们重点看的是Code后面的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量池</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#14         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #15.#16        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #17.#18        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #4 = Class              #19            // Demo</span><br><span class="line">   #5 = Class              #20            // java/lang/Object</span><br><span class="line">   #6 = Utf8               &lt;init&gt;</span><br><span class="line">   #7 = Utf8               ()V</span><br><span class="line">   ......</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">    <span class="comment">//操作数栈最大深度，本地变量表最大长度（64位操作系统为2其余为1），参数个数</span></span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    <span class="comment">//字节码</span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">11</span>  <span class="comment">//将11入栈</span></span><br><span class="line">         <span class="number">2</span>: istore_1 <span class="comment">//取出栈顶元素存进本地变量1</span></span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">12</span> <span class="comment">//将12入栈</span></span><br><span class="line">         <span class="number">5</span>: istore_2     <span class="comment">//取出栈顶元素存进本地变量2</span></span><br><span class="line">         <span class="number">6</span>: iload_1          <span class="comment">//把本地变量1入栈</span></span><br><span class="line">         <span class="number">7</span>: iload_2          <span class="comment">//把本地变量2入栈</span></span><br><span class="line">         <span class="number">8</span>: iadd             <span class="comment">//把栈顶取两个元素进行加法，进行入栈</span></span><br><span class="line">         <span class="number">9</span>: istore_3         <span class="comment">//取出栈顶元素存进本地变量3</span></span><br><span class="line">        10: getstatic     #2 //调用System.out   // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">13</span>: iload_3          <span class="comment">//把本地变量3入栈</span></span><br><span class="line">        14: invokevirtual #3//print语句                // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">17</span>: <span class="keyword">return</span>          <span class="comment">//返回值</span></span><br><span class="line">      <span class="comment">//行号表，第一个数字代表代码的行号，第二个数字代表字节码的行号</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM---bTrace</title>
    <link href="http://yoursite.com/2019/08/22/bTrace/"/>
    <id>http://yoursite.com/2019/08/22/bTrace/</id>
    <published>2019-08-21T17:35:09.000Z</published>
    <updated>2019-08-25T01:03:27.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BTrace"><a href="#BTrace" class="headerlink" title="BTrace"></a>BTrace</h2><p>BTrace可用于动态跟踪正在运行的Java程序（类似于OpenSolaris应用程序和操作系统的DTrace）。BTrace动态检测目标应用程序的类以注入跟踪代码（“字节码跟踪”）</p><p>不用修改源代码，既可以追踪Java程序</p><p>如果使用远程Debug，会对线上的项目产生巨大影响</p><p>编写BTrace 脚本时，也有如下约定：</p><ol><li>不能创建对象，数组</li><li>不能throw，catch 异常</li><li>不能有循环(for，while，do..while)</li><li>不能实现接口</li><li>不能有同步块及同步方法</li><li>不能有断言语句</li><li>不能有外部，内部，嵌套 或本地类</li><li>不能进行任何实例好或静态方法调用，只能从com.sun.btrace.BtraceUtils类的公共静态方法</li><li>……</li></ol><p>下载地址：<a href="https://github.com/btraceio/btrace/releases/tag/v1.3.11.3" target="_blank" rel="noopener">https://github.com/btraceio/btrace/releases/tag/v1.3.11.3</a></p><p>下载Btrace对应的版本后进行解压</p><p>在环境变量中自行配置（我这里写的是Windows下）</p><p>BTRACE_HOME=bTrace的安装路径</p><p>%BTRACE_HOME%\bin</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTraceDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//public static void test02(User user)&#123;&#125; 在打印复杂类型的例子里开启</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String  <span class="title">test01</span><span class="params">(String name)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> User(name);</span><br><span class="line">        test02(user);</span><br><span class="line">        <span class="comment">//int i = 1 / 0;在Kind.THROW的例子里开启</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">15</span>);</span><br><span class="line">        System.out.println(test01(<span class="string">"aaa"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTraceMonitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnMethod</span>(</span><br><span class="line">            clazz = <span class="string">"BTraceDemo"</span>,<span class="comment">//类名</span></span><br><span class="line">            method = <span class="string">"test01"</span>,<span class="comment">//方法名</span></span><br><span class="line">            location = <span class="meta">@Location</span>(Kind.ENTRY)<span class="comment">//在方法进入的时候进行拦截</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@ProbeClassName String className, @ProbeMethodName String methodName, AnyType args[])</span></span>&#123;</span><br><span class="line">        BTraceUtils.println(<span class="string">"className: "</span>+className);<span class="comment">//打印类名</span></span><br><span class="line">        BTraceUtils.println(<span class="string">"methodName: "</span>+methodName);<span class="comment">//打印方法名</span></span><br><span class="line">        BTraceUtils.printArray(args);<span class="comment">//打印参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一：首先运行BTraceDemo</p><p>然后使用jps - l查询到pid，进行追踪</p><img src="/2019/08/22/bTrace/01.jpg"><p>一般为了在IDE工具上打bTrace代码更加方便，通常需要引入一下jar包</p><p>贴一下我的项目结构：</p><img src="/2019/08/22/bTrace/02.png"><p>Maven的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.sun.tools.btrace&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;btrace-boot&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.3.11.3&lt;/version&gt;</span><br><span class="line">           &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">           &lt;systemPath&gt;$&#123;basedir&#125;/src/main/resources/lib/btrace-boot.jar&lt;/systemPath&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.sun.tools.btrace&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;btrace-client&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.3.11.3&lt;/version&gt;</span><br><span class="line">           &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">           &lt;systemPath&gt;$&#123;basedir&#125;/src/main/resources/lib/btrace-boot.jar&lt;/systemPath&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.sun.tools.btrace&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;btrace-agent&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.3.11.3&lt;/version&gt;</span><br><span class="line">           &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">           &lt;systemPath&gt;$&#123;basedir&#125;/src/main/resources/lib/btrace-boot.jar&lt;/systemPath&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="btrace的一些用法："><a href="#btrace的一些用法：" class="headerlink" title="btrace的一些用法："></a>btrace的一些用法：</h3><h4 id="拦截方法："><a href="#拦截方法：" class="headerlink" title="拦截方法："></a>拦截方法：</h4><p>普通方法:@OnMethod(clazz=””,method=””)</p><p>上面的Demo已经写过了</p><p>构造函数:@OnMethod(clazz=””,method=”<init>“)</init></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTraceMonitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz = <span class="string">"User"</span>,method = <span class="string">"&lt;init&gt;"</span>,location = <span class="meta">@Location</span>(Kind.ENTRY))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@ProbeClassName String className, @ProbeMethodName String methodName, String name)</span></span>&#123;</span><br><span class="line">        BTraceUtils.print(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拦截时机"><a href="#拦截时机" class="headerlink" title="拦截时机"></a>拦截时机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Kind.ENTRY ：入口</span><br><span class="line">Kind.RETURN：返回</span><br><span class="line">Kind.THROW：异常</span><br><span class="line">Kind.Line：行</span><br></pre></td></tr></table></figure><h5 id="Kind-ENTRY"><a href="#Kind-ENTRY" class="headerlink" title="Kind.ENTRY"></a>Kind.ENTRY</h5><p>上面已经演示过了</p><h5 id="Kind-RETURN"><a href="#Kind-RETURN" class="headerlink" title="Kind.RETURN"></a>Kind.RETURN</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTraceMonitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz = <span class="string">"BTraceDemo"</span>, method = <span class="string">"test01"</span>, location = <span class="meta">@Location</span>(Kind.RETURN))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@ProbeClassName String className, @ProbeMethodName String methodName,@Return String value)</span></span>&#123;</span><br><span class="line">        BTraceUtils.print(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Kind-THROW"><a href="#Kind-THROW" class="headerlink" title="Kind.THROW"></a>Kind.THROW</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTraceMonitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TLS</span></span><br><span class="line">    <span class="keyword">static</span> Throwable currentException;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"java.lang.Throwable"</span>, method=<span class="string">"&lt;init&gt;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow</span><span class="params">(@Self Throwable self)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new Throwable()</span></span><br><span class="line">        currentException = self; &#125;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"java.lang.Throwable"</span>, method=<span class="string">"&lt;init&gt;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow1</span><span class="params">(@Self Throwable self, String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new Throwable(String msg)</span></span><br><span class="line">        currentException = self; &#125;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"java.lang.Throwable"</span>, method=<span class="string">"&lt;init&gt;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow1</span><span class="params">(@Self Throwable self, String s, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new Throwable(String msg, Throwable cause)</span></span><br><span class="line">        currentException = self; &#125;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"java.lang.Throwable"</span>, method=<span class="string">"&lt;init&gt;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow2</span><span class="params">(@Self Throwable self, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new Throwable(Throwable cause)</span></span><br><span class="line">        currentException = self; &#125;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"java.lang.Throwable"</span>, method=<span class="string">"&lt;init&gt;"</span>, location=<span class="meta">@Location</span>(Kind.RETURN))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrowreturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentException != <span class="keyword">null</span>) &#123;</span><br><span class="line">            BTraceUtils.Threads.jstack(currentException);</span><br><span class="line">            BTraceUtils.println(<span class="string">"====================="</span>);</span><br><span class="line">            currentException = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kind.LINE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTraceMonitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz = <span class="string">"BTraceDemo"</span>, method = <span class="string">"test01"</span>, location = <span class="meta">@Location</span>(value = Kind.LINE,line = N<span class="comment">//自己写自己要监控的行数))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> line)</span></span>&#123;</span><br><span class="line">        BTraceUtils.print(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印复杂类型"><a href="#打印复杂类型" class="headerlink" title="打印复杂类型"></a>打印复杂类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTraceMonitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz = <span class="string">"BTraceDemo"</span>, method = <span class="string">"test02"</span>, location = <span class="meta">@Location</span>(value = Kind.ENTRY))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        BTraceUtils.printFields(user);</span><br><span class="line">        Field field = BTraceUtils.field(<span class="string">"User"</span>, <span class="string">"name"</span>);</span><br><span class="line">        BTraceUtils.printFields(BTraceUtils.get(field,user));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果报错找不到User类则 执行脚本修改为：bTrace -cp "字节码存放的路径" pid BTraceMonitor.java</span></span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><strong>BTrace对字节码的修改不可逆</strong></p><p><strong>默认只能监控本地Java进程</strong></p><p><strong>如果想要监控远程Java进程，需要修改源代码</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BTrace&quot;&gt;&lt;a href=&quot;#BTrace&quot; class=&quot;headerlink&quot; title=&quot;BTrace&quot;&gt;&lt;/a&gt;BTrace&lt;/h2&gt;&lt;p&gt;BTrace可用于动态跟踪正在运行的Java程序（类似于OpenSolaris应用程序和操作系统的DTrac
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security源码分析(一)</title>
    <link href="http://yoursite.com/2019/08/20/SpringSecurity---%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/08/20/SpringSecurity---源码分析(一)/</id>
    <published>2019-08-20T00:49:27.000Z</published>
    <updated>2019-08-25T13:24:09.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Security源码分析-一"><a href="#Spring-Security源码分析-一" class="headerlink" title="Spring Security源码分析(一)"></a>Spring Security源码分析(一)</h2><p>SpringSecurity基本原理是基于一个过滤器链<br>我们启动一个SpringSecurity项目，日志会打印过滤器<br><img src="/2019/08/20/SpringSecurity---源码分析(一)/01.png"></p><img src="/2019/08/20/SpringSecurity---源码分析(一)/02.jpg"><p>一共有十二个过滤器，大致介绍一下</p><ol><li>WebAsyncManagerIntegrationFilter将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成</li><li>SecurityContextPersistenceFilter 两个主要职责：请求来临时，创建SecurityContext安全上下文信息，请求结束时清空SecurityContextHolder。</li><li>HeaderWriterFilter (文档中并未介绍，非核心过滤器) 用来给http响应添加一些Header,比如X-Frame-Options, X-XSS-Protection*，X-Content-Type-Options.</li><li>CsrfFilter 在spring4这个版本中被默认开启的一个过滤器，用于防止csrf攻击</li><li>LogoutFilter 顾名思义，处理注销的过滤器<br>UsernamePasswordAuthenticationFilter 这个会重点分析，表单提交了username和password，被封装成token进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。</li><li>RequestCacheAwareFilter (文档中并未介绍，非核心过滤器) 内部维护了一个RequestCache，用于缓存request请求</li><li>SecurityContextHolderAwareRequestFilter 此过滤器对ServletRequest进行了一次包装，使得request具有更加丰富的API</li><li>AnonymousAuthenticationFilter 匿名身份过滤器</li><li>UsernamePasswordAuthenticationFilter 用户名密码过滤器，检验用户名和密码的</li><li>SessionManagementFilter 是和session相关的过滤器，内部维护了一个SessionAuthenticationStrategy，两者组合使用，常用来防止session-fixation protection attack，以及限制同一用户开启多个会话的数量</li><li>ExceptionTranslationFilter 直译成异常翻译过滤器，还是比较形象的，这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理，具体是那些类下面详细介绍</li><li>FilterSecurityInterceptor 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。</li></ol><p>最常用的就是<strong>UsernamePasswordAuthenticationFilter</strong> 了<br>接下来我们就对UsernamePasswordAuthenticationFilter进行一个源码分析</p><h3 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h3><p>核心方法:attemptAuthentication做了以下几件事情</p><ol><li>判断是不是post请求，不是则抛异常</li><li>获取用户名和密码，判空</li><li>构建UsernamePasswordAuthenticationToken（将权限和用户名和密码进行一个封装）</li><li>执行setDetails，将请求的信息存入token里</li><li>通过AuthenticationManager的authenticate()去进行校验</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(</span><br><span class="line"><span class="string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">&#125;</span><br><span class="line">String username = obtainUsername(request);</span><br><span class="line">String password = obtainPassword(request);</span><br><span class="line"><span class="keyword">if</span> (username == <span class="keyword">null</span>) &#123;</span><br><span class="line">username = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">password = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">username = username.trim();</span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">username, password);</span><br><span class="line"><span class="comment">// Allow subclasses to set the "details" property</span></span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而AuthenticationManager是一个接口，对应的实现类是ProviderManager,查看以下authenticate的实现方法</p><p>ProviderManager 中的List，会依照次序去认证，认证成功则立即返回，若认证失败则返回null，下一个AuthenticationProvider会继续尝试认证，如果所有认证器都无法认证成功，则<code>ProviderManager</code> 会抛出一个ProviderNotFoundException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">copyDetails(authentication, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以实现校验的过程的是AuthenticationProvider的实现类，比如使用表单验证的情况下，默认是使用DaoAuthenticationProvider<br><img src="/2019/08/20/SpringSecurity---源码分析(一)/03.png"><br>DaoAuthenticationProvider继承了AbstractUserDetailsAuthenticationProvider，authenticate方法是在AbstractUserDetailsAuthenticationProvider<br>authenticate方法做了什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.从缓存里取UserDetails信息</span></span><br><span class="line">UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"><span class="comment">//2.如果缓存没有则通过UserDetailsService去调取loadUserByUsername获取UserDeatails对象</span></span><br><span class="line">user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line"><span class="comment">//3.预检查,对UserDetails进行提前的检查，判断是否锁定，是否过期，是否可用</span></span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line"><span class="comment">//4.附加检查,判断是否有证书和是否有用passwordEncoder加密</span></span><br><span class="line">additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line"><span class="comment">//5.最后检查,判断证书是否过期</span></span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line"><span class="comment">//6.返回认证成功的信息</span></span><br><span class="line"><span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br></pre></td></tr></table></figure><p>createSuccessAuthentication(principalToReturn, authentication, user)源码：</p><p>重写组装了一个UsernamePasswordAuthenticationToken，和第一次的组装不一样的地方在于</p><p>添加了权限和设置了已验证的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次的组装</span></span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.principal = principal;</span><br><span class="line"><span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">setAuthenticated(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//第二次的组装</span></span><br><span class="line"><span class="keyword">super</span>(authorities);</span><br><span class="line"><span class="keyword">this</span>.principal = principal;</span><br><span class="line"><span class="keyword">this</span>.credentials = credentials;</span><br><span class="line"><span class="keyword">super</span>.setAuthenticated(<span class="keyword">true</span>); <span class="comment">// must use super, as we override</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Authentication <span class="title">createSuccessAuthentication</span><span class="params">(Object principal,</span></span></span><br><span class="line"><span class="function"><span class="params">Authentication authentication, UserDetails user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Ensure we return the original credentials the user supplied,</span></span><br><span class="line"><span class="comment">// so subsequent attempts are successful even with encoded passwords.</span></span><br><span class="line"><span class="comment">// Also ensure we return the original getDetails(), so that future</span></span><br><span class="line"><span class="comment">// authentication events after cache expiry contain the details</span></span><br><span class="line">UsernamePasswordAuthenticationToken result = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">principal, authentication.getCredentials(),</span><br><span class="line">authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">result.setDetails(authentication.getDetails());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程 一旦任何一处发送异常，都会被捕获AbstractAuthenticationProcessingFilter类里面捕获</p><ol><li>异常则调用unsuccessfulAuthentication()<ol><li>failureHandler.onAuthenticationFailure(request, response, failed);会调用自己写的failureHandler</li></ol></li><li>成功则调用successfulAuthentication(),<ol><li>successHandler.onAuthenticationSuccess(request, response, authResult);会调用自己写的successHandler</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//这里是UsernamePasswordAuthenticationFilter的最后返回值</span></span><br><span class="line">    authResult = attemptAuthentication(request, response);</span><br><span class="line">    <span class="keyword">if</span> (authResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// return immediately as subclass has indicated that it hasn't completed</span></span><br><span class="line">        <span class="comment">// authentication</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">    logger.error(</span><br><span class="line">        <span class="string">"An internal error occurred while trying to authenticate the user."</span>,</span><br><span class="line">        failed);</span><br><span class="line">    unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">    <span class="comment">// Authentication failed</span></span><br><span class="line">    unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Authentication success</span></span><br><span class="line"><span class="keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用登陆成功的处理器</span></span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br></pre></td></tr></table></figure><img src="/2019/08/20/SpringSecurity---源码分析(一)/04.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-Security源码分析-一&quot;&gt;&lt;a href=&quot;#Spring-Security源码分析-一&quot; class=&quot;headerlink&quot; title=&quot;Spring Security源码分析(一)&quot;&gt;&lt;/a&gt;Spring Security源码分析(一)
      
    
    </summary>
    
      <category term="Spring Security" scheme="http://yoursite.com/categories/Spring-Security/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JVM---内存溢出</title>
    <link href="http://yoursite.com/2019/08/06/JVM---%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2019/08/06/JVM---内存溢出/</id>
    <published>2019-08-05T16:28:57.000Z</published>
    <updated>2019-08-25T01:00:30.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java虚拟机结构模型："><a href="#Java虚拟机结构模型：" class="headerlink" title="Java虚拟机结构模型："></a>Java虚拟机结构模型：</h3><img src="/2019/08/06/JVM---内存溢出/01.png"><p>先普及几个指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx等价于-XX:InitialHeapSize 初始化堆内存</span><br><span class="line">-Xms等价于-XX:MaxHeapSize 最大堆内存</span><br></pre></td></tr></table></figure><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</strong></p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p><strong>如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-Xmx1M -Xms1M</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMStackOOM</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[]arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">           <span class="keyword">new</span> JVMStackOOM().start();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"Thread-135" Exception in thread "Thread-130" java.lang.OutOfMemoryError: Java heap space</span></span><br></pre></td></tr></table></figure><p>注明：单线程下无论是栈帧太大还是虚拟机容量太小，都是抛出StackOverflowError</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p><strong>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</strong></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xmx32M -Xms32M</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;HeapOOM&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HeapOOM());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></span><br></pre></td></tr></table></figure><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常</strong></p><p>这里使用的JDK8，JDK8以前是永久代，JDK8是元空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK8:-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</span></span><br><span class="line"><span class="comment"> * JDK7以下:-XX:PermSize=8m -XX:MaxPermSize=8m</span></span><br><span class="line"><span class="comment"> * 非堆内存溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">noHeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj, args1));</span><br><span class="line">            <span class="comment">//无限创建动态代理，生成Class对象</span></span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决内存溢出的办法"><a href="#解决内存溢出的办法" class="headerlink" title="解决内存溢出的办法"></a>解决内存溢出的办法</h4><h5 id="1-导出内存映像文件"><a href="#1-导出内存映像文件" class="headerlink" title="1.导出内存映像文件"></a>1.导出内存映像文件</h5><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用jmap -dump:format=b,file=heap.prof pid   (pid可以用jps查看)(这个方法只能记录当前的堆栈信息)</span><br></pre></td></tr></table></figure><img src="/2019/08/06/JVM---内存溢出/02.png"></li></ol><h5 id="2-使用MAT分析内存溢出"><a href="#2-使用MAT分析内存溢出" class="headerlink" title="2.使用MAT分析内存溢出"></a>2.使用MAT分析内存溢出</h5><p>下载链接： <a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a> </p><p>打开软件左上角File—&gt;Open Heap Dump—&gt;选择对应的hprof文件</p><img src="/2019/08/06/JVM---内存溢出/03.jpg"><p>怀疑的一个问题：主线程占了百分之97.3的内存，内存在“Java.Lang.Objult[]”的一个实例中累积</p><p>如果觉得不够清楚可以接着看别的地方：</p><img src="/2019/08/06/JVM---内存溢出/04.png"><img src="/2019/08/06/JVM---内存溢出/05.jpg"><img src="/2019/08/06/JVM---内存溢出/06.jpg"><p>这里可以看得更加清楚是哪个位置的哪个类的哪个变量引起的内存溢出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java虚拟机结构模型：&quot;&gt;&lt;a href=&quot;#Java虚拟机结构模型：&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机结构模型：&quot;&gt;&lt;/a&gt;Java虚拟机结构模型：&lt;/h3&gt;&lt;img src=&quot;/2019/08/06/JVM---内存溢出/
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM---jstack</title>
    <link href="http://yoursite.com/2019/08/06/JVM---jstack/"/>
    <id>http://yoursite.com/2019/08/06/JVM---jstack/</id>
    <published>2019-08-05T16:27:15.000Z</published>
    <updated>2019-08-25T01:00:23.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM之Jstack使用"><a href="#JVM之Jstack使用" class="headerlink" title="JVM之Jstack使用"></a>JVM之Jstack使用</h3><p><em>jstack</em>是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出Java 应用程序中线程堆栈信息</p><p>首先需要了解以下线程的几个状态</p><img src="/2019/08/06/JVM---jstack/01.jpg"><h4 id="解决CPU飙高问题"><a href="#解决CPU飙高问题" class="headerlink" title="解决CPU飙高问题"></a>解决CPU飙高问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; test()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; test()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>top指令能够实时显示系统中各个进程的资源占用状况</p><p>运行前的情况</p><img src="/2019/08/06/JVM---jstack/02.jpg"><p>运行后的情况</p><img src="/2019/08/06/JVM---jstack/03.png"><p>执行jstack命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 4468 &gt; 4468.txt</span><br></pre></td></tr></table></figure><p>查看该Pid下的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 4468 -H</span><br></pre></td></tr></table></figure><img src="/2019/08/06/JVM---jstack/04.png"><p>发现有两个线程的CPU利用率比较高</p><p>下载下来4468.txt查看一下</p><img src="/2019/08/06/JVM---jstack/05.jpg"><p>怎么去定位到我们的线程呢？</p><p>我们刚才可以查看到有两个线程的CPU利用率比较高分别的pid对应为4479和4478</p><p>要转为16进制，分别为：117f 和 117e</p><p>在4468.txt查看这两个数字去进行定位到该线程</p><img src="/2019/08/06/JVM---jstack/06.png"><p>根据Demo.test(Demo.java:12)可以明白问题的原因</p><h4 id="解决死锁问题"><a href="#解决死锁问题" class="headerlink" title="解决死锁问题"></a>解决死锁问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object object2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.test01()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.test02()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法还是一样，我们直接来看生成的txt文件</p><p>查看txt的末尾</p><img src="/2019/08/06/JVM---jstack/07.png"><p>找到一个死锁问题，并且对应的类和方法都写得很清楚，很容易就能排除这个问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JVM之Jstack使用&quot;&gt;&lt;a href=&quot;#JVM之Jstack使用&quot; class=&quot;headerlink&quot; title=&quot;JVM之Jstack使用&quot;&gt;&lt;/a&gt;JVM之Jstack使用&lt;/h3&gt;&lt;p&gt;&lt;em&gt;jstack&lt;/em&gt;是jdk自带的线程堆栈分析工具
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="http://yoursite.com/2019/08/04/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/04/HashMap源码分析/</id>
    <published>2019-08-03T22:58:38.000Z</published>
    <updated>2019-08-25T00:59:48.946Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><p>最简单的一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(&quot;a&quot;,&quot;a&quot;);</span><br></pre></td></tr></table></figure><p>从构造函数开始分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来执行put函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下hash函数做了什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析下hash算法(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16）</p><p>hashCode的值是32位二进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设h得到的值是：      10010001 10010101 10110000 11110001</span><br><span class="line">右移16位得到的值是:    00000000 00000000 10010001 10010101</span><br><span class="line">异或(同为0,不同为1)：  10010001 10010101 00100001 01100100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设h得到的值是：      10010001 00000000 00000000 00000000</span><br><span class="line">右移16位得到的值是:    00000000 00000000 00000000 10010001</span><br><span class="line">异或(同为0,不同为1)：  10010001 00000000 00000000 10010001</span><br></pre></td></tr></table></figure><p>通过这种方式，可以提高1的分布变得相对均匀一些</p><p>为什么要变得相对均匀呢?我们接着看</p><p>查看putVal的函数</p><p>由于代码比较长，我这里分段来显示且直接在代码里进行解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        //定义了一个Node数组，Node这个类里面包含了四个属性，hash值，Key，Value，指向下一个Node的指针</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        //对table进行一个判空操作，table是一个Node数组</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        //如果为空则走resize()</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">      ......（省略其余代码）</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>resize()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">//将table赋值给oldTab</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       //oldCap为0</span><br><span class="line">       int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">       int oldThr = threshold;</span><br><span class="line">       int newCap, newThr = 0;</span><br><span class="line">       //目前oldCap为0</span><br><span class="line">       ....（省略部分代码）</span><br><span class="line">       else &#123;</span><br><span class="line">       //赋值新的空间和新的阈值</span><br><span class="line">       //static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">       //DEFAULT_LOAD_FACTOR = 0.75f</span><br><span class="line">       //新的空间是16，新的阈值是12</span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       ....（省略部分代码）</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">       //申请16大小的空间</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">        ....（省略部分代码）</span><br><span class="line">       return newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>回到putVal函数</p><p>此时n得到的值为16</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">....（省略部分代码）</span><br><span class="line">//进行取余</span><br><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">....（省略部分代码）</span><br></pre></td></tr></table></figure><p>tab[i = (n - 1) &amp; hash]单独抽出来解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 16 二进制码:    0001 0000</span><br><span class="line">n-1=15：           0000 1111</span><br><span class="line">假设hash值是:       0000 0001</span><br><span class="line">取余运算后的结果是：  0000 0001</span><br></pre></td></tr></table></figure><p>当n是2的幂次方，减一后再去取余一定能保证，前面的都是0</p><p>这里就可以解决了一个问题，节约内存  而且进行与h操作的速度会很快</p><p>上面提到过为什么hash值要尽可能地均匀，如果尽可能地均匀，在这里进行取余运算的时候，hash冲突会降低</p><p>继续看源码回到putVal函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">//如果不为空，就插值</span><br><span class="line">tab[i] = newNode(hash, key, value, null);</span><br><span class="line">else&#123;</span><br><span class="line">//产生了Hash冲突</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">    //判断hash值，key，是否一致</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">     ....（省略部分代码）</span><br><span class="line">     //如果一致，将原先的key对应的值做一个替换</span><br><span class="line">     if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看源码回到putVal函数</p><p>假设hash值，key不是一致，另外一种冲突怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> //判断p是不是树形节点，至于TreeNode是什么呢？就是红黑树</span><br><span class="line"> else if (p instanceof TreeNode)</span><br><span class="line"> //如果是树形节点的，就按照红黑树的方式，插入节点</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">else &#123;</span><br><span class="line">//如果不是树形节点,以链表的方式，插入节点</span><br><span class="line">//这里有一个binCount计数，计算这个链表的长度</span><br><span class="line">    for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">        if ((e = p.next) == null) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, null);</span><br><span class="line">        //如果这个链表的长度大于8-1</span><br><span class="line">        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">        //接下来我们来看下treeifyBin</span><br><span class="line">        treeifyBin(tab, hash);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">   ....（省略部分代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看下treeifyBin()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">        int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        //判断是否为空和容量是不是太小</span><br><span class="line">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        //如果是，则要重新调整容量</span><br><span class="line">            resize();</span><br><span class="line">        //否则</span><br><span class="line">        else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        //将单链表转换成红黑树</span><br><span class="line">            ....（省略部分代码）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再回到我们的putVal函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (e != null) &#123; // existing mapping for key</span><br><span class="line">    V oldValue = e.value;</span><br><span class="line">    if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">    e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line">//修改的数量</span><br><span class="line">++modCount;</span><br><span class="line">//判断size（实际容量）是否大于阈值，初始值为12</span><br><span class="line">if (++size &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br></pre></td></tr></table></figure><p>再次回到resize()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">    //判断是否大于最大值，若已经大于最大值，则将阈值设置为Integer的最大值</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //否则，将阈值扩大一倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    ....（省略部分代码）</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    //生成新得一个容量数组</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    //将oldTab的节点插入到newTab中</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">       ....（省略部分代码）</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于get和remove方法在这里不过多讲解，相对于set的构建过程比较简单</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>HashMap包括了数组，链表，红黑树</li><li>数组容量为2的幂：<ol><li>提高运算速度</li><li>增加散列度，降低冲突</li><li>减少内存碎片</li></ol></li><li>hash函数：hashcode的高16位和低16位进行异或求模，增加散列度，降低冲突</li><li>插入冲突：通过单链表解决冲突，如果链表长度超过8，进行链表和红黑树的转换，以提高查询速度</li><li>扩容的条件：实际节点数大于容量的四分之三，扩容后进行数据排布</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HashMap源码分析&quot;&gt;&lt;a href=&quot;#HashMap源码分析&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码分析&quot;&gt;&lt;/a&gt;HashMap源码分析&lt;/h3&gt;&lt;p&gt;最简单的一个例子&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合支付宝-当面付(二)</title>
    <link href="http://yoursite.com/2019/08/02/SpringBoot%E6%95%B4%E5%90%88%E6%94%AF%E4%BB%98%E5%AE%9D-%E5%BD%93%E9%9D%A2%E4%BB%98(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2019/08/02/SpringBoot整合支付宝-当面付(二)/</id>
    <published>2019-08-02T09:51:10.000Z</published>
    <updated>2019-08-25T00:59:38.117Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/01.png"><p>在上一篇简单将一个支付宝Demo跑起来后，现在需要整合到我们的springBoot项目，虽然说是整合SpringBoot，但是，你SSM也都是可以的</p><p>我先简单写一个SpringBoot的Demo</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/02.png"><p>maven导入了一些与alipay相关的其余依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.10&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;commons-configuration&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;commons-configuration&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.10&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;commons-lang&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;core&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.8.5&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.3&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里注意一下：</p><p><strong>支付宝给的Demo的Gson是2.3.1版本，我这里使用SpringBoot2.x的时候需要修改为2.6版本以上</strong></p><p>主要是在··AlipayController里面</p><p>其实就是把支付宝的Demo里面的test_trade_precreate()函数引入进来而已</p><p>这里为了防止小伙伴出错，我这里贴一下我的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import com.alipay.api.AlipayResponse;</span><br><span class="line">import com.alipay.api.response.AlipayTradePrecreateResponse;</span><br><span class="line">import com.alipay.demo.trade.config.Configs;</span><br><span class="line">import com.alipay.demo.trade.model.ExtendParams;</span><br><span class="line">import com.alipay.demo.trade.model.GoodsDetail;</span><br><span class="line">import com.alipay.demo.trade.model.builder.AlipayTradePrecreateRequestBuilder;</span><br><span class="line">import com.alipay.demo.trade.model.result.AlipayF2FPrecreateResult;</span><br><span class="line">import com.alipay.demo.trade.service.AlipayTradeService;</span><br><span class="line">import com.alipay.demo.trade.service.impl.AlipayTradeServiceImpl;</span><br><span class="line">import com.alipay.demo.trade.utils.ZxingUtils;</span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author ymbcxb</span><br><span class="line"> * @title</span><br><span class="line"> * @Package com.example.demo</span><br><span class="line"> * @date 2019/8/2 10:10</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class AlipayController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static AlipayTradeService tradeService;</span><br><span class="line"></span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(AlipayController.class);</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/pay&quot;)</span><br><span class="line">    public String pay()&#123;</span><br><span class="line">        test_trade_precreate();</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        /** 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数</span><br><span class="line">         *  Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录</span><br><span class="line">         */</span><br><span class="line">        Configs.init(&quot;zfbinfo.properties&quot;);</span><br><span class="line"></span><br><span class="line">        /** 使用Configs提供的默认参数</span><br><span class="line">         *  AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new</span><br><span class="line">         */</span><br><span class="line">        tradeService = new AlipayTradeServiceImpl.ClientBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test_trade_precreate() &#123;</span><br><span class="line">        // (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线，</span><br><span class="line">        // 需保证商户系统端不能重复，建议通过数据库sequence生成，</span><br><span class="line">        String outTradeNo = &quot;tradeprecreate&quot; + System.currentTimeMillis()</span><br><span class="line">                + (long) (Math.random() * 10000000L);</span><br><span class="line"></span><br><span class="line">        // (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费”</span><br><span class="line">        String subject = &quot;xxx品牌xxx门店当面付扫码消费&quot;;</span><br><span class="line"></span><br><span class="line">        // (必填) 订单总金额，单位为元，不能超过1亿元</span><br><span class="line">        // 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】</span><br><span class="line">        String totalAmount = &quot;0.01&quot;;</span><br><span class="line"></span><br><span class="line">        // (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段</span><br><span class="line">        // 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】</span><br><span class="line">        String undiscountableAmount = &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">        // 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号)</span><br><span class="line">        // 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID</span><br><span class="line">        String sellerId = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        // 订单描述，可以对交易或商品进行一个详细地描述，比如填写&quot;购买商品2件共15.00元&quot;</span><br><span class="line">        String body = &quot;购买商品3件共20.00元&quot;;</span><br><span class="line"></span><br><span class="line">        // 商户操作员编号，添加此参数可以为商户操作员做销售统计</span><br><span class="line">        String operatorId = &quot;test_operator_id&quot;;</span><br><span class="line"></span><br><span class="line">        // (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持</span><br><span class="line">        String storeId = &quot;test_store_id&quot;;</span><br><span class="line"></span><br><span class="line">        // 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持</span><br><span class="line">        ExtendParams extendParams = new ExtendParams();</span><br><span class="line">        extendParams.setSysServiceProviderId(&quot;2088100200300400500&quot;);</span><br><span class="line"></span><br><span class="line">        // 支付超时，定义为120分钟</span><br><span class="line">        String timeoutExpress = &quot;120m&quot;;</span><br><span class="line"></span><br><span class="line">        // 商品明细列表，需填写购买商品详细信息，</span><br><span class="line">        List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;GoodsDetail&gt;();</span><br><span class="line">        // 创建一个商品信息，参数含义分别为商品id（使用国标）、名称、单价（单位为分）、数量，如果需要添加商品类别，详见GoodsDetail</span><br><span class="line">        GoodsDetail goods1 = GoodsDetail.newInstance(&quot;goods_id001&quot;, &quot;xxx小面包&quot;, 1000, 1);</span><br><span class="line">        // 创建好一个商品后添加至商品明细列表</span><br><span class="line">        goodsDetailList.add(goods1);</span><br><span class="line"></span><br><span class="line">        // 继续创建并添加第一条商品信息，用户购买的产品为“黑人牙刷”，单价为5.00元，购买了两件</span><br><span class="line">        GoodsDetail goods2 = GoodsDetail.newInstance(&quot;goods_id002&quot;, &quot;xxx牙刷&quot;, 500, 2);</span><br><span class="line">        goodsDetailList.add(goods2);</span><br><span class="line"></span><br><span class="line">        // 创建扫码支付请求builder，设置请求参数</span><br><span class="line">        AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder()</span><br><span class="line">                .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo)</span><br><span class="line">                .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body)</span><br><span class="line">                .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams)</span><br><span class="line">                .setTimeoutExpress(timeoutExpress)</span><br><span class="line">                //                .setNotifyUrl(&quot;http://www.test-notify-url.com&quot;)//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置</span><br><span class="line">                .setGoodsDetailList(goodsDetailList);</span><br><span class="line"></span><br><span class="line">        AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder);</span><br><span class="line">        switch (result.getTradeStatus()) &#123;</span><br><span class="line">            case SUCCESS:</span><br><span class="line">                log.info(&quot;支付宝预下单成功: )&quot;);</span><br><span class="line"></span><br><span class="line">                AlipayTradePrecreateResponse response = result.getResponse();</span><br><span class="line">                dumpResponse(response);</span><br><span class="line"></span><br><span class="line">                // 需要修改为运行机器上的路径</span><br><span class="line">                String filePath = String.format(&quot;F:/qr-%s.png&quot;,</span><br><span class="line">                        response.getOutTradeNo());</span><br><span class="line">                log.info(&quot;filePath:&quot; + filePath);</span><br><span class="line">                ZxingUtils.getQRCodeImge(response.getQrCode(), 256, filePath);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case FAILED:</span><br><span class="line">                log.error(&quot;支付宝预下单失败!!!&quot;);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case UNKNOWN:</span><br><span class="line">                log.error(&quot;系统异常，预下单状态未知!!!&quot;);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                log.error(&quot;不支持的交易状态，交易返回异常!!!&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 简单打印应答</span><br><span class="line">    private void dumpResponse(AlipayResponse response) &#123;</span><br><span class="line">        if (response != null) &#123;</span><br><span class="line">            log.info(String.format(&quot;code:%s, msg:%s&quot;, response.getCode(), response.getMsg()));</span><br><span class="line">            if (StringUtils.isNotEmpty(response.getSubCode())) &#123;</span><br><span class="line">                log.info(String.format(&quot;subCode:%s, subMsg:%s&quot;, response.getSubCode(),</span><br><span class="line">                        response.getSubMsg()));</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(&quot;body:&quot; + response.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用函数的时候，因为我这里只是个Demo，没做太多操作，请小伙伴们根据自己的实际情况进行传参</p><p><strong>强调一点 ZxingUtils.getQRCodeImge(response.getQrCode(), 256, filePath);是生成的二维码</strong></p><p><strong>要扫这个工具生成的二维码才可以</strong></p><p>重点：</p><p>上支付宝官方的图</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/03.png"><p>支付成功后的回调！当我们支付成功的时候，支付宝会根据我们事先定义好的接口，发起回调，前提是这个接口必须是公网可以访问的才行，有两种方法，申请一个公网Ip地址，或者使用内网穿透，这里我来使用一下内网穿透，内网穿透的工具很多，关于内网穿透的知识，可以参看我的另外一篇博客 内网穿透</p><p>这里我设置一下我的回调接口</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/04.png"><p>写个Controller进行Debug</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/05.png"><p>运行项目，进行一次支付，可以接收到回调</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/06.png"><p>官方文档：<a href="https://docs.open.alipay.com/203/105286/" target="_blank" rel="noopener">https://docs.open.alipay.com/203/105286/</a>有关异步回调的一些说明</p><p>我把一些注意点强调一下：</p><ol><li><strong>程序执行完后必须打印输出“success”（不包含引号）。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）</strong></li><li><strong>程序执行完成后，该页面不能执行页面跳转。如果执行页面跳转，支付宝会收不到success字符，会被支付宝服务器判定为该页面程序运行出现异常，而重发处理结果通知</strong></li><li><strong>cookies、session等在此页面会失效，即无法获取这些数据</strong></li></ol><img src="/2019/08/02/SpringBoot整合支付宝-当面付(二)/07.png"><p>按照步骤做就可以了</p><p>我这里直接贴代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/alipay_callback&quot;)</span><br><span class="line">    public Object alipayCallback(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();</span><br><span class="line">        Map requestParams = request.getParameterMap();</span><br><span class="line">        for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">            String name = (String) iter.next();</span><br><span class="line">            String[] values = (String[]) requestParams.get(name);</span><br><span class="line">            String valueStr = &quot;&quot;;</span><br><span class="line">            for (int i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">                valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            params.put(name, valueStr);</span><br><span class="line">        &#125;</span><br><span class="line">        if(params == null || params.size() == 0)&#123;</span><br><span class="line">            return &quot;failed&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;支付宝回调,sign: &#123;&#125;, trade_status: &#123;&#125;, 参数: &#123;&#125;&quot;, params.get(&quot;sign&quot;), params.get(&quot;trade_status&quot;), params.toString());</span><br><span class="line"></span><br><span class="line">        //验证回调的正确性</span><br><span class="line">        params.remove(&quot;sign_type&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean alipayRSACheck = AlipaySignature.rsaCheckV2(params, Configs.getAlipayPublicKey(), &quot;utf-8&quot;, Configs.getSignType());</span><br><span class="line">            if (!alipayRSACheck) &#123;</span><br><span class="line">                //非法请求</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (AlipayApiException e) &#123;</span><br><span class="line">            log.error(&quot;支付宝验证回调异常&quot;, e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //验证各种数据</span><br><span class="line">        //业务代码</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里注意一点，用SpringBoot打包的时候，如果按照平时的方法打包，会报错，找不到Alipay的类（SSM同理）</p><p>在maven里面</p><p>加上下面的配置</p><p>外部jar包根据实际情况自行进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                    &lt;compilerArguments&gt;</span><br><span class="line">                        &lt;extdirs&gt;$&#123;project.basedir&#125;/src/main/resources/lib&lt;/extdirs&gt;</span><br><span class="line">                    &lt;/compilerArguments&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/08/02/SpringBoot整合支付宝-当面付(二)/01.png&quot;&gt;
&lt;p&gt;在上一篇简单将一个支付宝Demo跑起来后，现在需要整合到我们的springBoot项目，虽然说是整合SpringBoot，但是，你SSM也都是可以的&lt;/p&gt;
&lt;p&gt;我
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="支付宝当面付" scheme="http://yoursite.com/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%BD%93%E9%9D%A2%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合支付宝-当面付(一)</title>
    <link href="http://yoursite.com/2019/08/02/SpringBoot%E6%95%B4%E5%90%88%E6%94%AF%E4%BB%98%E5%AE%9D-%E5%BD%93%E9%9D%A2%E4%BB%98(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/08/02/SpringBoot整合支付宝-当面付(一)/</id>
    <published>2019-08-02T08:10:15.000Z</published>
    <updated>2019-08-25T00:59:29.248Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/01.png"><p>闲话不多讲直接上干货</p><p>以下是当面付的Demo</p><p><a href="https://docs.open.alipay.com/54/104506" target="_blank" rel="noopener">https://docs.open.alipay.com/54/104506</a></p><p>这里我们先下载Java版的下来看看</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/02.jpg"><p>这是一个Eclipse版的Web项目，我这里使用的工具是IDEA，需要转换一下</p><p>点击File—&gt;Project Structure</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/03.png"><p>添加好之后点击右下角Apply，项目会多一个web目录</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/04.jpg"><p>选择好项目的模块右下角点击Apply</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/05.png"><p>将原先的webroot下面jsp和图片放到web下</p><p>启动项目,进入二维码支付</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/06.jpg"><p>启动项目会报错，查看控制台，会看到乱码，产生问题原因是我们没有在zfbinfo.properties写对应的配置</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/07.png"><p>我们需要去蚂蚁金服开放平台登陆入驻，</p><p>做好登陆入驻后：</p><p>在右上角点击管理中心—–&gt;开发中心——&gt;研发服务</p><p>我们使用沙箱环境</p><p>里面有APPID等信息，对应填上我们的配置文件里面就可以了</p><p>我们现在是开发环境：（需要修改的配置项）</p><p>把支付宝网关的地址<a href="https://openapi.alipay.com/gateway.do修改为https://openapi.alipaydev.com/gateway.do" target="_blank" rel="noopener">https://openapi.alipay.com/gateway.do修改为https://openapi.alipaydev.com/gateway.do</a></p><p>appid：对应的APPID</p><p>pid：商户UID</p><p>密钥生成：</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/08.jpg"><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/09.png"><p>将生成的商户应用密钥的私钥和公钥对应配置到zfbinfo.properties中的private_key和public_key中</p><p>我们使用：SHA256withRsa对应支付宝公钥</p><p>在沙箱应用的</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/10.png"><p>点击查看应用公钥，点击修改，将刚才生成的商户应用公钥粘贴进去，修改完成后，点击查看支付宝公钥</p><p>将支付宝公钥配置到zfbinfo.properties的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#SHA256withRsa对应支付宝公钥</span><br><span class="line">alipay_public_key=xxxxxxxxx</span><br></pre></td></tr></table></figure><p>重启项目</p><img src="/2019/08/02/SpringBoot整合支付宝-当面付(一)/11.png"><p>成功了之后用我们的支付宝扫一下</p><p>停！我们要使用沙箱专用的支付宝才行</p><p>我们在沙箱工具里面<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=tool" target="_blank" rel="noopener">https://openhome.alipay.com/platform/appDaily.htm?tab=tool</a></p><p>下载沙箱版的钱包，账号密码和支付密码，在对应的沙箱账号里面有显示</p><p>本文篇幅有点过长，决定使用两篇文章来写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/08/02/SpringBoot整合支付宝-当面付(一)/01.png&quot;&gt;
&lt;p&gt;闲话不多讲直接上干货&lt;/p&gt;
&lt;p&gt;以下是当面付的Demo&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.open.alipay.com/54/10450
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="支付宝当面付" scheme="http://yoursite.com/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%BD%93%E9%9D%A2%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者</title>
    <link href="http://yoursite.com/2019/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85/"/>
    <id>http://yoursite.com/2019/08/01/设计模式-建造者/</id>
    <published>2019-08-01T09:20:11.000Z</published>
    <updated>2019-11-26T03:19:35.924Z</updated>
    
    <content type="html"><![CDATA[<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><strong>将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表示</strong></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>如果一个对象有非常复杂的内部结构，可以把复杂对象的创建和适用分离</p><p>扩展性好，建造类之间独立</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>产生多余的Builder</p><p>产生的内部发生变化，建造者都要修改，成本较大</p><p>适用于规模固定的场景</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>创建一个产品类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Product &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Double price;</span><br><span class="line">    //隐藏了set方法和toString方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个产品的一个构建者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface ProductBuilder &#123;</span><br><span class="line">    void buildProductName(String name);</span><br><span class="line">    void buildProductPrice(Double price);</span><br><span class="line">    Product makeProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现产品构建者的实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ProductActualBuilder implements ProductBuilder &#123;</span><br><span class="line"></span><br><span class="line">    private Product product = new Product();</span><br><span class="line"></span><br><span class="line">    public void buildProductName(String name) &#123;</span><br><span class="line">        product.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void buildProductPrice(Double price) &#123;</span><br><span class="line">        product.setPrice(price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Product makeProduct() &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上一张图以表示它们之间的关系</p><img src="/2019/08/01/设计模式-建造者/01.png"><p>测试Demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ProductBuilder productBuilder = new ProductActualBuilder();</span><br><span class="line">        productBuilder.buildProductName(&quot;aaa&quot;);</span><br><span class="line">        productBuilder.buildProductPrice(100.0);</span><br><span class="line">        Product product = productBuilder.makeProduct();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子我们就完成了建造者设计模式的一个完整demo了</p><h4 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h4><p>这一个设计模式下来，看上去，和我们直接调用set方法没啥区别，的确，就是一样样的</p><p>buildProductName和setProductName，从某个角度，可以看似一样的东西，但是，一般来讲，我们从名字上可以区分set就是设值操作，build是一个更为抽象的东西，我build一个房子，里面包含了许多build步骤，而set操作只是对对象的某个属性赋值而已，由于是Demo原因，这里看上去build和set的功能一样罢了，但是实际上build里面可以包含很多复杂的操作</p><p>而本次案例当中build方法比较简单，只是为了来说明一下构建者模式仅此而已</p><p>接下来我们来写一个<strong>链式调用的构建者模式</strong></p><p>一样是Product类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Product &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Double price;</span><br><span class="line"></span><br><span class="line">    private Product(ProductBuilder productBuilder)&#123;</span><br><span class="line">        this.name = productBuilder.name;</span><br><span class="line">        this.price = productBuilder.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ProductBuilder&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private Double price;</span><br><span class="line"></span><br><span class="line">        public ProductBuilder buildProductName(String name)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ProductBuilder buildProductPrice(Double price)&#123;</span><br><span class="line">            this.price = price;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Product build()&#123;</span><br><span class="line">            return new Product(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Product&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别的地方在于，在Product类里面实现了构建者</p><p>TestDemo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       Product product = new Product.ProductBuilder().buildProductName(&quot;build&quot;)</span><br><span class="line">               .buildProductPrice(100.2).build();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子，代码更加精简</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>建造者，用于对复杂对象的构造、初始化，与工厂模式不同的是，建造者的目的在于把复杂构造过程从不同对象展现中抽离出来，使得同样的构造工序可以展现出不同的产品对象。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; title=&quot;建造者模式&quot;&gt;&lt;/a&gt;建造者模式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表示&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透</title>
    <link href="http://yoursite.com/2019/07/13/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://yoursite.com/2019/07/13/内网穿透/</id>
    <published>2019-07-13T13:55:00.000Z</published>
    <updated>2019-08-25T00:59:15.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是内网和外网"><a href="#什么是内网和外网" class="headerlink" title="什么是内网和外网"></a>什么是内网和外网</h3><p>所谓内网就是内部建立的局域网络或办公网络。举个例：一家公司或一个家庭有多台计算机，他们利用不同网络布局将这一台或多台计算机或其它设备连接起来构成一个局部的办公或者资源共享网络，我们就称它为内部网络，也叫内网。</p><img src="/2019/07/13/内网穿透/01.jpg"><p>所谓外网就是通过一个网关或网桥与其它网络系统连接，相对于自己的内网来说，连接的其它网络系统就称为外部网络，也叫外网。举例说明：当一家公司或一个家庭的所有电脑网络想要与公司或家庭以外的网络连接（比如连接互连网），相对于这家公司或家庭，其它网络（或互连网）就称为外网！</p><h3 id="为什么需要内网穿透"><a href="#为什么需要内网穿透" class="headerlink" title="为什么需要内网穿透"></a>为什么需要内网穿透</h3><p>简单来说：</p><p><strong>当内网中的主机没有静态IP地址却要被外网稳定访问时可以使用内网穿透</strong></p><p>在互联网中唯一定位一台主机的方法是通过公网的IP地址，但固定IP是一种非常稀缺的资源，不可能给每个公司都分配一个，且许多中小公司不愿意为高昂的费用买单，多数公司直接或间接的拨号上网，电信部门会给接入网络的用户分配IP地址，以前上网用户少的时候基本分配的都是临时的静态IP地址，租约过了之后可能会更换成另一个IP地址，这样外网访问就不稳定，因为内网的静态IP地址一直变化，为了解决这个问题可以使用动态域名解析的办法变换域名指向的静态IP地址。但是现在越来越多的上网用户使得临时分配的静态IP地址也不够用了，电信部门开始分配一些虚拟的静态IP地址，这些IP是公网不能直接访问的，如以125开头的一些IP地址，以前单纯的动态域名解析就不好用了。</p><h3 id="内网穿透的定义与障碍"><a href="#内网穿透的定义与障碍" class="headerlink" title="内网穿透的定义与障碍"></a>内网穿透的定义与障碍</h3><p><strong>当内网中的主机没有静态IP地址要被外网稳定访问时可以使用内网穿透</strong></p><p><strong>障碍一</strong>：位于局域网内的主机有两套 IP 地址，一套是局域网内的 IP 地址，通常是动态分配的，仅供局域网内的主机间通信使用；一套是经过网关转换后的外网 IP 地址，用于与外网程序进行通信。</p><img src="/2019/07/13/内网穿透/02.png"><p>障碍二：位于不同局域网内的两台主机，即使是知道了对方的 IP 地址和端口号，“一厢情愿”地将数据包发送过去，对方也是接收不到的。</p><p>因为出于安全起见，除非是主机主动向对方发出了连接请求（这时会在该主机的数据结构中留下一条记录），否则，当主机接收到数据包时，如果在其数据结构中查询不到对应的记录，那些不请自来的数据包将会被丢弃。</p><img src="/2019/07/13/内网穿透/03.png"><p><strong>解决办法：要想解决以上两大障碍，我们需要借助一台具有公网 IP 的服务器进行桥接。</strong></p><h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><p>ngrok是一个反向代理，通过在公共的端点和本地运行的Web服务器之间建立一个安全的通道。ngrok可捕获和分析所有通道上的流量，便于后期分析与响应。</p><img src="/2019/07/13/内网穿透/04.png"><p>没有ngrok的时候</p><p>作为一个Web开发者，我们有时候会需要临时地将一个本地的Web网站部署到外网，以供他人体验评价或协助调试等等，通常我们会这么做：</p><ol><li><p>找到一台运行于外网的Web服务器</p></li><li><p>服务器上有网站所需要的环境，否则自行搭建</p></li><li><p>将网站部署到服务器上</p></li><li>调试结束后，再将网站从服务器上删除</li></ol><p>有ngrok的时候</p><ol><li>首先注册并下载ngrok，得到一串授权码</li><li>ngrok -authtoken 你的授权码 80，80是你本地Web服务的端口，而之后ngrok会记住你的授权码，直接ngrok 80就OK了</li><li>你会得到一串网址，通过这个网址就可以访问你本地的Web服务了</li></ol><p>去官方注册个账号或者使用github账号登陆一下,有步骤介绍</p><img src="/2019/07/13/内网穿透/05.png"><p>下载ngrok，这里以Windows为例子</p><p>下载的是一个压缩包，解压后，用CMD进入到该目录下执行以下命令,后面是一个token值，随便打即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ngrok authtoken (authtoken看自己的token值，登陆之后在Auth下可以查看)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ngrok http 8080</span><br></pre></td></tr></table></figure><img src="/2019/07/13/内网穿透/06.jpg"><p>解析来我们就可以拿着对应的域名来访问了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是内网和外网&quot;&gt;&lt;a href=&quot;#什么是内网和外网&quot; class=&quot;headerlink&quot; title=&quot;什么是内网和外网&quot;&gt;&lt;/a&gt;什么是内网和外网&lt;/h3&gt;&lt;p&gt;所谓内网就是内部建立的局域网络或办公网络。举个例：一家公司或一个家庭有多台计算机，他们利用不
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://yoursite.com/2019/06/23/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yoursite.com/2019/06/23/布隆过滤器/</id>
    <published>2019-06-23T14:51:43.000Z</published>
    <updated>2019-08-25T00:59:04.686Z</updated>
    
    <content type="html"><![CDATA[<p>先探讨一个问题？</p><p>现在有50亿个电话号码，现在要快速准确判断这些电话号码是否已经存在？</p><ol><li>数据库查询？太慢了</li><li>数据使用集合存放在内存？内存浪费</li><li>布隆过滤器！</li></ol><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><h4 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h4><p>它实际上是一个很长的二进制向量和一系列随机映射函数</p><h4 id="布隆过滤器的实现原理"><a href="#布隆过滤器的实现原理" class="headerlink" title="布隆过滤器的实现原理"></a>布隆过滤器的实现原理</h4><p>当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>画个图描述一下</p><img src="/2019/06/23/布隆过滤器/01.jpg"><h4 id="布隆过滤器的误差率"><a href="#布隆过滤器的误差率" class="headerlink" title="布隆过滤器的误差率"></a>布隆过滤器的误差率</h4><p>直观因素：m/n的比率，hash函数的个数</p><p>1个元素，1个hash函数，任意一个比特为1的概率为1/m，依然为0的概率为1-1/m</p><p>k给函数，依然为0的概率为（1-1/m）^k，n个元素，依然为0的概率为(1-1/m)^nk</p><p>被设置为1的概率为1-(1-1/m)^nk</p><p>新元素权重的概率为（1-(1-1/m)^nk）^k</p><h4 id="本地布隆过滤器"><a href="#本地布隆过滤器" class="headerlink" title="本地布隆过滤器"></a>本地布隆过滤器</h4><p>使用Guava来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class BloomFilterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //构建布隆过滤器</span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(new Funnel&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void funnel(String s, PrimitiveSink primitiveSink) &#123;</span><br><span class="line">                primitiveSink.putString(s, Charsets.UTF_8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,10000,0.0001);</span><br><span class="line">        //插入数据</span><br><span class="line">        for (int i = 0 ; i &lt; 1000 ; i++)&#123;</span><br><span class="line">            bloomFilter.put(&quot;i_&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        //测试结果</span><br><span class="line">        for (int i = 0 ; i &lt; 1005 ; i++)&#123;</span><br><span class="line">            if(!bloomFilter.mightContain(&quot;i_&quot;+i))&#123;</span><br><span class="line">                System.out.println(&quot;no&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于Redis的布隆过滤器"><a href="#基于Redis的布隆过滤器" class="headerlink" title="基于Redis的布隆过滤器"></a>基于Redis的布隆过滤器</h4><p>redis 在 4.0 的版本中加入了 module 功能，布隆过滤器可以通过 module 的形式添加到 redis 中，所以使用 redis 4.0 以上的版本可以通过加载 module 来使用 redis 中的布隆过滤器</p><p>在Docker中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker run -d -p 6379:6379 --name bloomfilter redislabs/rebloom</span><br><span class="line">&gt; docker exec -it bloomfilter redis-cli</span><br><span class="line"># redis-cli</span><br><span class="line"># 127.0.0.1:6379&gt;</span><br><span class="line"># 127.0.0.1:6379&gt; BF.ADD newFilter foo</span><br><span class="line">(integer) 1</span><br><span class="line"># 127.0.0.1:6379&gt; BF.EXISTS newFilter foo</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先探讨一个问题？&lt;/p&gt;
&lt;p&gt;现在有50亿个电话号码，现在要快速准确判断这些电话号码是否已经存在？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库查询？太慢了&lt;/li&gt;
&lt;li&gt;数据使用集合存放在内存？内存浪费&lt;/li&gt;
&lt;li&gt;布隆过滤器！&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;布隆
      
    
    </summary>
    
      <category term="技术分享" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis-缓存设计</title>
    <link href="http://yoursite.com/2019/05/27/Redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/05/27/Redis-缓存设计/</id>
    <published>2019-05-27T14:49:16.000Z</published>
    <updated>2019-08-25T00:58:51.110Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/27/Redis-缓存设计/01.png"><h3 id="缓存有什么作用？"><a href="#缓存有什么作用？" class="headerlink" title="缓存有什么作用？"></a>缓存有什么作用？</h3><p>先来看一幅图</p><img src="/2019/05/27/Redis-缓存设计/02.png"><p>缓存主要带来了什么好处呢？</p><ol><li><p>加速读写</p><p>因为缓存通常都是全内存的（例如Redis、Memcache），而存储层通常读写性能不够强悍（例如MySQL），通过缓存的使用可以有效地加速读写，优化用户体验</p></li><li><p>降低后端负载</p><p>帮助后端减少访问量和复杂计算（例如很复杂的SQL语句），在很大程度降低了后端的负载</p></li></ol><p>当然，缓存能够给我们带来好的方便，但是也加大了开发者的开发成本</p><p>接下来我们就来学习下如何使用Redis来设计缓存，以及注意的问题：</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存中的数据通常都是有生命周期的，需要在指定时间后被删除或更新，这样可以保证缓存空间在一个可控的范围。</p><p>三种策略：</p><h4 id="LRU-LFU-FIFO算法剔除"><a href="#LRU-LFU-FIFO算法剔除" class="headerlink" title="LRU/LFU/FIFO算法剔除"></a>LRU/LFU/FIFO算法剔除</h4><p>通常用于缓存使用量超过了预设的最大值时候，如何对现有的数据进行剔除。例如Redis使用maxmemory-policy这个配置作为内存最大值后对于数据的剔除策略,还要设置maxmemory（最大内存）</p><p>maxmemory 默认为0（代表不限制Redis的内存使用）</p><p>maxmemory-policy有六种策略</p><ol><li>noeviction: 不进行置换，表示即使内存达到上限也不进行置换，所有能引起内存增加的命令都会返回error</li><li>allkeys-lru: 优先删除掉最近最不经常使用的key，用以保存新数据</li><li>volatile-lru: 只从设置失效（expire set）的key中选择最近最不经常使用的key进行删除，用以保存新数据</li><li>allkeys-random: 随机从all-keys中选择一些key进行删除，用以保存新数据</li><li>volatile-random: 只从设置失效（expire set）的key中，选择一些key进行删除，用以保存新数据</li><li>volatile-ttl: 只从设置失效（expire set）的key中，选出存活时间（TTL）最短的key进行删除，用以保存新数据</li></ol><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>使用简单，只用修改对应的配置文件就可以</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>数据的清理由选择算法决定，开发人员只能选择置换内存的算法策略，所以数据的一致性是最差的</p><h4 id="超时剔除"><a href="#超时剔除" class="headerlink" title="超时剔除"></a>超时剔除</h4><p>超时剔除通过给缓存数据设置过期时间，让其在过期时间后自动删除，Redis提供了expire命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ EXPIRE key time(s)</span><br></pre></td></tr></table></figure><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>使用简单，只需要设置对应key的过期时间即可</p><p>能够允许在一段时间内的数据不一致或者是数据对实际业务影响不大的场景，此方案还是很好的解决方案</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>数据不一致：如果，数据对实际业务影响比较大的场景，谨慎使用，特别涉及到金钱交易的情况下</p><h4 id="主动更新"><a href="#主动更新" class="headerlink" title="主动更新"></a>主动更新</h4><p>应用方对于数据的一致性要求高，需要在真实数据更新后，立即更新缓存数据。例如可以利用消息系统或者其他方式通知缓存更新</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>可以根据自己的业务需求来完成缓存的更新，解决了单纯使用expire设置过期时间的局限性</p><p>一致性最高，但如果主动更新发生了问题，那么这条数据很可能很长时间不会更新，所以建议结合超时剔除一起使用效果会更好</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>维护成本会比较高，开发者需要自己来完成更新，并保证更新操作的正确性</p><img src="/2019/05/27/Redis-缓存设计/03.png"><p>有两个建议：</p><ol><li>低一致性业务建议配置最大内存和淘汰策略的方式使用</li><li>高一致性业务可以结合使用超时剔除和主动更新，这样即使主动更新出了问题，也能保证数据过期时间后删除脏数据</li></ol><h3 id="缓存粒度"><a href="#缓存粒度" class="headerlink" title="缓存粒度"></a>缓存粒度</h3><p>很多时候我们缓存的值是后端Mysql或者别的数据库查询出来的值，因为一般来说，复杂的查询比较费时，所以查询出来放进redis是一个比较明智的做法</p><p>那么我们要缓存多少，缓存到一个什么层度呢？</p><p>比如说：缓存所有列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:&#123;id&#125; &apos;select * from user where id=&#123;id&#125;&apos;</span><br></pre></td></tr></table></figure><p>缓存部分列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set user:&#123;id&#125; &apos;select &#123;importantColumn1&#125;, &#123;important Column2&#125; ... &#123;importantColumnN&#125;</span><br><span class="line">from user where id=&#123;id&#125;&apos;</span><br></pre></td></tr></table></figure><p>这个问题就是缓存粒度问题</p><p>缓存全部数据要比部分数据占用更多的空间，可能存在以下问题：</p><ol><li>全部数据会造成内存的浪费</li><li>全部数据可能每次传输产生的网络流量会比较大，耗时相对较大，在极端情况下会阻塞网络</li><li>全部数据的序列化和反序列化的CPU开销更大</li></ol><img src="/2019/05/27/Redis-缓存设计/04.png"><p>缓存粒度问题是一个容易被忽视的问题，如果使用不当，可能会造成很多无用空间的浪费，网络带宽的浪费，代码通用性较差等情况，需要综合数据通用性、空间占用比、代码维护性三点进行取舍</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><img src="/2019/05/27/Redis-缓存设计/05.png"><p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，当被别人恶意访问查询一个不存在的数据的时候，请求就会访问到存储层（Mysql），当请求量很大的情况下，Mysql是承受不了的，可能造成后端存储宕掉，而且缓存层也失去了保护存储层的意义</p><p>解决办法：</p><ol><li><p>缓存空对象</p><p>当第2步存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源，缺点：</p><ol><li><p>缓存层中存了更多的键，需要更多的内存空间(也是一种危害)</p><p><strong>措施：是将这类的Key设置一个较短的过期时间</strong></p></li><li><p>缺点：缓存层和存储层的短暂不一致</p><p><strong>措施：可以利用消息系统或者其他方式清除掉缓存层中的空对象</strong></p></li></ol></li><li><p>布隆过滤器</p><p>在访问缓存层之前，将存在的key用布隆过滤器提前保存起来,当访问不存在的key的时候，布隆过滤器直接返回，可以避免访问缓存层和存储层</p></li><li><p>使用互斥锁：根据key获取value值为空时，锁上，从数据库中load数据后再释放锁（适合并发量比较低的情况，因为并发量很大的情况下，会导致阻塞和死锁的情况）</p></li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>由于缓存层承载大量请求，当cache服务异常/脱机，流量打向了后端的存储层，造成存储层也会级联宕机的情<br>况，除了缓存服务异常和脱机的情况，还有另外一种情况：缓存key大片面积失效（时间到期）也会导致缓存雪崩</p><img src="/2019/05/27/Redis-缓存设计/06.png"><p>关于解决缓存服务异常和脱机需要注意的几个问题:</p><ol><li><p>保证缓存层服务高可用性</p><p>如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务</p></li><li><p>依赖隔离组件为后端限流并降级</p><p>我们需要对重要的资源（例如Redis、MySQL、HBase、外部接口）都进行隔离，让每种资源都单独运行在自己的线程池中，即使个别资源出现了问题，对其他服务没有影响</p></li><li><p>提前演练</p><p>演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定</p></li></ol><p>解决方案：</p><ol><li>在设置缓存时候，不设置统一的过期时间，而是在一个范围内随机设置过期时间，以防止大量的key同时过期</li><li>使用互斥锁：根据key获取value值为空时，锁上，从数据库中load数据后再释放锁（适合并发量比较低的情况，因为并发量很大的情况下，会导致阻塞和死锁的情况）</li><li>提前使用互斥锁，比如key10S过期，在内部使用一个标识key 8S过期，假设标识key过期的时候，就给对应的Key延长过期时间</li><li>双缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，如果A没有则读B，并且更新A缓存和B缓存（对存储的消耗比较大）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/27/Redis-缓存设计/01.png&quot;&gt;
&lt;h3 id=&quot;缓存有什么作用？&quot;&gt;&lt;a href=&quot;#缓存有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;缓存有什么作用？&quot;&gt;&lt;/a&gt;缓存有什么作用？&lt;/h3&gt;&lt;p&gt;先来看一
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-抽象工厂</title>
    <link href="http://yoursite.com/2019/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>http://yoursite.com/2019/05/27/设计模式-抽象工厂/</id>
    <published>2019-05-27T10:25:23.000Z</published>
    <updated>2019-11-18T06:50:57.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p><strong>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口</strong></p><ul><li>客户端（应用层）不依赖于产品类实例如何被创建，实现等细节</li><li>强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码</li><li>具体产品在应用层代码隔离，无需关系创建细节</li><li>将一个系列的产品族一起创建</li></ul><p>产品族：这里画个图来帮助理解</p><img src="/2019/05/27/设计模式-抽象工厂/01.jpg"><p>比如说，小米的所有子产品都属于一个产品族</p><p>前面学的工厂方法所关注的就是产品等级结构：就如图中的小米电脑和苹果电脑，都属于电脑</p><p>这里的抽象工厂关注的是一个产品族:我们只需要指出一个产品所处于的产品族以及所属的等级结构就能唯一确定这个产品（举个例子：从小米工厂取出的手机——》就是小米手机）</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>工厂接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 品牌工厂</span><br><span class="line"> */</span><br><span class="line">public interface BrandFactory &#123;</span><br><span class="line">    Phone getPhone();//获得手机</span><br><span class="line">    LapTop getLapTop();//获得手提电脑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个抽象实体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 手提电脑</span><br><span class="line"> */</span><br><span class="line">public abstract class LapTop &#123;</span><br><span class="line">    public abstract void produce();//生产手提电脑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 手机</span><br><span class="line"> */</span><br><span class="line">public abstract class Phone &#123;</span><br><span class="line">    public abstract void produce();//生产手机</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个具体的工厂:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 苹果工厂</span><br><span class="line"> */</span><br><span class="line">public class AppleFactory implements BrandFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone getPhone() &#123;</span><br><span class="line">        return new ApplePhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LapTop getLapTop() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 小米工厂</span><br><span class="line"> */</span><br><span class="line">public class MiFactory implements BrandFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone getPhone() &#123;</span><br><span class="line">        return new MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LapTop getLapTop() &#123;</span><br><span class="line">        return new MiLapTop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个手机的实现类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 小米手机</span><br><span class="line"> */</span><br><span class="line">public class MiPhone extends Phone &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产小米手机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 苹果手机</span><br><span class="line"> */</span><br><span class="line">public class ApplePhone extends Phone &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产苹果手机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个笔记本的实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 苹果笔记本</span><br><span class="line"> */</span><br><span class="line">public class AppleLapTop extends LapTop &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产苹果笔记本&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 小米笔记本</span><br><span class="line"> */</span><br><span class="line">public class MiLapTop extends LapTop &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产小米笔记本&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下类图</p><img src="/2019/05/27/设计模式-抽象工厂/02.png"><p>写个测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BrandFactory brandFactory = new MiFactory();</span><br><span class="line">        Phone phone = brandFactory.getPhone();</span><br><span class="line">        LapTop lapTop = brandFactory.getLapTop();</span><br><span class="line">        phone.produce();//输出生产小米手机</span><br><span class="line">        lapTop.produce();//输出小米笔记本</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>在抽象工厂里面，对于应用层，根本不关心手机和笔记本的实现过程，只关心对应的一个工厂，在哪个工厂取得的产品也就是什么工厂的产品，还是上面的例子（小米工厂拿到的手机就是小米手机）</strong></p><p>应用层代码和具体的手机是解耦的，和具体的笔记本电脑也是解耦的</p><p>工厂方法和抽象工厂的最大区别是：</p><p><strong>工厂方法关注的是同一产品等级，抽象工厂关注的是产品族</strong></p><p>抽象工厂</p><p>优点：</p><ol><li>应用层代码不和具体的产品发生依赖，只和具体的产品族工厂发生依赖</li><li>从某个工厂取出的产品，一定是属于这个工厂的产品</li><li>扩展性好，比如增加一个华为的品牌，只用增加一个工厂，一个手机，一个笔记本即可，其余不用发生改变（符合开闭原则）<strong>产品等级稳定的情况下</strong></li></ol><p>缺点：</p><ol><li>新增产品等级的时候，会在原有的结构上进行较大的改动（比如说，增加一个小米生产的别的产品）此时就违背了开闭原则，所以要注意场景使用</li></ol><p><strong>举个真实的例子：在java.sql这个包下Connection这个接口里面PrepareStatement和Statement都是属于一个产品族在这里，就使用到了抽象工厂的设计模式</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;抽象工厂&quot;&gt;&lt;a href=&quot;#抽象工厂&quot; class=&quot;headerlink&quot; title=&quot;抽象工厂&quot;&gt;&lt;/a&gt;抽象工厂&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端（
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Cluster常见问题</title>
    <link href="http://yoursite.com/2019/05/26/Redis-Cluster%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/26/Redis-Cluster常见问题/</id>
    <published>2019-05-26T13:00:30.000Z</published>
    <updated>2019-08-25T00:58:28.202Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/26/Redis-Cluster常见问题/01.png"><h3 id="集群完整性"><a href="#集群完整性" class="headerlink" title="集群完整性"></a>集群完整性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 默认为yes</span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure><p>默认的配置保证了两个问题：</p><ul><li>集群中的161384个槽全部可用，保证了集群的完整性</li><li>节点故障或者故障转移的时候，进行set操作会报 (error) CLUSTERRDOWN The cluster is down</li></ul><p>一个节点坏了，整个集群都不可用了，这在实际业务上是有问题的</p><p>所以我们通常需要将它修改为no</p><h3 id="带宽消耗"><a href="#带宽消耗" class="headerlink" title="带宽消耗"></a>带宽消耗</h3><p>RedisCluster会定期进行Ping/Pong进行心跳检测，也会进行信息的一个交互</p><p>官方建议RedisCluster的节点数量不要超过1000个，因为RedisCluster对带宽的消耗很高</p><p>主要来自下面三个方面</p><ul><li>消息发送频率，节点发现与其他节点最后通信时间超过cluster-node-timeout/2时会直接发送ping消息</li><li>消息数据量：slots槽数组（2KB空间）和整个集群1/10的状态数据（10个节点的状态数据约1KB）</li><li>节点部署的机器规模：集群分布的机器越多且每台机器划分的节点数越均匀，则集群内整体的可用带宽就越高</li></ul><p>举个例子：</p><p>规模：节点200个，20台物理机（每台10个节点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-node-timeout = 15000</span><br></pre></td></tr></table></figure><p>ping/pong的带宽为25Mb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-node-timeout = 20000</span><br></pre></td></tr></table></figure><p>ping/pong带宽会低于15Mb</p><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><ol><li>避免多业务使用一个集群，大业务可以多集群</li><li>cluster-node-timeout:带宽和故障转移速度的均衡</li><li>尽量均匀分配到多机器上，保证高可用和带宽</li></ol><h3 id="Pub-Sub广播"><a href="#Pub-Sub广播" class="headerlink" title="Pub/Sub广播"></a>Pub/Sub广播</h3><p>问题：publish在集群每个节点广播：加重带宽</p><p>解决：针对这种情况建议使用sentinel结构专门用于Pub/Sub功能，从而<br>规避这一问题。</p><h3 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h3><p>集群内特定节点<strong>数据量</strong>过大将导致节点之间负载不均，影响集群均衡和运维成本。</p><p>数据倾斜主要分为以下几种：</p><ol><li><p>·节点和槽分配严重不均。</p><p>当节点对应槽数量不均匀时，可以使用redis-trib.rb rebalance命令进行平衡</p></li><li><p>·不同槽对应键数量差异过大。</p><p>通过命令：cluster countkeysinslot{slot}可以获取槽对应的键数量，识别出哪些槽映射了过多的键。再通过命令clustergetkeysinslot{slot}{count}循环迭代出槽下所有的键。</p></li><li><p>·集合对象包含大量元素。</p><p>对于大集合对象的识别可以使用redis-cli–bigkeys命令识别</p></li><li><p>·内存相关配置不一致。</p><p>当集群大量使用hash、set等数据结构时，如果内存压缩数据结构配置不一致，极端情况下会相差数倍的内存，从而造成节点内存量倾斜。</p></li></ol><h3 id="请求倾斜"><a href="#请求倾斜" class="headerlink" title="请求倾斜"></a>请求倾斜</h3><p>集群内特定节点<strong>请求量/流量</strong>过大将导致节点之间负载不均，影响集群均衡和运维成本。</p><p>避免方式如下：</p><ol><li>合理设计键，热点大集合对象做拆分或使用hmget替代hgetall避免整体读取。</li><li>不要使用热键作为hash_tag，避免映射到同一槽。</li><li>对于一致性要求不高的场景，客户端可使用本地缓存减少热键调用。</li></ol><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="只读连接"><a href="#只读连接" class="headerlink" title="只读连接"></a>只读连接</h4><p>集群模式下从节点不接受任何读写请求，发送过来的键命令会重定向到负责槽的主节点上（其中包括它的主节点）</p><p>当需要使用从节点分担主节点读压力时，可以使用readonly命令打开客户端连接只读状态。</p><p><strong>注意：readonly是连接级别生效，每次连接都要开启一遍才可以</strong></p><img src="/2019/05/26/Redis-Cluster常见问题/02.png"><h4 id="读写分离-1"><a href="#读写分离-1" class="headerlink" title="读写分离"></a>读写分离</h4><p>问题：复制延迟，读取过期数据，从节点故障</p><p>集群模式下读写分离涉及对客户端修改如下：</p><ol><li>维护每个主节点可用从节点列表</li><li>针对读命令维护请求节点路由</li><li>从节点新建连接开启readonly转态</li></ol><p><strong>集群模式下读写分离成本比较高，可以直接扩展主节点数量提高集群性能，一般不建议集群模式下做读写分离</strong></p><p>集群读写分离有时用于特殊业务场景如：</p><ol><li>利用复制的最终一致性使用多个从节点做跨机房部署降低读命令网络延迟。</li><li>主节点故障转移时间过长，业务端把读请求路由给从节点保证读操作可用。</li></ol><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>应用Redis集群时，常需要把单机Redis数据迁移到集群环境。redis-trib.rb工具提供了导入功能，用于数据从单机向集群环境迁移的场景，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-trib.rb import host:port --from &lt;arg&gt; --copy --replace</span><br></pre></td></tr></table></figure><img src="/2019/05/26/Redis-Cluster常见问题/03.png"><p>redis-trib.rb import命令内部采用批量scan和migrate的方式迁移数据。这<br>种迁移方式存在以下缺点：</p><ol><li>迁移只能从单机节点向集群环境导入数据。</li><li>不支持在线迁移数据，迁移数据时应用方必须停写，无法平滑迁移<br>数据。</li><li>迁移过程中途如果出现超时等错误，不支持断点续传只能重新全量<br>导入。</li><li>使用单线程进行数据迁移，大数据量迁移速度过慢</li></ol><p>正因为这些问题，社区开源了很多迁移工具，这里推荐一款唯品会开发的redis-migrate-tool，该工具可满足大多数Redis迁移需求，特点如下：</p><ol><li>·支持单机、Twemproxy、Redis Cluster、RDB/AOF等多种类型的数据迁移</li><li>工具模拟成从节点基于复制流迁移数据，从而支持在线迁移数据，业务方不需要停写</li><li>采用多线程加速数据迁移过程且提供数据校验和查看迁移状态等功能</li></ol><h3 id="集群VS单机"><a href="#集群VS单机" class="headerlink" title="集群VS单机"></a>集群VS单机</h3><h4 id="集群限制"><a href="#集群限制" class="headerlink" title="集群限制"></a>集群限制</h4><ol><li>key批量操作支持有限：mget，mset必须在一个slot上</li><li>key事务和Lua支持有限：操作的key必须在一个节点上</li><li>key是数据分区的最小粒度，不支持bigkey</li><li>不支持多个数据库：集群下只有一个db0</li><li>复制只支持复制一层，不支持树形复制结构</li></ol><h4 id="思考分布式Redis"><a href="#思考分布式Redis" class="headerlink" title="思考分布式Redis"></a>思考分布式Redis</h4><ol><li>RedisCluster:用来满足容量和性能的扩展性，但是要看业务来使用</li><li>大多数情况客户端性能会降低</li><li>命令无法跨节点使用</li><li>Lua和事务无法跨节点使用</li><li>客户端维护更加复杂</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/26/Redis-Cluster常见问题/01.png&quot;&gt;
&lt;h3 id=&quot;集群完整性&quot;&gt;&lt;a href=&quot;#集群完整性&quot; class=&quot;headerlink&quot; title=&quot;集群完整性&quot;&gt;&lt;/a&gt;集群完整性&lt;/h3&gt;&lt;figure clas
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
</feed>
